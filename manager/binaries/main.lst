     1                                  ; asmsyntax=nasm
     2                                  ;
     3                                  ; main.asm
     4                                  ;
     5                                  ; Main programs for Smart Boot Manager
     6                                  ;
     7                                  ; Copyright (C) 2000, Suzhe. See file COPYING for details.
     8                                  ; Copyright (C) 2001, Suzhe. See file COPYING for details.
     9                                  ;
    10                                  
    11                                  %define MAIN
    12                                  %define HAVE_MAIN_PROG
    13                                  ;%define EMULATE_PROG
    14                                  
    15                                  %include "macros.h"
    16                              <1> ; macros.h
    17                              <1> ;
    18                              <1> ; some nasm macros that simplify the coding.
    19                              <1> ;
    20                              <1> ; Copyright (C) 2000, Suzhe. See file COPYING and CREDITS for details.
    21                              <1> ;
    22                              <1> 
    23                              <1> %ifndef DEFINE_MACROS
    24                              <1> %define DEFINE_MACROS
    25                              <1> 
    26                              <1> %macro retz 0
    27                              <1>        jnz %%skip
    28                              <1>        ret
    29                              <1> %%skip:
    30                              <1> %endmacro
    31                              <1> 
    32                              <1> %define jmpz  jz near
    33                              <1> %define jmpnz jnz near
    34                              <1> %define jmpe  je near
    35                              <1> %define jmpne jne near
    36                              <1> %define jmpc  jc near
    37                              <1> %define jmpnc jnc near
    38                              <1> %define jmpa  ja near
    39                              <1> %define jmpna jna near
    40                              <1> %define jmpb  jb near
    41                              <1> %define jmpnb jnb near
    42                              <1> 
    43                              <1> 
    44                              <1> %if 0
    45                              <1> %macro jmpz 1
    46                              <1>        jnz %%skip
    47                              <1>        jmp %1
    48                              <1> %%skip:
    49                              <1> %endmacro
    50                              <1> 
    51                              <1> %macro jmpnz 1
    52                              <1>        jz %%skip
    53                              <1>        jmp %1
    54                              <1> %%skip:
    55                              <1> %endmacro
    56                              <1> 
    57                              <1> %macro jmpe 1
    58                              <1>        jne %%skip
    59                              <1>        jmp %1
    60                              <1> %%skip:
    61                              <1> %endmacro
    62                              <1> 
    63                              <1> %macro jmpne 1
    64                              <1>        je %%skip
    65                              <1>        jmp %1
    66                              <1> %%skip:
    67                              <1> %endmacro
    68                              <1> 
    69                              <1> %macro jmpc 1
    70                              <1>        jnc %%skip
    71                              <1>        jmp %1
    72                              <1> %%skip:
    73                              <1> %endmacro
    74                              <1> 
    75                              <1> %macro jmpnc 1
    76                              <1>        jc %%skip
    77                              <1>        jmp %1
    78                              <1> %%skip:
    79                              <1> %endmacro
    80                              <1> 
    81                              <1> %macro jmpb 1
    82                              <1>        jnb %%skip
    83                              <1>        jmp %1
    84                              <1> %%skip:
    85                              <1> %endmacro
    86                              <1> 
    87                              <1> %macro jmpnb 1
    88                              <1>        jb %%skip
    89                              <1>        jmp %1
    90                              <1> %%skip:
    91                              <1> %endmacro
    92                              <1> 
    93                              <1> %endif
    94                              <1> 
    95                              <1> %endif
    96                                  %include "ui.h"
    97                              <1> ;
    98                              <1> ; ui.h
    99                              <1> ;
   100                              <1> ; header file for ui.asm
   101                              <1> ;
   102                              <1> ; Copyright (C) 2000, Suzhe. See file COPYING and CREDITS for details.
   103                              <1> ;
   104                              <1> 
   105                              <1> ; following flags is used in struc_window.flags
   106                              <1> 
   107                              <1> %define WINFLAG_OPEN		0x01  ; set this flag when open the window
   108                              <1> %define WINFLAG_MODAL		0x02  ; Modal window
   109                              <1> %define WINFLAG_FRAMED		0x04  ; the window has frame.
   110                              <1> %define WINFLAG_NO_FOCUS	0x08  ; Cannot be focused.
   111                              <1> 
   112                              <1> %define MENUFLAG_SCROLLBAR	0x10  ; the menu has scroll bar
   113                              <1> %define MENUFLAG_SINK_WIDTH	0x20  ; reduce the width of menu area by two char
   114                              <1> %define MENUFLAG_SINK_UPPER	0x40  ; reduce the upper of menu area by one char
   115                              <1> %define MENUFLAG_SINK_BOTTOM	0x80  ; ..
   116                              <1> 
   117                              <1> %define WINFLAG_HI_RUNNING	0x01  ; unsed in hi-byte of struc_window.flags
   118                              <1> 
   119                              <1> ; following flags is used in struc_action.flags
   120                              <1> 
   121                              <1> %define ACTFLAG_CLOSE_WIN	0x01  ; close the window after doing the action
   122                              <1> %define ACTFLAG_REDRAW_BODY	0x02  ; redraw window body after doing it
   123                              <1> %define ACTFLAG_REDRAW_WIN	0x04  ; redraw entire window after doing it
   124                              <1> %define ACTFLAG_REDRAW_SCR	0x08  ; redraw entire screen after doint it
   125                              <1> 
   126                              <1> %define ACTFLAG_CHK_RECNUM	0x10  ; check good record number before do it
   127                              <1> %define ACTFLAG_AUTH_ROOT	0x20  ; confirm root password before do it
   128                              <1> %define ACTFLAG_AUTH_RECORD	0x40  ; confirm record password before do it
   129                              <1> %define ACTFLAG_AUTH_SECURITY	0x80  ; confirm password according to security
   130                              <1>                                       ; level
   131                              <1> %define ACTFLAG_AUTHS		0xF0
   132                              <1> 
   133                              <1> %define SIZE_OF_STRUC_WINDOW		struc_window.end_of_struc
   134                              <1> %define SIZE_OF_STRUC_MENU_BOX		struc_menu_box.end_of_struc
   135                              <1> %define SIZE_OF_STRUC_ACTION		struc_action.end_of_struc
   136                              <1> %define SIZE_OF_STRUC_MESSAGE_BOX	struc_message_box.end_of_struc
   137                              <1> %define SIZE_OF_STRUC_INPUT_BOX		struc_input_box.end_of_struc
   138                              <1> 
   139                              <1> struc struc_window
   140 00000000 <res 00000002>      <1> 	.flags			resw 1	; flags
   141 00000002 <res 00000002>      <1> 	.title			resw 1	; 2nd level pointer to window title
   142 00000004 <res 00000002>      <1> 	.win_attr		resw 1  ; window attribute, 
   143                              <1> 					; high = title, low = frame
   144 00000006 <res 00000002>      <1> 	.win_pos		resw 1	; window position, 
   145                              <1> 					; high = row, low = col
   146 00000008 <res 00000002>      <1> 	.win_size		resw 1	; window size,
   147                              <1> 					; high = height, low = width
   148 0000000A <res 00000002>      <1> 	.parent_win		resw 1	; pointer to parent window
   149 0000000C <res 00000002>      <1> 	.next_win		resw 1  ; pointer to next window
   150 0000000E <res 00000002>      <1> 	.previous_win		resw 1  ; pointer to previous window
   151                              <1> 
   152 00000010 <res 00000002>      <1> 	.act_num		resw 1  ; number of actions
   153 00000012 <res 00000002>      <1> 	.act_table		resw 1	; pointer to action table
   154                              <1> 
   155 00000014 <res 00000002>      <1> 	.default_event_handle	resw 1	; default key event handle
   156 00000016 <res 00000002>      <1> 	.event_handle		resw 1	; key event handle
   157 00000018 <res 00000002>      <1> 	.draw_body_proc		resw 1	; draw window body proc
   158                              <1> 	.end_of_struc
   159                              <1> endstruc
   160                              <1> 
   161                              <1> struc struc_action
   162 00000000 <res 00000001>      <1> 	.flags			resb 1	; flags
   163 00000001 <res 00000002>      <1> 	.keycode		resw 1	; keycode
   164 00000003 <res 00000002>      <1> 	.func			resw 1	; function entry
   165                              <1> 	.end_of_struc
   166                              <1> endstruc
   167                              <1> 
   168                              <1> 
   169                              <1> ; For menubox, the actions of menu items are stored in struc_window.act_table.
   170                              <1> ; First items_num actions in act_table are menu items'. Other actions are 
   171                              <1> ; hotkeys.
   172                              <1> 
   173                              <1> struc struc_menu_box
   174                              <1> ; first part is a struc_window data
   175 00000000 <res 0000001A>      <1> 	.window			resb SIZE_OF_STRUC_WINDOW
   176                              <1> 
   177                              <1> ; data member of menu box
   178 0000001A <res 00000002>      <1> 	.menu_header		resw 1	; 2nd level pointer to menu header string
   179 0000001C <res 00000001>      <1> 	.menu_header_attr	resb 1	; attribute of menu header (if have)
   180 0000001D <res 00000002>      <1> 	.menu_norm_attr		resw 1	; attribute of normal menu item, 
   181                              <1> 					; high = hotkey attr, low =normal attr
   182 0000001F <res 00000002>      <1> 	.menu_focus_attr	resw 1	; attribute of focused menu item
   183 00000021 <res 00000002>      <1> 	.menu_area_pos		resw 1	; position of menu area
   184 00000023 <res 00000002>      <1> 	.menu_area_size		resw 1	; size of menu area
   185 00000025 <res 00000001>      <1> 	.scrollbar_attr		resb 1	; attribute of scrollbar
   186                              <1> 
   187 00000026 <res 00000001>      <1> 	.items_num		resb 1	; number of menu items
   188 00000027 <res 00000001>      <1> 	.focus_item		resb 1	; focused item
   189 00000028 <res 00000001>      <1> 	.first_visible_item	resb 1	; first visible item
   190                              <1> 
   191 00000029 <res 00000002>      <1> 	.item_str_proc		resw 1	; proc of get a item's string
   192                              <1> 					; input cx = index, si -> menu
   193                              <1> 					; output si -> string
   194                              <1> 	.end_of_struc
   195                              <1> endstruc
   196                              <1> 
   197                              <1> struc struc_message_box
   198 00000000 <res 0000001A>      <1> 	.window			resb SIZE_OF_STRUC_WINDOW
   199 0000001A <res 00000002>      <1> 	.message		resw 1  ; pointer to the message
   200 0000001C <res 00000002>      <1> 	.message_attr		resw 1  ; attribute of the message
   201 0000001E <res 00000002>      <1> 	.pressed_key		resw 1  ; the key which user pressed
   202                              <1> 	.end_of_struc
   203                              <1> endstruc
   204                              <1> 
   205                              <1> struc struc_input_box
   206 00000000 <res 0000001A>      <1> 	.window			resb SIZE_OF_STRUC_WINDOW
   207 0000001A <res 00000002>      <1> 	.message		resw 1  ; pointer to the message
   208 0000001C <res 00000002>      <1> 	.message_attr		resw 1  ; attribute of the message
   209 0000001E <res 00000001>      <1> 	.input_attr		resb 1  ; attribute of input area
   210 0000001F <res 00000001>      <1> 	.input_type		resb 1	; input type, 0=normal, 1=passwd
   211 00000020 <res 00000002>      <1> 	.input_buf		resw 1	; pointer to input buffer
   212 00000022 <res 00000001>      <1> 	.input_buf_len		resb 1	; length of input buffer
   213 00000023 <res 00000001>      <1> 	.input_area_len		resb 1	; length of input area
   214 00000024 <res 00000002>      <1> 	.input_area_pos		resw 1	; position of input area (in window)
   215 00000026 <res 00000001>      <1> 	.input_startp		resb 1	; the first visible char in input buf
   216 00000027 <res 00000001>      <1> 	.input_curp		resb 1	; cursor position
   217 00000028 <res 00000001>      <1> 	.return_val		resb 1	; return val, 0 = success, 1 = cancel
   218                              <1> 	.end_of_struc
   219                              <1> endstruc
   220                              <1> 
   221                              <1> ; vi:nowrap
   222                                  %include "hd_io.h"
   223                              <1> ; hd_io.h
   224                              <1> ;
   225                              <1> ; header file for hd_io.asm
   226                              <1> ;
   227                              <1> ; Copyright (C) 2000, Suzhe. See file COPYING and CREDITS for details.
   228                              <1> ;
   229                              <1> 
   230                              <1> 
   231                              <1> %define DRVFLAG_DRIVEOK    0x0001       ;
   232                              <1> %define DRVFLAG_CHSVALID   0x0002       ; used in driveinfo structure
   233                              <1> %define DRVFLAG_REMOVABLE  0x0004       ; and bootrecord structure 
   234                              <1> %define DRVFLAG_EXTOK      0x0008       ;
   235                              <1> %define DRVFLAG_ISCDROM    0x0010       ; 0000,0000,0001,0000B
   236                              <1> 
   237                              <1> %define DRVFLAG_MASK       0x0015       ; 0000,0000,0001,0101B
   238                              <1> 
   239                              <1> %define INT13H_EXT_INSTCHECK 0x41
   240                              <1> %define INT13H_EXT_READ      0x42
   241                              <1> %define INT13H_EXT_WRITE     0x43
   242                              <1> %define INT13H_EXT_GETINFO   0x48
   243                              <1> %define INT13H_EXT_LOCK      0x45
   244                              <1> %define INT13H_RESET         0X00
   245                              <1> %define INT13H_READ          0X02
   246                              <1> %define INT13H_WRITE         0X03
   247                              <1> %define INT13H_GETINFO       0X08
   248                              <1> %define INT13H_GETTYPE       0x15
   249                              <1> 
   250                              <1> %define EXT_SUBSET_FIXED     0x01
   251                              <1> %define EXT_SUBSET_REMOVABLE 0x02
   252                              <1> %define EXT_SUBSET_EDD       0x04
   253                              <1> 
   254                              <1> %define DRV_TYPE_FIXED       0x03
   255                              <1> 
   256                              <1> %define MIN_HD_ID            0X80
   257                              <1> %define EXTPARAM_SIZE        0x42
   258                              <1> 
   259                              <1> %define MAX_CYLS             1023
   260                              <1> 
   261                              <1> ; Structure for calling int 13h ext Read / Write functions
   262                              <1> struc struc_int13ext
   263 00000000 <res 00000001>      <1>       .pack_size    : resb  1      ; ==16 size of struct Int13ExtData
   264 00000001 <res 00000001>      <1>       .reserved     : resb  1      ; ==0
   265 00000002 <res 00000001>      <1>       .blk_count    : resb  1      ; number of blocks to transfer <= 127
   266 00000003 <res 00000001>      <1>       .reserved1    : resb  1      ; ==0
   267 00000004 <res 00000002>      <1>       .buf_addr_off : resw  1      ; address of transfer buffer(segment:offset)
   268 00000006 <res 00000002>      <1>       .buf_addr_seg : resw  1
   269 00000008 <res 00000002>      <1>       .blk_num_low1 : resw  1      ; starting absolute block number
   270 0000000A <res 00000002>      <1>       .blk_num_low2 : resw  1
   271 0000000C <res 00000002>      <1>       .blk_num_high1: resw  1
   272 0000000E <res 00000002>      <1>       .blk_num_high2: resw  1
   273                              <1>       .end_of_struc
   274                              <1> endstruc
   275                              <1> 
   276                              <1> ; structure for calling int 13h ext get drive parameters functions (0x48)
   277                              <1> struc struc_extparam
   278 00000000 <res 00000002>      <1>       .pack_size         : resw  1
   279 00000002 <res 00000002>      <1>       .flags             : resw  1
   280 00000004 <res 00000004>      <1>       .cylinders         : resd  1
   281 00000008 <res 00000004>      <1>       .heads             : resd  1      ; <= 255
   282 0000000C <res 00000004>      <1>       .sectors           : resd  1      ; <= 63
   283 00000010 <res 00000008>      <1>       .total_sectors     : resd  2
   284 00000018 <res 00000002>      <1>       .bytes_per_sect    : resw  1
   285 0000001A <res 00000004>      <1>       .dpte_addr         : resd  1      ; device parameter table extension
   286 0000001E <res 00000002>      <1>       .dpi_key           : resw  1      ; 0xBEDD - Key, indicates presence
   287                              <1>                                         ; of Device Path Information
   288 00000020 <res 00000001>      <1>       .dpi_length        : resb  1      ; Length of Device Path Information 
   289                              <1>                                         ; including the key. = 36
   290 00000021 <res 00000001>      <1>       .reserved1         : resb  1
   291 00000022 <res 00000002>      <1>       .reserved2         : resw  1
   292 00000024 <res 00000004>      <1>       .host_bus_type     : resb  4      ; Host bus type, 4 bytes
   293                              <1>                                         ; PCI    PCI Local Bus
   294                              <1>                                         ; ISA    Legacy 16 bit fixed bus
   295 00000028 <res 00000008>      <1>       .interface_type    : resb  8      ; Interface type, 8 bytes
   296                              <1>                                         ; ATA   ATA/ATAPI-4 compliant device using ATA commands
   297                              <1>                                         ; ATAPI ATA/ATAPI-4 compliant device using ATAPI commands
   298                              <1>                                         ; SCSI  SCSI compliant device
   299                              <1>                                         ; USB   USB Mass Storage compliant device
   300                              <1>                                         ; 1394  1394 Mass Storage device
   301                              <1>                                         ; FIBRE Fibre Channel
   302 00000030 <res 00000008>      <1>       .interface_path    : resq  1
   303 00000038 <res 00000008>      <1>       .device_path       : resq  1
   304 00000040 <res 00000001>      <1>       .reserved3         : resb  1
   305 00000041 <res 00000001>      <1>       .checksum          : resb  1
   306                              <1>       .end_of_struc
   307                              <1> endstruc
   308                              <1> 
   309                              <1> ; Device parameter table extension
   310                              <1> %define SIZE_OF_DPTE struc_dpte.end_of_struc
   311                              <1> struc struc_dpte
   312 00000000 <res 00000002>      <1> 	.base_io	: resw 1
   313 00000002 <res 00000002>      <1> 	.ctrl_io	: resw 1
   314 00000004 <res 00000001>      <1> 	.flags		: resb 1
   315 00000005 <res 00000001>      <1> 	.vender_spec	: resb 1
   316 00000006 <res 00000001>      <1> 	.irq		: resb 1
   317 00000007 <res 00000001>      <1> 	.blk_count	: resb 1
   318 00000008 <res 00000001>      <1> 	.dma		: resb 1
   319 00000009 <res 00000001>      <1> 	.pio		: resb 1
   320 0000000A <res 00000002>      <1> 	.bios_spec	: resw 1
   321 0000000C <res 00000002>      <1> 	.reserved	: resw 1
   322 0000000E <res 00000001>      <1> 	.revision	: resb 1
   323 0000000F <res 00000001>      <1> 	.checksum	: resb 1
   324                              <1> 	.end_of_struc
   325                              <1> endstruc
   326                              <1> 
   327                              <1> ;Return cdrom boot catalog command packet
   328                              <1> %define SIZE_OF_CDBC_CMD struc_cdbc_cmd.end_of_struc
   329                              <1> struc struc_cdbc_cmd
   330 00000000 <res 00000001>      <1> 	.pack_size	: resb 1
   331 00000001 <res 00000001>      <1> 	.sector_count	: resb 1
   332 00000002 <res 00000002>      <1> 	.buf_addr_off	: resw 1
   333 00000004 <res 00000002>      <1> 	.buf_addr_seg	: resw 1
   334 00000006 <res 00000002>      <1> 	.begnning_sect	: resw 1
   335                              <1> 	.end_of_struc
   336                              <1> endstruc
   337                              <1> 
   338                              <1> ;CD Emulation Specification Packet
   339                              <1> %define SIZE_OF_CDEMU_SPEC struc_cdemu_spec.end_of_struc
   340                              <1> struc struc_cdemu_spec
   341 00000000 <res 00000001>      <1> 	.pack_size	: resb 1
   342 00000001 <res 00000001>      <1> 	.media_type	: resb 1
   343 00000002 <res 00000001>      <1> 	.emu_drvid	: resb 1
   344 00000003 <res 00000001>      <1> 	.controller_id	: resb 1
   345 00000004 <res 00000004>      <1> 	.image_lba	: resd 1
   346 00000008 <res 00000002>      <1> 	.device_spec	: resw 1
   347 0000000A <res 00000002>      <1> 	.user_bufseg	: resw 1
   348 0000000C <res 00000002>      <1> 	.load_seg	: resw 1
   349 0000000E <res 00000002>      <1> 	.sect_count	: resw 1
   350 00000010 <res 00000001>      <1> 	.cylinders	: resb 1
   351 00000011 <res 00000001>      <1> 	.sectors	: resb 1
   352 00000012 <res 00000001>      <1> 	.heads		: resb 1
   353                              <1> 	.end_of_struc
   354                              <1> endstruc
   355                              <1> 
   356                              <1> 
   357                              <1> ;Structure of boot catalog entry
   358                              <1> %define SIZE_OF_BOOT_CATALOG struc_boot_catalog.end_of_struc
   359                              <1> struc struc_boot_catalog
   360 00000000 <res 00000001>      <1> 	.indicator	: resb 1
   361 00000001 <res 00000001>      <1> 	.media_type	: resb 1
   362 00000002 <res 00000002>      <1> 	.load_seg	: resw 1
   363 00000004 <res 00000001>      <1> 	.sys_type	: resb 1
   364 00000005 <res 00000001>      <1> 	.reserved	: resb 1
   365 00000006 <res 00000002>      <1> 	.sect_count	: resw 1
   366 00000008 <res 00000004>      <1> 	.load_rba	: resd 1
   367 0000000C <res 00000014>      <1> 	.reserved1	: resb 20
   368                              <1> 	.end_of_struc
   369                              <1> endstruc
   370                              <1> 
   371                              <1> 
   372                              <1> ; structure for record drive informations
   373                              <1> struc struc_driveinfo
   374 00000000 <res 00000001>      <1>       .id                : resb  1
   375 00000001 <res 00000001>      <1>       .flags             : resb  1
   376 00000002 <res 00000002>      <1>       .cylinders         : resw  1
   377 00000004 <res 00000002>      <1>       .heads             : resw  1
   378 00000006 <res 00000002>      <1>       .sectors           : resw  1
   379 00000008 <res 00000002>      <1>       .sector_size       : resw  1
   380                              <1>       .end_of_struc
   381                              <1> endstruc
   382                              <1> 
   383                              <1> 
   384                              <1> 
   385                              <1> %define SIZE_OF_DRIVEINFO (struc_driveinfo.end_of_struc)
   386                              <1> %define SIZE_OF_EXTPARAM (struc_extparam.end_of_struc)
   387                              <1> %define SIZE_OF_INT13EXT (struc_int13ext.end_of_struc)
   388                              <1> 
   389                                  %include "knl.h"
   390                              <1> ; knl.h
   391                              <1> ;
   392                              <1> ; header file for knl.asm
   393                              <1> ;
   394                              <1> ; Copyright (C) 2000, Suzhe. See file COPYING and CREDITS for details.
   395                              <1> ;
   396                              <1> 
   397                              <1> %define MAX_NAME_LENGTH   15
   398                              <1> %define MAX_KEYSTROKES    13
   399                              <1> 
   400                              <1> %define FAT16_DRVID_OFF   0x24               ; drive id offset in fat16
   401                              <1> %define FAT16_HIDSEC_OFF  0x1C               ; hidden sector offset in fat16
   402                              <1> %define FAT16_EXTBRID_OFF 0x26               ; EXBRID offset in fat16
   403                              <1> 
   404                              <1> %define FAT32_DRVID_OFF   0x40
   405                              <1> %define FAT32_HIDSEC_OFF  0x1C
   406                              <1> %define FAT32_EXTBRID_OFF 0x42
   407                              <1> 
   408                              <1> %define EXTBRID           0x29               ; ext boot record id for fat
   409                              <1> 
   410                              <1> %define INFOFLAG_SCHEDULED  0x8000       ; 1000,0000,0000,0000B
   411                              <1> %define INFOFLAG_HAVEKEYS   0x4000       ; 0100,0000,0000,0000B
   412                              <1> %define INFOFLAG_SWAPDRVID  0x2000       ; 0010,0000,0000,0000B
   413                              <1> %define INFOFLAG_AUTOACTIVE 0x1000       ; 0001,0000,0000,0000B
   414                              <1> %define INFOFLAG_ACTIVE     0x0800       ; 0000,1000,0000,0000B
   415                              <1> %define INFOFLAG_AUTOHIDE   0x0400       ; 0000,0100,0000,0000B
   416                              <1> %define INFOFLAG_HIDDEN     0x0200       ; 0000,0010,0000,0000B
   417                              <1> %define INFOFLAG_LOGICAL    0x0100       ; 0000,0001,0000,0000B
   418                              <1> 
   419                              <1> %define INFOFLAG_ISDRIVER   0x0080       ; 0000,0000,1000,0000B
   420                              <1> %define INFOFLAG_ISSPECIAL  0X0008       ; 0000,0000,0000,1000B
   421                              <1> 
   422                              <1> %define SPREC_BOOTPREV      0
   423                              <1> %define SPREC_QUIT          1
   424                              <1> %define SPREC_POWEROFF      2
   425                              <1> %define SPREC_RESTART       3
   426                              <1> 
   427                              <1> %define NUM_OF_SPREC        4
   428                              <1> 
   429                              <1> %define NUM_OF_INFOFLAGS    9
   430                              <1> 
   431                              <1> ; structure for boot record, including removable drives and partitions
   432                              <1> struc struc_bootrecord
   433 00000000 <res 00000002>      <1>       .flags           : resw 1  ; type flags of this record, see INFOFLAG_x
   434 00000002 <res 00000001>      <1>       .drive_id        : resb 1  ; drive id = 0 to 255
   435                              <1>                                  ; partition id used in linux,
   436 00000003 <res 00000001>      <1>       .part_id         : resb 1  ; 1-4 for primary partitions,
   437                              <1>                                  ; > 5 for logical partitions,
   438                              <1>                                  ; 0 for driver or special bootrecord.
   439 00000004 <res 00000001>      <1>       .type            : resb 1  ; partition type, = 0 : not a partition
   440 00000005 <res 00000001>      <1>       .reserved        : resb 1  ;
   441 00000006 <res 00000004>      <1>       .father_abs_addr : resd 1  ; father's LBA address
   442 0000000A <res 00000004>      <1>       .abs_addr        : resd 1  ; partition's abs LBA address
   443 0000000E <res 00000004>      <1>       .password        : resd 1  ; password of this record
   444 00000012 <res 00000004>      <1>       .schedule_time   : resd 1  ; schedule time
   445 00000016 <res 00000010>      <1>       .name            : resb 16 ; name of this record, zero ending.
   446 00000026 <res 0000001A>      <1>       .keystrokes      : resw 13 ; keystrokes to be preloaded.
   447                              <1>       .end_of_struc
   448                              <1> endstruc
   449                              <1> 
   450                              <1> ; structure for partition record
   451                              <1> struc struc_partition
   452 00000000 <res 00000001>      <1>       .state           : resb 1  ; = 0 : inactive; = drive id : active
   453 00000001 <res 00000001>      <1>       .start_head      : resb 1  ; start chs address of the partition
   454 00000002 <res 00000002>      <1>       .start_cs        : resw 1  ;
   455 00000004 <res 00000001>      <1>       .type            : resb 1  ; equal to the same item in struc_bootrecord
   456 00000005 <res 00000001>      <1>       .end_head        : resb 1  ; end chs address of the partition
   457 00000006 <res 00000002>      <1>       .end_cs          : resw 1  ;
   458 00000008 <res 00000004>      <1>       .relative_addr   : resd 1  ; the relative address of this partition
   459 0000000C <res 00000004>      <1>       .sectors         : resd 1  ; the number of sectors of the partition
   460                              <1>       .end_of_struc
   461                              <1> endstruc
   462                              <1> 
   463                              <1> %define SIZE_OF_BOOTRECORD (struc_bootrecord.end_of_struc)
   464                              <1> %define SIZE_OF_PARTITION  (struc_partition.end_of_struc)
   465                              <1> 
   466                                  %include "sbm.h"
   467                              <1> ; sbm.h
   468                              <1> ;
   469                              <1> ; header file for main.asm and loader.asm
   470                              <1> ;
   471                              <1> ; Copyright (C) 2000, Suzhe. See file COPYING and CREDITS for details.
   472                              <1> ;
   473                              <1> 
   474                              <1> %define BR_GOOD_FLAG    0XAA55
   475                              <1> %define BR_FLAG_OFF     0x01FE
   476                              <1> %define PART_TBL_OFF    0x01BE
   477                              <1> 
   478                              <1> %define SECTOR_SIZE     0x200              ; size of a sector
   479                              <1> %define CDSECTOR_SIZE   0x800              ; size of a CD-ROM sector
   480                              <1> 
   481                              <1> %define SBMK_MAGIC      0x4B4D4253         ; magic number of
   482                              <1>                                            ; Smart Boot Manager kernel.
   483                              <1> %define SBMK_VERSION    0x035A             ; version of kernel.
   484                              <1> %define SBMT_MAGIC      0x544D4253         ; magic number of
   485                              <1>                                            ; Smart Boot Manager theme.
   486                              <1> %define SBMT_VERSION    0x035A             ; version of theme.
   487                              <1> %define SBML_MAGIC      0x4C4D4253         ; magic number of
   488                              <1>                                            ; Smart Boot Manager loader.
   489                              <1> %define SBML_VERSION    0x0301             ; version of loader.
   490                              <1> 
   491                              <1> %define MAX_SBM_SIZE    30000              ; the max size of Smart Boot Manager
   492                              <1> 
   493                              <1> %define SIZE_OF_MBR     446                ; the size of master boot record
   494                              <1> 
   495                              <1> %define MAX_RECORD_NUM      32
   496                              <1> %define MAX_FLOPPY_NUM      2
   497                              <1> %define MAX_PASSWORD_LENGTH 16
   498                              <1> 
   499                              <1> %define BOOT_OFF        0x7C00             ; boot sector startup offset
   500                              <1> %define BOOT_SEG	0x07C0
   501                              <1> %define PART_OFF        0x0600             ; partition table offset
   502                              <1>                                            ; Smart Boot Manager kernel startup
   503                              <1> %define KERNEL_SEG      0x1000             ; Segment ( Off = 0 )
   504                              <1> %define KNLBACKUP_SEG   0x2000             ; Backup Segment ( Off = 0 )
   505                              <1> 
   506                              <1> %define STACK_SEG       0x3000
   507                              <1> %define STACK_SIZE      0x8000
   508                              <1> 
   509                              <1> %define SBM_SAVE_NBLKS  5
   510                              <1> 
   511                              <1> %ifndef STRUC_SBMK_HEADER
   512                              <1> %define STRUC_SBMK_HEADER
   513                              <1> 
   514                              <1> struc struc_block_map
   515 00000000 <res 00000001>      <1>       .n_sects         resb 1
   516 00000001 <res 00000004>      <1>       .lba_addr        resd 1
   517                              <1>       .end_of_struc
   518                              <1> endstruc
   519                              <1> 
   520                              <1> %define SIZE_OF_STRUC_BLOCK_MAP struc_block_map.end_of_struc
   521                              <1> 
   522                              <1> struc struc_sbml_header
   523 00000000 <res 00000003>      <1>       .jmp_cmd     resb 3               ; cli and jmp command.
   524                              <1> 
   525                              <1> ;=================== For floppy FAT12 filesystem ======================
   526 00000003 <res 00000008>      <1>       .bsOEM       resb 8               ; OEM String
   527 0000000B <res 00000002>      <1>       .bsSectSize  resw 1               ; Bytes per sector
   528 0000000D <res 00000001>      <1>       .bsClustSize resb 1               ; Sectors per cluster
   529 0000000E <res 00000002>      <1>       .bsRessect   resw 1               ; # of reserved sectors
   530 00000010 <res 00000001>      <1>       .bsFatCnt    resb 1               ; # of fat copies
   531 00000011 <res 00000002>      <1>       .bsRootSize  resw 1               ; size of root directory
   532 00000013 <res 00000002>      <1>       .bsTotalSect resw 1               ; total # of sectors if < 32 meg
   533 00000015 <res 00000001>      <1>       .bsMedia     resb 1               ; Media Descriptor
   534 00000016 <res 00000002>      <1>       .bsFatSize   resw 1               ; Size of each FAT
   535 00000018 <res 00000002>      <1>       .bsTrackSect resw 1               ; Sectors per track
   536 0000001A <res 00000002>      <1>       .bsHeadCnt   resw 1               ; number of read-write heads
   537 0000001C <res 00000004>      <1>       .bsHidenSect resd 1               ; number of hidden sectors
   538 00000020 <res 00000004>      <1>       .bsHugeSect  resd 1               ; if bsTotalSect is 0 this value is
   539                              <1>                                         ; the number of sectors
   540 00000024 <res 00000001>      <1>       .bsBootDrv   resb 1               ; holds drive that the bs came from
   541 00000025 <res 00000001>      <1>       .bsReserv    resb 1               ; not used for anything
   542 00000026 <res 00000001>      <1>       .bsBootSign  resb 1               ; boot signature 29h
   543 00000027 <res 00000004>      <1>       .bsVolID     resd 1               ; Disk volume ID also used for temp
   544                              <1>                                         ; sector # / # sectors to load
   545 0000002B <res 0000000B>      <1>       .bsVoLabel   resb 11              ; Volume Label
   546 00000036 <res 00000008>      <1>       .bsFSType    resb 8               ; File System type
   547                              <1> 
   548 0000003E <res 00000002>      <1>       .reserved    resb 2
   549                              <1> ;====================================================================
   550                              <1> 
   551 00000040 <res 00000004>      <1>       .magic           resd 1           ; magic number.
   552 00000044 <res 00000002>      <1>       .version         resw 1           ; version.
   553                              <1> 
   554 00000046 <res 00000019>      <1>       .block_map       resb SIZE_OF_STRUC_BLOCK_MAP * 5
   555                              <1>                                         ; block map for SBMK, 5 blocks allowed
   556                              <1> endstruc
   557                              <1> 
   558                              <1> struc struc_sbmk_header
   559 00000000 <res 00000004>      <1>       .jmp_cmd         resd 1           ; jmp and nop command.
   560 00000004 <res 00000004>      <1>       .magic           resd 1           ; magic number.
   561 00000008 <res 00000002>      <1>       .version         resw 1           ; version.
   562 0000000A <res 00000002>      <1>       .total_size      resw 1           ; the size of kernel code.
   563 0000000C <res 00000002>      <1>       .compressed_addr resw 1           ; the address of compressed part
   564 0000000E <res 00000001>      <1>       .checksum        resb 1           ; checksum value.
   565 0000000F <res 00000001>      <1>       .sectors         resb 1           ;
   566 00000010 <res 00000001>      <1>       .drvid           resb 1           ;
   567 00000011 <res 00000019>      <1>       .block_map       resb SIZE_OF_STRUC_BLOCK_MAP * 5
   568                              <1>                                         ; block map for SBMK, 5 blocks allowed
   569 0000002A <res 00000002>      <1>       .reserved1       resw 1           ;
   570                              <1> 
   571 0000002C <res 00000001>      <1>       .flags           resb 1           ; kernel flags. 
   572 0000002D <res 00000001>      <1>       .delay_time      resb 1           ; delay time ( seconds )
   573 0000002E <res 00000001>      <1>       .direct_boot     resb 1           ; >= MAX_RECORD_NUM means no
   574                              <1>                                         ; direct boot.
   575 0000002F <res 00000001>      <1>       .default_boot    resb 1           ; the record number will
   576                              <1>                                         ; be booted after the
   577                              <1>                                         ; delay time is up or ESC
   578                              <1>                                         ; key is pressed.
   579 00000030 <res 00000004>      <1>       .root_password   resd 1           ; root password.
   580                              <1> 
   581 00000034 <res 00000002>      <1>       .bootmenu_style  resb 2
   582 00000036 <res 00000004>      <1>       .cdrom_ioports   resw 2
   583 0000003A <res 00000002>      <1>       .y2k_last_year   resw 1
   584 0000003C <res 00000001>      <1>       .y2k_last_month  resb 1
   585 0000003D <res 00000003>      <1>       .reserved2       resb 3
   586                              <1> endstruc
   587                              <1> 
   588                              <1> struc struc_sbmk_data
   589 00000000 <res 00000800>      <1>       .boot_records    resb MAX_RECORD_NUM * SIZE_OF_BOOTRECORD
   590 00000800 <res 000001BE>      <1>       .sbml_codes      resb SIZE_OF_MBR
   591 000009BE <res 00000200>      <1>       .previous_mbr    resb SECTOR_SIZE
   592                              <1> 
   593 00000BBE <res 00000002>      <1>       .boot_menu_pos   resw 1
   594 00000BC0 <res 00000002>      <1>       .main_menu_pos   resw 1
   595 00000BC2 <res 00000002>      <1>       .record_menu_pos resw 1
   596 00000BC4 <res 00000002>      <1>       .sys_menu_pos    resw 1
   597                              <1> endstruc
   598                              <1> 
   599                              <1> struc struc_sbmt_header
   600 00000000 <res 00000004>      <1>       .magic           resd 1           ; magic number.
   601 00000004 <res 00000002>      <1>       .reserved        resw 1           ;
   602 00000006 <res 00000006>      <1>       .lang            resb 6           ; language info.
   603 0000000C <res 00000002>      <1>       .version         resw 1           ; theme version.
   604 0000000E <res 00000002>      <1>       .size            resw 1           ; theme size.
   605                              <1> endstruc
   606                              <1> 
   607                              <1> 
   608                              <1> %endif
   609                              <1> 
   610                                  %include "main.h"
   611                              <1> ; main.h
   612                              <1> ;
   613                              <1> ; header file for main.asm main-cmds.asm main-utils.asm
   614                              <1> ;
   615                              <1> ; Copyright (C) 2000, Suzhe. See file COPYING and CREDITS for details.
   616                              <1> ;
   617                              <1> 
   618                              <1> %define KNLFLAG_FIRSTSCAN   0x01
   619                              <1> %define KNLFLAG_SECURITY    0x02
   620                              <1> %define KNLFLAG_NOINT13EXT  0x04
   621                              <1> %define KNLFLAG_NOCDROM     0x08
   622                              <1> 
   623                              <1> %define KNLFLAG_REMLAST     0x10
   624                              <1> %define KNLFLAG_ONLYPARTS   0X20
   625                              <1> %define KNLFLAG_COMPRESSED  0x80
   626                              <1> 
   627                              <1> %define BMSTYLE_FULL        0
   628                              <1> %define BMSTYLE_NOFLAGS     1
   629                              <1> %define BMSTYLE_NONUMBER    2
   630                              <1> %define BMSTYLE_NOTYPE      3
   631                              <1> 
   632                                  %include "evtcode.h"
   633                              <1> ;
   634                              <1> ; evtcode.h
   635                              <1> ;
   636                              <1> ; definiation of event codes
   637                              <1> ;
   638                              <1> ; Copyright (C) 2000, Suzhe. See file COPYING and CREDITS for details.
   639                              <1> ;
   640                              <1> 
   641                              <1> %define kbEsc                0x011B
   642                              <1> %define kbAltEsc             0x0100
   643                              <1> 
   644                              <1> %define kbF1                 0x3B00
   645                              <1> %define kbAltF1              0x6800
   646                              <1> %define kbCtrlF1             0x5E00
   647                              <1> %define kbShiftF1            0x5400
   648                              <1> 
   649                              <1> %define kbF2                 0x3C00
   650                              <1> %define kbAltF2              0x6900
   651                              <1> %define kbCtrlF2             0x5F00
   652                              <1> %define kbShiftF2            0x5500
   653                              <1> 
   654                              <1> %define kbF3                 0x3D00
   655                              <1> %define kbAltF3              0x6A00
   656                              <1> %define kbCtrlF3             0x6000
   657                              <1> %define kbShiftF3            0x5600
   658                              <1> 
   659                              <1> %define kbF4                 0x3E00
   660                              <1> %define kbAltF4              0x6B00
   661                              <1> %define kbCtrlF4             0x6100
   662                              <1> %define kbShiftF4            0x5700
   663                              <1> 
   664                              <1> %define kbF5                 0x3F00
   665                              <1> %define kbAltF5              0x6C00
   666                              <1> %define kbCtrlF5             0x6200
   667                              <1> %define kbShiftF5            0x5800
   668                              <1> 
   669                              <1> %define kbF6                 0x4000
   670                              <1> %define kbAltF6              0x6D00
   671                              <1> %define kbCtrlF6             0x6300
   672                              <1> %define kbShiftF6            0x5900
   673                              <1> 
   674                              <1> %define kbF7                 0x4100
   675                              <1> %define kbAltF7              0x6E00
   676                              <1> %define kbCtrlF7             0x6400
   677                              <1> %define kbShiftF7            0x5A00
   678                              <1> 
   679                              <1> %define kbF8                 0x4200
   680                              <1> %define kbAltF8              0x6F00
   681                              <1> %define kbCtrlF8             0x6500
   682                              <1> %define kbShiftF8            0x5B00
   683                              <1> 
   684                              <1> %define kbF9                 0x4300
   685                              <1> %define kbAltF9              0x7000
   686                              <1> %define kbCtrlF9             0x6600
   687                              <1> %define kbShiftF9            0x5C00
   688                              <1> 
   689                              <1> %define kbF10                0x4400
   690                              <1> %define kbAltF10             0x7100
   691                              <1> %define kbCtrlF10            0x6700
   692                              <1> %define kbShiftF10           0x5D00
   693                              <1> 
   694                              <1> %define kbF11                0x8500
   695                              <1> %define kbAltF11             0x8B00
   696                              <1> %define kbCtrlF11            0x8900
   697                              <1> %define kbShiftF11           0x8700
   698                              <1> 
   699                              <1> %define kbF12                0x8600
   700                              <1> %define kbAltF12             0x8C00
   701                              <1> %define kbCtrlF12            0x8A00
   702                              <1> %define kbShiftF12           0x8800
   703                              <1> 
   704                              <1> %define kbTab                0x0F09
   705                              <1> %define kbAltTab             0xA500
   706                              <1> %define kbCtrlTab            0x9400
   707                              <1> %define kbShiftTab           0x0F00
   708                              <1> 
   709                              <1> %define kbBack               0x0E08
   710                              <1> %define kbAltBack            0x0E00
   711                              <1> %define kbCtrlBack           0x0E7F
   712                              <1> 
   713                              <1> %define kbEnter              0x1C0D
   714                              <1> %define kbAltEnter           0x1C00
   715                              <1> %define kbCtrlEnter          0x1C0A
   716                              <1> %define kbEnhEnter           0xE00D
   717                              <1> %define kbEnhAltEnter        0xA600
   718                              <1> %define kbEnhCtrlEnter       0xE00A
   719                              <1> 
   720                              <1> %define kbSpace              0x3920
   721                              <1> 
   722                              <1> %define kbIns                0x5200
   723                              <1> %define kbEnhIns             0x52E0
   724                              <1> %define kbCtrlIns            0x9200
   725                              <1> %define kbEnhCtrlIns         0x92E0
   726                              <1> %define kbEnhAltIns          0xA200
   727                              <1> 
   728                              <1> %define kbHome               0x4700
   729                              <1> %define kbEnhHome            0x47E0
   730                              <1> %define kbCtrlHome           0x7700
   731                              <1> %define kbEnhCtrlHome        0x77E0
   732                              <1> %define kbEnhAltHome         0x9700
   733                              <1> 
   734                              <1> %define kbPgUp               0x4900
   735                              <1> %define kbEnhPgUp            0x49E0
   736                              <1> %define kbCtrlPgUp           0x8400
   737                              <1> %define kbEnhCtrlPgUp        0x84E0
   738                              <1> %define kbEnhAltPgUp         0x9900
   739                              <1> 
   740                              <1> %define kbEnd                0x4F00
   741                              <1> %define kbEnhEnd             0x4FE0
   742                              <1> %define kbCtrlEnd            0x7500
   743                              <1> %define kbEnhCtrlEnd         0x75E0
   744                              <1> %define kbEnhAltEnd          0x9F00
   745                              <1> 
   746                              <1> %define kbDel                0x5300
   747                              <1> %define kbEnhDel             0x53E0
   748                              <1> %define kbCtrlDel            0x9300
   749                              <1> %define kbEnhCtrlDel         0x93E0
   750                              <1> %define kbEnhAltDel          0xA300
   751                              <1> 
   752                              <1> %define kbPgDn               0x5100
   753                              <1> %define kbEnhPgDn            0x51E0
   754                              <1> %define kbCtrlPgDn           0x7600
   755                              <1> %define kbEnhCtrlPgDn        0x76E0
   756                              <1> %define kbEnhAltPgDn         0xA100
   757                              <1> 
   758                              <1> %define kbUp                 0x4800
   759                              <1> %define kbCtrlUp             0x8D00
   760                              <1> %define kbEnhUp              0x48E0
   761                              <1> %define kbEnhAltUp           0x9800
   762                              <1> %define kbEnhCtrlUp          0x8DE0
   763                              <1> 
   764                              <1> %define kbDown               0x5000
   765                              <1> %define kbCtrlDown           0x9100
   766                              <1> %define kbEnhDown            0x50E0
   767                              <1> %define kbEnhAltDown         0xA000
   768                              <1> %define kbEnhCtrlDown        0x91E0
   769                              <1> 
   770                              <1> %define kbLeft               0x4b00
   771                              <1> %define kbCtrlLeft           0x7300
   772                              <1> %define kbEnhLeft            0x4BE0
   773                              <1> %define kbEnhAltLeft         0x9B00
   774                              <1> %define kbEnhCtrlLeft        0x73E0
   775                              <1> 
   776                              <1> %define kbRight              0x4d00
   777                              <1> %define kbCtrlRight          0x7400
   778                              <1> %define kbEnhRight           0x4DE0
   779                              <1> %define kbEnhAltRight        0x9D00
   780                              <1> %define kbEnhCtrlRight       0x74E0
   781                              <1> 
   782                              <1> %define kbGraySlash          0xE02F
   783                              <1> %define kbGrayStar           0x372A
   784                              <1> %define kbGrayMinus          0x4A2D
   785                              <1> %define kbGrayPlus           0x4E2B
   786                              <1> 
   787                              <1> %define kbCtrlQ              0x1011
   788                              <1> %define kbCtrlW              0x1117
   789                              <1> %define kbCtrlE              0x1205
   790                              <1> %define kbCtrlR              0x1312
   791                              <1> %define kbCtrlT              0x1414
   792                              <1> %define kbCtrlY              0x1519
   793                              <1> %define kbCtrlU              0x1615
   794                              <1> %define kbCtrlI              0x1709
   795                              <1> %define kbCtrlO              0x180F
   796                              <1> %define kbCtrlP              0x1910
   797                              <1> %define kbCtrlA              0x1E01
   798                              <1> %define kbCtrlS              0x1f13
   799                              <1> %define kbCtrlD              0x2004
   800                              <1> %define kbCtrlF              0x2106
   801                              <1> %define kbCtrlG              0x2207
   802                              <1> %define kbCtrlH              0x2308
   803                              <1> %define kbCtrlJ              0x240A
   804                              <1> %define kbCtrlK              0x250b
   805                              <1> %define kbCtrlL              0x260C
   806                              <1> %define kbCtrlZ              0x2C1A
   807                              <1> %define kbCtrlX              0x2D18
   808                              <1> %define kbCtrlC              0x2E03
   809                              <1> %define kbCtrlV              0x2F16
   810                              <1> %define kbCtrlB              0x3002
   811                              <1> %define kbCtrlN              0x310E
   812                              <1> %define kbCtrlM              0x320D
   813                              <1> 
   814                              <1> %define kbLowerY             0x1579
   815                              <1> %define kbUpperY             0x1559
   816                              <1> 
   817                              <1> %define kbSlash              0x352F
   818                              <1> %define kbQuestion           0x353F
   819                              <1> 
   820                              <1> %define kbAltS               0x1F00
   821                              <1> %define kbAltR               0x1300
   822                              <1> 
   823                              <1> %define kbOne                0x0231
   824                              <1> 
   825                              <1> %define kbRightShiftMask     0x01
   826                              <1> %define kbLeftShiftMask      0x02
   827                              <1> %define kbShiftMask          0x03
   828                              <1> %define kbCtrlMask           0x04
   829                              <1> %define kbAltMask            0x08
   830                              <1> %define kbScrollMask         0x10
   831                              <1> %define kbNumLockMask        0x20
   832                              <1> %define kbCapsLockMask       0x40
   833                              <1> %define kbInsertMask         0x80
   834                              <1> 
   835                              <1> %define kbStateKeysMask   (kbScrollMask | kbNumLockMask | kbCapsLockMask | kbInsertMask)
   836                              <1> 
   837                              <1> %define EVTCODE_COMMAND		0xF0
   838                              <1> %define EVTCODE_KEYPRESS        0x01
   839                              <1> %define EVTCODE_KEYRELEASE      0x02
   840                              <1> %define EVTCODE_BROADCAST	0x04
   841                              <1> 
   842                              <1> ; Broadcast events
   843                              <1> %define EVENT_REDRAW_ROOT  ((EVTCODE_COMMAND | EVTCODE_BROADCAST) << 8 | 0x0001)
   844                              <1> %define EVENT_BOOT_DEFAULT ((EVTCODE_COMMAND | EVTCODE_BROADCAST) << 8 | 0x0002)
   845                              <1> 
   846                              <1> ; Normal events
   847                              <1> %define EVENT_TOGGLE_MENU  ((EVTCODE_COMMAND ) << 8 | 0x0001)
   848                              <1> 
   849                              <1> ; Key press event
   850                              <1> %define EVENT_RIGHTSHIFT_PRESS    ((EVTCODE_COMMAND | EVTCODE_KEYPRESS) << 8 | kbRightShiftMask)
   851                              <1> %define EVENT_LEFTSHIFT_PRESS     ((EVTCODE_COMMAND | EVTCODE_KEYPRESS) << 8 | kbLeftShiftMask)
   852                              <1> %define EVENT_SHIFT_PRESS         ((EVTCODE_COMMAND | EVTCODE_KEYPRESS) << 8 | kbShiftMask)
   853                              <1> %define EVENT_CTRL_PRESS          ((EVTCODE_COMMAND | EVTCODE_KEYPRESS) << 8 | kbCtrlMask)
   854                              <1> %define EVENT_ALT_PRESS           ((EVTCODE_COMMAND | EVTCODE_KEYPRESS) << 8 | kbAltMask)
   855                              <1> %define EVENT_SCROLL_ON           ((EVTCODE_COMMAND | EVTCODE_KEYPRESS) << 8 | kbScrollMask)
   856                              <1> %define EVENT_NUMLOCK_ON          ((EVTCODE_COMMAND | EVTCODE_KEYPRESS) << 8 | kbNumLockMask)
   857                              <1> %define EVENT_CAPSLOCK_ON         ((EVTCODE_COMMAND | EVTCODE_KEYPRESS) << 8 | kbCapsLockMask)
   858                              <1> %define EVENT_INSERT_ON           ((EVTCODE_COMMAND | EVTCODE_KEYPRESS) << 8 | kbInsertMask)
   859                              <1> 
   860                              <1> %define EVENT_RIGHTSHIFT_RELEASE  ((EVTCODE_COMMAND | EVTCODE_KEYRELEASE) << 8 | kbRightShiftMask)
   861                              <1> %define EVENT_LEFTSHIFT_RELEASE   ((EVTCODE_COMMAND | EVTCODE_KEYRELEASE) << 8 | kbLeftShiftMask)
   862                              <1> %define EVENT_SHIFT_RELEASE       ((EVTCODE_COMMAND | EVTCODE_KEYRELEASE) << 8 | kbShiftMask)
   863                              <1> %define EVENT_CTRL_RELEASE        ((EVTCODE_COMMAND | EVTCODE_KEYRELEASE) << 8 | kbCtrlMask)
   864                              <1> %define EVENT_ALT_RELEASE         ((EVTCODE_COMMAND | EVTCODE_KEYRELEASE) << 8 | kbAltMask)
   865                              <1> %define EVENT_SCROLL_OFF          ((EVTCODE_COMMAND | EVTCODE_KEYRELEASE) << 8 | kbScrollMask)
   866                              <1> %define EVENT_NUMLOCK_OFF         ((EVTCODE_COMMAND | EVTCODE_KEYRELEASE) << 8 | kbNumLockMask)
   867                              <1> %define EVENT_CAPSLOCK_OFF        ((EVTCODE_COMMAND | EVTCODE_KEYRELEASE) << 8 | kbCapsLockMask)
   868                              <1> %define EVENT_INSERT_OFF          ((EVTCODE_COMMAND | EVTCODE_KEYRELEASE) << 8 | kbInsertMask)
   869                              <1> 
   870                              <1> 
   871                                  
   872                                  %define GOOD_RECORD_NUMBER    (main_windows_data.boot_menu + struc_menu_box.items_num)
   873                                  %define FOCUS_RECORD          (main_windows_data.boot_menu + struc_menu_box.focus_item)
   874                                  %define FIRST_VISIBLE_RECORD  (main_windows_data.boot_menu + struc_menu_box.first_visible_item)
   875                                  %define BOOT_MENU_AREA_HEIGHT (main_windows_data.boot_menu + struc_menu_box.menu_area_size + 1) 
   876                                  
   877                                  %define ADDR_SBMK_MAGIC            (sbmk_header + struc_sbmk_header.magic)
   878                                  %define ADDR_SBMK_VERSION          (sbmk_header + struc_sbmk_header.version)
   879                                  %define ADDR_SBMK_TOTAL_SIZE       (sbmk_header + struc_sbmk_header.total_size)
   880                                  %define ADDR_SBMK_COMPRESSED_ADDR  (sbmk_header + struc_sbmk_header.compressed_addr)
   881                                  %define ADDR_SBMK_CHECKSUM         (sbmk_header + struc_sbmk_header.checksum)
   882                                  %define ADDR_SBMK_SECTORS          (sbmk_header + struc_sbmk_header.sectors)
   883                                  %define ADDR_SBMK_DRVID            (sbmk_header + struc_sbmk_header.drvid)
   884                                  %define ADDR_SBMK_BLOCK_MAP        (sbmk_header + struc_sbmk_header.block_map)
   885                                  %define ADDR_SBMK_FLAGS            (sbmk_header + struc_sbmk_header.flags)
   886                                  %define ADDR_SBMK_DELAY_TIME       (sbmk_header + struc_sbmk_header.delay_time)
   887                                  %define ADDR_SBMK_DIRECT_BOOT      (sbmk_header + struc_sbmk_header.direct_boot)
   888                                  %define ADDR_SBMK_DEFAULT_BOOT     (sbmk_header + struc_sbmk_header.default_boot)
   889                                  %define ADDR_SBMK_ROOT_PASSWORD    (sbmk_header + struc_sbmk_header.root_password)
   890                                  %define ADDR_SBMK_BOOTMENU_STYLE   (sbmk_header + struc_sbmk_header.bootmenu_style)
   891                                  %define ADDR_SBMK_CDROM_IOPORTS    (sbmk_header + struc_sbmk_header.cdrom_ioports)
   892                                  %define ADDR_SBMK_Y2K_LAST_YEAR    (sbmk_header + struc_sbmk_header.y2k_last_year)
   893                                  %define ADDR_SBMK_Y2K_LAST_MONTH   (sbmk_header + struc_sbmk_header.y2k_last_month)
   894                                  %define ADDR_SBMK_BOOT_RECORDS     (sbmk_data + struc_sbmk_data.boot_records)
   895                                  %define ADDR_SBMK_SBML_CODES       (sbmk_data + struc_sbmk_data.sbml_codes)
   896                                  %define ADDR_SBMK_PREVIOUS_MBR     (sbmk_data + struc_sbmk_data.previous_mbr)
   897                                  %define ADDR_SBMK_BOOT_MENU_POS    (sbmk_data + struc_sbmk_data.boot_menu_pos)
   898                                  %define ADDR_SBMK_MAIN_MENU_POS    (sbmk_data + struc_sbmk_data.main_menu_pos)
   899                                  %define ADDR_SBMK_RECORD_MENU_POS  (sbmk_data + struc_sbmk_data.record_menu_pos)
   900                                  %define ADDR_SBMK_SYS_MENU_POS     (sbmk_data + struc_sbmk_data.sys_menu_pos)
   901                                  
   902                                  	bits 16
   903                                  
   904                                  %ifdef EMULATE_PROG
   905                                  	org 0x100
   906                                  %else
   907                                  	org 0
   908                                  %endif
   909                                  
   910                                  	section .text
   911                                          
   912                                  start_of_sbm:
   913                                  start_of_kernel:
   914                                  
   915                                  ;=============================================================================
   916                                  ;the header of Smart Boot Manager kernel
   917                                  ;=============================================================================
   918                                  sbmk_header     istruc  struc_sbmk_header
   919 00000000 E9030C                  	        jmp sbm_start
   920 00000003 90                      	        nop
   921                                  ;!!! PLEASE DON NOT CHANGE THE SIZE AND ORDER OF FOLLOWING DATA !!!
   922 00000004 53424D4B                    at struc_sbmk_header.magic,          dd SBMK_MAGIC   ; magic number = 'SBMK', 4 bytes.
   923 00000008 5A03                        at struc_sbmk_header.version,        dw SBMK_VERSION ; version, high byte is major version,
   924                                                                                           ; low byte is minor version.
   925 0000000A 924B                        at struc_sbmk_header.total_size,     dw (end_of_kernel - start_of_kernel)
   926                                                                                           ; set to total(compressed) 
   927                                                                                           ; size by installer
   928 0000000C [AE0C]                      at struc_sbmk_header.compressed_addr,dw sbm_real_start ; The address of compressed part
   929                                  
   930 0000000E 00                          at struc_sbmk_header.checksum,       db 0            ; checksum of the kernel program.
   931                                  
   932 0000000F 00                          at struc_sbmk_header.sectors,        db 0            ; kernel size in sectors
   933 00000010 00                          at struc_sbmk_header.drvid,          db 0
   934 00000011 00<rept>                    at struc_sbmk_header.block_map,      times SIZE_OF_STRUC_BLOCK_MAP * 5 db 0
   935 0000002A 55AA                        at struc_sbmk_header.reserved1,      dw  BR_GOOD_FLAG
   936                                  ;=============================================================================
   937                                  ; MAIN data area
   938                                  ;=============================================================================
   939 0000002C 01                          at struc_sbmk_header.flags,          db KNLFLAG_FIRSTSCAN 
   940 0000002D 1E                          at struc_sbmk_header.delay_time,     db 30           ; delay time ( seconds )
   941 0000002E FF                          at struc_sbmk_header.direct_boot,    db 0xff         ; >= MAX_RECORD_NUM means no
   942                                                                                           ; direct boot.
   943 0000002F FF                          at struc_sbmk_header.default_boot,   db 0xff         ; the record number will
   944                                                                                           ; be booted after the
   945                                                                                           ; delay time is up or ESC
   946                                                                                           ; key is pressed.
   947 00000030 00000000                    at struc_sbmk_header.root_password,  dd 0
   948                                  
   949 00000034 0000                        at struc_sbmk_header.bootmenu_style, db 0,0
   950 00000036 00000000                    at struc_sbmk_header.cdrom_ioports,  dw 0, 0
   951 0000003A 0000                        at struc_sbmk_header.y2k_last_year,  dw 0
   952 0000003C 00                          at struc_sbmk_header.y2k_last_month, db 0
   953 0000003D 0055AA                      at struc_sbmk_header.reserved2,      db 0,0x55,0xAA
   954                                                  iend
   955                                  
   956                                  end_of_sbmk_header:
   957                                  
   958                                  ;=============================================================================
   959                                  ; Other DATA
   960                                  ;=============================================================================
   961                                  sbmk_data       istruc struc_sbmk_data
   962                                  ; buffer to store boot records
   963 00000040 00<rept>                    at struc_sbmk_data.boot_records, times MAX_RECORD_NUM * SIZE_OF_BOOTRECORD db 0
   964 00000840 00<rept>                    at struc_sbmk_data.sbml_codes,   times SIZE_OF_MBR db 0
   965 000009FE 00<rept>                    at struc_sbmk_data.previous_mbr, times SECTOR_SIZE db 0
   966                                  
   967                                  ; private data 
   968 00000BFE 0E06                        at struc_sbmk_data.boot_menu_pos,    dw 0x060E
   969 00000C00 0101                        at struc_sbmk_data.main_menu_pos,    dw 0x0101
   970 00000C02 0202                        at struc_sbmk_data.record_menu_pos,  dw 0x0202
   971 00000C04 0303                        at struc_sbmk_data.sys_menu_pos,     dw 0x0303
   972                                                  iend
   973                                  
   974                                  
   975                                  end_of_sbmk_data:
   976                                  
   977                                  
   978                                  ;=============================================================================
   979                                  ; Program entry
   980                                  ;=============================================================================
   981                                  
   982                                  sbm_start:
   983                                  
   984                                  %ifndef EMULATE_PROG                            ; real program goes here.
   985 00000C06 FA                      	cli
   986 00000C07 B80030                  	mov ax, STACK_SEG
   987 00000C0A 8ED0                    	mov ss, ax                              ; ss:sp = 0x3000:0x1000
   988 00000C0C BC0080                  	mov sp, STACK_SIZE                      ;
   989                                  
   990 00000C0F 0E                      	push cs
   991 00000C10 1F                      	pop ds
   992 00000C11 FB                      	sti
   993                                  
   994                                  ;Save current driver id for future use.
   995 00000C12 8816[1000]              	mov [ADDR_SBMK_DRVID], dl
   996                                  
   997                                  ;Backup Smart BootManager and decompress it, if it's compressed.
   998 00000C16 680020                  	push word KNLBACKUP_SEG
   999 00000C19 07                      	pop es
  1000                                  
  1001 00000C1A 31F6                    	xor si, si
  1002 00000C1C 31FF                    	xor di, di
  1003                                  
  1004 00000C1E 8B0E[0A00]              	mov cx, [ADDR_SBMK_TOTAL_SIZE]
  1005 00000C22 FC                      	cld
  1006 00000C23 F3A4                    	rep movsb
  1007                                  
  1008                                  %ifdef COMPRESS_SBM
  1009                                  ;test if it's compressed
  1010 00000C25 F606[2C00]80            	test byte [ADDR_SBMK_FLAGS], KNLFLAG_COMPRESSED
  1011 00000C2A 0F848000                	jmpz sbm_real_start
  1012                                  
  1013                                  ;decompress SBM
  1014 00000C2E BE[AE0C]                	mov si, sbm_real_start
  1015 00000C31 56                      	push si
  1016 00000C32 5F                      	pop di
  1017                                  
  1018 00000C33 1E                      	push ds
  1019 00000C34 06                      	push es
  1020 00000C35 1F                      	pop ds
  1021 00000C36 07                      	pop es
  1022                                  
  1023 00000C37 BB0F80                  	mov bx, 0x800F
  1024 00000C3A 31C9                    	xor cx, cx
  1025 00000C3C 31ED                    	xor bp, bp
  1026 00000C3E 45                      	inc bp
  1027 00000C3F 1E                      	push ds
  1028 00000C40 5A                      	pop dx
  1029                                  
  1030 00000C41 EB01                    	jmp short decompr_start_n2b		; decompress SBM
  1031                                  
  1032                                  
  1033                                  ;=============================================================================
  1034                                  %include "n2b_d8e.ash"
  1035                              <1> ;  n2b_d8e.ash -- ucl_nrv2b_decompress_8 in 16-bit assembly (dos/exe)
  1036                              <1> ;
  1037                              <1> ;  This file is part of the UCL real-time data compression library.
  1038                              <1> ;
  1039                              <1> ;  Copyright (C) 1996-2000 Markus Franz Xaver Johannes Oberhumer
  1040                              <1> ;
  1041                              <1> ;  The UCL library is free software; you can redistribute it and/or
  1042                              <1> ;  modify it under the terms of the GNU General Public License as
  1043                              <1> ;  published by the Free Software Foundation; either version 2 of
  1044                              <1> ;  the License, or (at your option) any later version.
  1045                              <1> ;
  1046                              <1> ;  The UCL library is distributed in the hope that it will be useful,
  1047                              <1> ;  but WITHOUT ANY WARRANTY; without even the implied warranty of
  1048                              <1> ;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1049                              <1> ;  GNU General Public License for more details.
  1050                              <1> ;
  1051                              <1> ;  You should have received a copy of the GNU General Public License
  1052                              <1> ;  along with the UCL library; see the file COPYING.
  1053                              <1> ;  If not, write to the Free Software Foundation, Inc.,
  1054                              <1> ;  59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  1055                              <1> ;
  1056                              <1> ;  Markus F.X.J. Oberhumer
  1057                              <1> ;  markus.oberhumer@jk.uni-linz.ac.at
  1058                              <1> ;  http://wildsau.idv.uni-linz.ac.at/mfx/ucl.html
  1059                              <1> ;
  1060                              <1> 
  1061                              <1> 
  1062                              <1> ; ------------- DECOMPRESSION -------------
  1063                              <1> 
  1064                              <1> ; Input
  1065                              <1> ; ds:si - source
  1066                              <1> ; es:di - dest
  1067                              <1> ; dx = ds
  1068                              <1> ; cx = 0
  1069                              <1> ; bx = 0x800F
  1070                              <1> ; bp = 1
  1071                              <1> 
  1072                              <1> 
  1073                              <1>     %ifndef jmps
  1074                              <1>     %define jmps    jmp short
  1075                              <1>     %endif
  1076                              <1>     %ifndef jmpn
  1077                              <1>     %define jmpn    jmp near
  1078                              <1>     %endif
  1079                              <1> 
  1080                              <1> 
  1081                              <1> ;       __NRV2B16S__
  1082                              <1> literal_n2b:
  1083 00000C43 A4                  <1>                 movsb
  1084                              <1> decompr_start_n2b:
  1085 00000C44 00FF                <1>                 add     bh, bh
  1086 00000C46 7503                <1>                 jnz     dec1_n2b
  1087 00000C48 E85D00              <1>                 call    reloadbh_n2b
  1088                              <1> dec1_n2b:
  1089 00000C4B 72F6                <1>                 jc      literal_n2b
  1090 00000C4D 41                  <1>                 inc     cx
  1091 00000C4E 8CC0                <1>                 mov     ax, es
  1092                              <1> %ifdef  __NDIGT64K__
  1093                              <1>                 add     di, di
  1094                              <1>                 jnc     di_ok_n2b
  1095                              <1>                 add     ah, 8
  1096                              <1>                 mov     es, ax
  1097                              <1> di_ok_n2b:
  1098                              <1>                 shr     di, 1
  1099                              <1> %endif; __NRV2BEX1__
  1100                              <1> offset_loop_n2b:
  1101 00000C50 E84800              <1>                 call    getbit_cx_n2b
  1102 00000C53 E359                <1>                 jcxz    decomp_done_n2b
  1103 00000C55 73F9                <1>                 jnc     offset_loop_n2b
  1104 00000C57 49                  <1>                 dec     cx
  1105 00000C58 49                  <1>                 dec     cx
  1106 00000C59 740C                <1>                 jz      offset_ok_n2b
  1107                              <1> %ifdef  __N2BX8601__
  1108                              <1>                 add     cx, cx
  1109                              <1>                 add     cx, cx
  1110                              <1>                 add     cx, cx
  1111                              <1>                 add     cx, cx
  1112                              <1> %else;  __N2B28601__
  1113 00000C5B C1E104              <1>                 shl     cx, 4
  1114                              <1> %endif; __NRV2BEX2__
  1115 00000C5E 89CD                <1>                 mov     bp, cx
  1116 00000C60 8A1C                <1>                 mov     bl, [si]
  1117 00000C62 46                  <1>                 inc     si
  1118 00000C63 F6D3                <1>                 not     bl
  1119 00000C65 31C9                <1>                 xor     cx, cx
  1120                              <1> offset_ok_n2b:
  1121 00000C67 E83100              <1>                 call    getbit_cx_n2b
  1122 00000C6A 11C9                <1>                 adc     cx, cx
  1123 00000C6C 7508                <1>                 jnz     copy_match_n2b
  1124 00000C6E 41                  <1>                 inc     cx
  1125                              <1> length_loop_n2b:
  1126 00000C6F E82900              <1>                 call    getbit_cx_n2b
  1127 00000C72 73FB                <1>                 jnc     length_loop_n2b
  1128 00000C74 41                  <1>                 inc     cx
  1129 00000C75 41                  <1>                 inc     cx
  1130                              <1> copy_match_n2b:
  1131 00000C76 81FDD100            <1>                 cmp     bp, 0xd1
  1132 00000C7A 83D9FE              <1>                 sbb     cx, byte -2
  1133                              <1> 
  1134 00000C7D 29E8                <1>                 sub     ax, bp
  1135 00000C7F 720E                <1>                 jb      handle_underflow_n2b
  1136 00000C81 8ED8                <1>                 mov     ds, ax
  1137 00000C83 8D01                <1>                 lea     ax, [bx + di]
  1138                              <1> ds_ok_n2b:
  1139 00000C85 28FC                <1>                 sub     ah, bh
  1140 00000C87 96                  <1>                 xchg    ax, si
  1141 00000C88 F3                  <1>                 rep
  1142 00000C89 A4                  <1>                 movsb
  1143 00000C8A 96                  <1>                 xchg    ax, si
  1144 00000C8B 8EDA                <1>                 mov     ds, dx
  1145 00000C8D EBB5                <1>                 jmps    decompr_start_n2b
  1146                              <1> handle_underflow_n2b:
  1147                              <1> %ifdef  __N2BX8602__
  1148                              <1>                 shl     ax, 1
  1149                              <1>                 shl     ax, 1
  1150                              <1>                 shl     ax, 1
  1151                              <1>                 shl     ax, 1
  1152                              <1>                 push    ax
  1153                              <1>                 xor     ax, ax
  1154                              <1>                 mov     ds, ax
  1155                              <1>                 pop     ax
  1156                              <1> %else;  __N2B28602__
  1157 00000C8F C1E004              <1>                 shl     ax, 4
  1158 00000C92 6A00                <1>                 push    byte 0
  1159 00000C94 1F                  <1>                 pop     ds
  1160                              <1> %endif; __NRV2BEX3__
  1161 00000C95 01D8                <1>                 add     ax, bx
  1162 00000C97 01F8                <1>                 add     ax, di
  1163 00000C99 EBEA                <1>                 jmps    ds_ok_n2b
  1164                              <1> getbit_cx_n2b:
  1165 00000C9B 00FF                <1>                 add     bh, bh
  1166 00000C9D 7503                <1>                 jnz     gb2_n2b
  1167 00000C9F E80600              <1>                 call    reloadbh_n2b
  1168                              <1> gb2_n2b:
  1169 00000CA2 11C9                <1>                 adc     cx, cx
  1170                              <1> getbit_n2b:
  1171 00000CA4 00FF                <1>                 add     bh, bh
  1172 00000CA6 7505                <1>                 jnz     f2_n2b
  1173                              <1> reloadbh_n2b:
  1174 00000CA8 8A3C                <1>                 mov     bh, [si]
  1175                              <1> %ifdef  __NSIGT64K__
  1176                              <1>                 adc     si, si
  1177                              <1>                 jnc     si_ok_n2b
  1178                              <1>                 add     dh, 8
  1179                              <1>                 mov     ds, dx
  1180                              <1> si_ok_n2b:
  1181                              <1>                 shr     si, 1
  1182                              <1> %endif; __NRV2BEX9__
  1183 00000CAA 46                  <1>                 inc     si
  1184 00000CAB 10FF                <1>                 adc     bh, bh
  1185                              <1> f2_n2b:
  1186 00000CAD C3                  <1>                 ret
  1187                              <1> decomp_done_n2b:
  1188                              <1> ;       __NRV2B16E__
  1189                                  ;=============================================================================
  1190                                  
  1191                                  %endif
  1192                                  %endif
  1193                                  
  1194                                  ;=============================================================================
  1195                                  ; Compressed area starts here.
  1196                                  ;=============================================================================
  1197                                  sbm_real_start:
  1198 00000CAE 0E                      	push cs					; reinitialize cs, ds
  1199 00000CAF 0E                      	push cs
  1200 00000CB0 1F                      	pop ds
  1201 00000CB1 07                      	pop es
  1202                                  
  1203                                  ; clear the temp data area.
  1204 00000CB2 BF[F419]                	mov di, start_of_tmp_data
  1205 00000CB5 B91E1D                  	mov cx, end_of_tmp_data - start_of_tmp_data
  1206 00000CB8 E87623                          call clear_memory
  1207                                  
  1208                                  ; Install My Int 13H handle
  1209 00000CBB B301                    	mov bl, 1
  1210 00000CBD E82B30                  	call install_myint13h
  1211                                  
  1212                                  ;Initializing the CD-ROMs..
  1213                                  %ifndef DISABLE_CDBOOT
  1214 00000CC0 F606[2C00]08            	test byte [ADDR_SBMK_FLAGS], KNLFLAG_NOCDROM
  1215 00000CC5 750B                    	jnz .not_set_cdrom_ports
  1216 00000CC7 8B1E[3600]              	mov bx, [ADDR_SBMK_CDROM_IOPORTS]
  1217 00000CCB 8B0E[3800]              	mov cx, [ADDR_SBMK_CDROM_IOPORTS+2]
  1218 00000CCF E88A30                  	call set_io_ports
  1219                                  .not_set_cdrom_ports:
  1220                                  %endif
  1221                                  
  1222                                  
  1223                                  %ifndef EMULATE_PROG
  1224                                  
  1225                                  ; Set "No Int 13h Extension" flag
  1226 00000CD2 30C0                    	xor al, al
  1227 00000CD4 F606[2C00]04            	test byte [ADDR_SBMK_FLAGS], KNLFLAG_NOINT13EXT
  1228 00000CD9 7502                    	jnz .no_int13_ext
  1229 00000CDB FEC0                            inc al
  1230                                  .no_int13_ext:
  1231 00000CDD A2[EA3C]                	mov [use_int13_ext], al
  1232                                  
  1233                                  ; Do some initialization
  1234 00000CE0 E8ED09                  	call main_init_theme		; initialize the theme
  1235 00000CE3 E8CF0A                  	call main_init_video		; initialize the video mode.
  1236 00000CE6 E80D1B                          call window_initialize
  1237                                  
  1238                                  ; Check if needs scan boot records.
  1239 00000CE9 F606[2C00]01            	test byte [ADDR_SBMK_FLAGS], KNLFLAG_FIRSTSCAN
  1240 00000CEE 740D                    	jz .no_first_scan
  1241                                  
  1242 00000CF0 E8FF0A                  	call main_init_boot_records	; if it's the first time
  1243                                  					; to run this program,
  1244                                  					; call the init_boot_records.
  1245 00000CF3 E8D20A                  	call main_init_good_record_list
  1246                                  
  1247 00000CF6 8026[2C00]FE            	and byte [ADDR_SBMK_FLAGS], ~ KNLFLAG_FIRSTSCAN
  1248 00000CFB EB6D                    	jmp short .show_menu
  1249                                  
  1250                                  .no_first_scan:
  1251                                  
  1252                                  %ifdef Y2K_BUGFIX
  1253                                  
  1254                                  ;Initialize the Y2K bug workaround stuff
  1255                                  
  1256                                  ;Y2K fix for some BIOS which don't boot with years after 1999, we need to set
  1257                                  ;the year based on the last time we booted the machine
  1258 00000CFD B404                    	mov ah, 4
  1259 00000CFF CD1A                    	int 0x1a				;(bcd) cx=year dh=month ...
  1260 00000D01 7229                    	jc .y2k_donothing
  1261 00000D03 A1[3A00]                	mov ax,[ADDR_SBMK_Y2K_LAST_YEAR]
  1262 00000D06 09C0                    	or ax,ax
  1263 00000D08 7422                    	jz .y2k_donothing
  1264 00000D0A 3836[3C00]              	cmp [ADDR_SBMK_Y2K_LAST_MONTH],dh
  1265 00000D0E 7416                    	je .y2k_unbug
  1266 00000D10 720C                    	jb .y2k_chmonth
  1267 00000D12 40                      	inc ax	;we enter here only if above wich means we don't have CF
  1268 00000D13 27                      	daa	;this is a must as daa uses CF and inc doesn't set it
  1269 00000D14 86E0                    	xchg ah,al
  1270 00000D16 1400                    	adc al,0
  1271 00000D18 27                      	daa
  1272 00000D19 86E0                    	xchg ah,al
  1273 00000D1B A3[3A00]                	mov [ADDR_SBMK_Y2K_LAST_YEAR],ax
  1274                                  .y2k_chmonth:
  1275 00000D1E 8836[3C00]              	mov [ADDR_SBMK_Y2K_LAST_MONTH],dh
  1276 00000D22 FE06[352D]                      inc byte [main_tmp.change_occured]
  1277                                  .y2k_unbug:
  1278 00000D26 89C1                    	mov cx,ax
  1279 00000D28 B405                    	mov ah,5				; FIXME this can go one day
  1280 00000D2A CD1A                    	int 0x1a				; back if the day ends
  1281                                  .y2k_donothing:
  1282                                  %endif
  1283                                  
  1284                                  ; go ahead!
  1285                                  
  1286                                  ; Initialize the good record list
  1287 00000D2C E8990A                  	call main_init_good_record_list
  1288                                  
  1289                                  ; Initialize the keyboard shift var, and test if Ctrl is pressed down.
  1290 00000D2F B402                    	mov ah, 0x02			; test the keyboard status,
  1291 00000D31 E81021                  	call bioskey			; if ctrl pressed then show
  1292 00000D34 A2[0D2D]                        mov [utils_tmp.kbd_last_shift], al ; Initialize the kbd stat reg.
  1293 00000D37 A804                    	test al, kbCtrlMask		; menu directly,
  1294 00000D39 752F                    	jnz .show_menu			;
  1295                                  
  1296                                  ; Check direct boot, and schedule boot
  1297 00000D3B A0[2E00]                	mov al, [ADDR_SBMK_DIRECT_BOOT]	; check if need boot directly.
  1298 00000D3E 3C20                    	cmp al, MAX_RECORD_NUM		;
  1299 00000D40 7213                    	jb .go_direct_boot
  1300                                  
  1301 00000D42 E8870F                  	call main_do_schedule		; implement the schedule table.
  1302                                  
  1303 00000D45 803E[2D00]00            	cmp byte [ADDR_SBMK_DELAY_TIME], 0
  1304 00000D4A 751E                    	jnz .show_menu			; delay_time = 0, boot the
  1305                                  					; default record directly.
  1306 00000D4C A0[2F00]                	mov al, [ADDR_SBMK_DEFAULT_BOOT]
  1307 00000D4F 3C20                    	cmp al, MAX_RECORD_NUM
  1308 00000D51 720F                    	jb .go_def_boot
  1309 00000D53 EB15                    	jmp short .show_menu
  1310                                          
  1311                                  .go_direct_boot:
  1312 00000D55 C606[2E00]FF            	mov byte [ADDR_SBMK_DIRECT_BOOT], 0xff ; clear the direct boot sig.
  1313 00000D5A E8B20F                  	call main_save_boot_manager
  1314 00000D5D 7208                    	jc .disk_error
  1315                                  
  1316 00000D5F A2[2F00]                	mov [ADDR_SBMK_DEFAULT_BOOT], al
  1317                                  
  1318                                  .go_def_boot:
  1319 00000D62 E8B20E                  	call main_boot_default
  1320 00000D65 EB03                    	jmp short .show_menu
  1321                                  
  1322                                  .disk_error:
  1323 00000D67 E8330E                  	call main_show_disk_error
  1324                                  
  1325                                  %else
  1326                                  ; For emulator program
  1327                                  	call main_init_video			; here is the code for
  1328                                  	call main_init_boot_records		; emulate program.
  1329                                          call main_init_good_record_list
  1330                                  	call main_do_schedule
  1331                                  %endif
  1332                                  
  1333                                  
  1334                                  .show_menu:
  1335 00000D6A E8B709                  	call main_init_all_menus	; initialize the command menus
  1336                                  
  1337                                  ;Initialize  time count var
  1338 00000D6D A0[2D00]                	mov al, [ADDR_SBMK_DELAY_TIME]
  1339 00000D70 3CFF                    	cmp al, 255
  1340 00000D72 7305                    	jae .not_count_time			; if delay_time = 255
  1341 00000D74 A2[2F2D]                	mov [main_tmp.time_count], al		; then do not count time.
  1342 00000D77 30C0                    	xor al, al
  1343                                  
  1344                                  .not_count_time:
  1345 00000D79 A2[322D]                	mov [main_tmp.key_pressed], al
  1346                                  
  1347                                  ; Set focus bar to the default record
  1348 00000D7C 8A1E[2F00]              	mov bl, [ADDR_SBMK_DEFAULT_BOOT]
  1349 00000D80 8D36[0F2D]              	lea si, [main_tmp.good_record_list]
  1350 00000D84 8A0E[C049]              	mov cl, [GOOD_RECORD_NUMBER]
  1351 00000D88 30ED                    	xor ch, ch
  1352 00000D8A 30FF                    	xor bh, bh
  1353                                          
  1354                                  .loop_search_def:
  1355 00000D8C AC                      	lodsb
  1356 00000D8D 38D8                    	cmp al, bl
  1357 00000D8F 7406                    	je .found_def
  1358 00000D91 FEC7                    	inc bh
  1359 00000D93 E2F7                    	loop .loop_search_def
  1360 00000D95 EB14                    	jmp short .go_ahead
  1361                                  
  1362                                  .found_def:
  1363 00000D97 883E[C149]              	mov [FOCUS_RECORD], bh
  1364 00000D9B 3A3E[BE49]              	cmp bh, [BOOT_MENU_AREA_HEIGHT]
  1365 00000D9F 720A                    	jb .go_ahead
  1366 00000DA1 FEC7                    	inc bh
  1367 00000DA3 2A3E[BE49]              	sub bh, [BOOT_MENU_AREA_HEIGHT]
  1368 00000DA7 883E[C249]              	mov [FIRST_VISIBLE_RECORD], bh
  1369                                  
  1370                                  ; Run the UI system
  1371                                  .go_ahead:
  1372 00000DAB BB[8049]                        mov bx, main_windows_data.root_window
  1373 00000DAE BE[9A49]                        mov si, main_windows_data.boot_menu
  1374 00000DB1 E8781A                          call window_execute
  1375                                  
  1376                                  .halt:
  1377 00000DB4 EBFE                            jmp short .halt
  1378                                  
  1379                                  ;=============================================================================
  1380                                  ;include area
  1381                                  ;=============================================================================
  1382                                  
  1383                                  %include "main-cmds.asm"
  1384                              <1> ; asmsyntax=nasm
  1385                              <1> ;
  1386                              <1> ; main-cmds.asm
  1387                              <1> ;
  1388                              <1> ; command handles for main program
  1389                              <1> ;
  1390                              <1> ; Copyright (C) 2000, Suzhe. See file COPYING for details.
  1391                              <1> ;
  1392                              <1> 
  1393                              <1> %ifdef MAIN
  1394                              <1> 
  1395                              <1> ;=============================================================================
  1396                              <1> ;main_show_help ---- show the help window
  1397                              <1> ;=============================================================================
  1398                              <1> main_show_help:
  1399 00000DB6 8B36[4F4C]          <1>         mov si, [str_idx.help_content]
  1400 00000DBA 09F6                <1>         or si, si
  1401 00000DBC 740D                <1>         jz .end
  1402                              <1>         
  1403 00000DBE A0[D84B]            <1> 	mov al, [color.help_msg]
  1404 00000DC1 8B1E[D64B]          <1> 	mov bx, [color.help_win]
  1405 00000DC5 BA[0D4C]            <1>         mov dx, str_idx.help
  1406 00000DC8 E80514              <1>         call message_box
  1407                              <1> .end:
  1408 00000DCB C3                  <1>         ret
  1409                              <1> 
  1410                              <1> ;=============================================================================
  1411                              <1> ;main_show_about ---- show the about window
  1412                              <1> ;=============================================================================
  1413                              <1> main_show_about:
  1414 00000DCC 8B36[4D4C]          <1>         mov si, [str_idx.about_content]
  1415 00000DD0 09F6                <1>         or si, si
  1416 00000DD2 740D                <1>         jz .end
  1417                              <1>         
  1418 00000DD4 A0[DB4B]            <1>         mov al, [color.about_msg]
  1419 00000DD7 8B1E[D94B]          <1>         mov bx, [color.about_win]
  1420 00000DDB BA[094C]            <1>         mov dx, str_idx.about
  1421 00000DDE E8EF13              <1>         call message_box
  1422                              <1> .end:
  1423 00000DE1 C3                  <1>         ret
  1424                              <1> 
  1425                              <1> ;=============================================================================
  1426                              <1> ;main_show_main_menu ---- show the main command menu
  1427                              <1> ;=============================================================================
  1428                              <1> main_show_main_menu:
  1429 00000DE2 BE[C549]            <1> 	mov si, main_windows_data.main_menu
  1430 00000DE5 E87E1A              <1> 	call window_run
  1431 00000DE8 C3                  <1> 	ret
  1432                              <1> 
  1433                              <1> ;=============================================================================
  1434                              <1> ;main_show_record_menu ---- show the record command menu
  1435                              <1> ;=============================================================================
  1436                              <1> main_show_record_menu:
  1437 00000DE9 BE[F049]            <1> 	mov si, main_windows_data.record_menu
  1438 00000DEC E8771A              <1> 	call window_run
  1439 00000DEF C3                  <1> 	ret
  1440                              <1> 
  1441                              <1> ;=============================================================================
  1442                              <1> ;main_show_sys_menu ---- show the sys command menu
  1443                              <1> ;=============================================================================
  1444                              <1> main_show_sys_menu:
  1445 00000DF0 BE[1B4A]            <1> 	mov si, main_windows_data.sys_menu
  1446 00000DF3 E8701A              <1> 	call window_run
  1447 00000DF6 C3                  <1> 	ret
  1448                              <1> 
  1449                              <1> ;=============================================================================
  1450                              <1> ;main_ask_save_changes ---- save boot manager to disk
  1451                              <1> ;=============================================================================
  1452                              <1> main_ask_save_changes:
  1453 00000DF7 803E[352D]00        <1>         cmp byte [main_tmp.change_occured], 0
  1454 00000DFC 7418                <1>         je .no_changes
  1455                              <1>         
  1456 00000DFE 8B36[554C]          <1>         mov si, [str_idx.ask_save_changes]
  1457 00000E02 E8F713              <1>         call info_box
  1458 00000E05 3D0D1C              <1>         cmp ax, kbEnter
  1459 00000E08 740D                <1>         je main_save_changes
  1460 00000E0A 3A06[A64B]          <1>         cmp al, [yes_key_lower]
  1461 00000E0E 7407                <1>         je main_save_changes
  1462 00000E10 3A06[A74B]          <1>         cmp al, [yes_key_upper]
  1463 00000E14 7401                <1>         je main_save_changes
  1464                              <1>         
  1465                              <1> .no_changes:
  1466 00000E16 C3                  <1>         ret
  1467                              <1> 
  1468                              <1> ;=============================================================================
  1469                              <1> ;main_save_changes ---- save boot manager to disk
  1470                              <1> ;=============================================================================
  1471                              <1> main_save_changes:
  1472                              <1> 
  1473                              <1> %ifndef EMULATE_PROG
  1474 00000E17 E8F50E              <1>         call main_save_boot_manager
  1475 00000E1A 720D                <1>         jc .disk_error
  1476                              <1> %endif
  1477                              <1> 
  1478 00000E1C C606[352D]00        <1>         mov byte [main_tmp.change_occured], 0       ; clear change signature.
  1479                              <1> 
  1480 00000E21 8B36[514C]          <1>         mov si, [str_idx.changes_saved]
  1481 00000E25 E8D413              <1>         call info_box
  1482 00000E28 C3                  <1>         ret
  1483                              <1> 
  1484                              <1> .disk_error:
  1485 00000E29 E8710D              <1>         call main_show_disk_error
  1486                              <1> .end:
  1487 00000E2C C3                  <1>         ret
  1488                              <1> 
  1489                              <1> %if 0
  1490                              <1> ;=============================================================================
  1491                              <1> ;main_change_video_mode ---- change the video mode
  1492                              <1> ;=============================================================================
  1493                              <1> main_change_video_mode:
  1494                              <1> 
  1495                              <1>         inc byte [change_occured]               ; some changes occured.
  1496                              <1> 
  1497                              <1>         mov al, [video_mode]
  1498                              <1>         not al
  1499                              <1>         mov [video_mode], al
  1500                              <1>         call init_video
  1501                              <1>         call draw_screen
  1502                              <1>         ret
  1503                              <1> %endif
  1504                              <1> 
  1505                              <1> ;=============================================================================
  1506                              <1> ;main_change_name ---- change the record name
  1507                              <1> ;=============================================================================
  1508                              <1> main_change_name:
  1509 00000E2D E8BC0D              <1>         call main_get_focus_record_pointer
  1510                              <1> 
  1511 00000E30 89F7                <1> 	mov di, si
  1512 00000E32 81C71600            <1> 	add di, struc_bootrecord.name
  1513                              <1> 
  1514 00000E36 0FB606[CF4B]        <1>         movzx ax, byte [color.input_box_msg]
  1515 00000E3B 8B1E[CD4B]          <1>         mov bx, [color.input_box]
  1516 00000E3F B90F0F              <1> 	mov cx, (MAX_NAME_LENGTH<<8)|MAX_NAME_LENGTH
  1517 00000E42 31D2                <1> 	xor dx, dx
  1518 00000E44 8B36[154C]          <1>         mov si, [str_idx.name]
  1519                              <1>         
  1520 00000E48 E88315              <1>         call input_box
  1521 00000E4B 7204                <1>         jc .end
  1522 00000E4D FE06[352D]          <1>         inc byte [main_tmp.change_occured]          ; some changes occured.
  1523                              <1> .end:
  1524 00000E51 C3                  <1>         ret
  1525                              <1> 
  1526                              <1> 
  1527                              <1> ;=============================================================================
  1528                              <1> ;main_login_as_root ---- login as root
  1529                              <1> ;=============================================================================
  1530                              <1> main_login_as_root:
  1531 00000E52 A0[362D]            <1> 	mov al, [main_tmp.root_login]
  1532 00000E55 08C0                <1> 	or al, al
  1533 00000E57 0F94C0              <1> 	setz al
  1534 00000E5A A2[362D]            <1> 	mov [main_tmp.root_login], al
  1535 00000E5D C3                  <1>         ret
  1536                              <1> 
  1537                              <1> 
  1538                              <1> ;=============================================================================
  1539                              <1> ;main_change_security_mode ---- change the secure mode
  1540                              <1> ;=============================================================================
  1541                              <1> main_change_security_mode:
  1542 00000E5E 8036[2C00]02        <1> 	xor byte [ADDR_SBMK_FLAGS], KNLFLAG_SECURITY
  1543 00000E63 FE06[352D]          <1>         inc byte [main_tmp.change_occured]
  1544 00000E67 C3                  <1>         ret
  1545                              <1> 
  1546                              <1> ;=============================================================================
  1547                              <1> ;main_change_root_password ---- change the root password
  1548                              <1> ;=============================================================================
  1549                              <1> main_change_root_password:
  1550 00000E68 B110                <1> 	mov cl, MAX_PASSWORD_LENGTH
  1551 00000E6A 8B36[174C]          <1>         mov si, [str_idx.new_root_passwd]
  1552 00000E6E E8A015              <1>         call input_password
  1553 00000E71 7241                <1>         jc .end
  1554 00000E73 89C3                <1>         mov bx, ax
  1555 00000E75 89D1                <1>         mov cx, dx
  1556                              <1> 
  1557 00000E77 53                  <1>         push bx
  1558 00000E78 51                  <1>         push cx
  1559 00000E79 B110                <1> 	mov cl, MAX_PASSWORD_LENGTH
  1560 00000E7B 8B36[1F4C]          <1>         mov si, [str_idx.retype_passwd]
  1561 00000E7F E88F15              <1>         call input_password
  1562 00000E82 59                  <1>         pop cx
  1563 00000E83 5B                  <1>         pop bx
  1564 00000E84 722E                <1>         jc .end
  1565 00000E86 39C3                <1>         cmp bx, ax
  1566 00000E88 7523                <1>         jne .wrong
  1567 00000E8A 39D1                <1>         cmp cx, dx
  1568 00000E8C 751F                <1>         jne .wrong
  1569                              <1> 
  1570 00000E8E 891E[3000]          <1>         mov [ADDR_SBMK_ROOT_PASSWORD], bx
  1571 00000E92 890E[3200]          <1>         mov [ADDR_SBMK_ROOT_PASSWORD+2], cx
  1572                              <1> 
  1573 00000E96 C606[362D]00        <1>         mov byte [main_tmp.root_login], 0
  1574 00000E9B 8026[2C00]FD        <1>         and byte [ADDR_SBMK_FLAGS], ~ KNLFLAG_SECURITY
  1575                              <1> 
  1576 00000EA0 8B36[534C]          <1>         mov si, [str_idx.passwd_changed]
  1577 00000EA4 E85513              <1>         call info_box
  1578                              <1> 
  1579 00000EA7 FE06[352D]          <1>         inc byte [main_tmp.change_occured]         ; some changes occured.
  1580 00000EAB EB07                <1>         jmp short .end
  1581                              <1> .wrong:
  1582 00000EAD 8B36[574C]          <1>         mov si, [str_idx.wrong_passwd]
  1583 00000EB1 E83613              <1>         call error_box
  1584                              <1> .end:
  1585 00000EB4 C3                  <1>         ret
  1586                              <1> 
  1587                              <1> ;=============================================================================
  1588                              <1> ;main_change_record_password ---- change the record password
  1589                              <1> ;=============================================================================
  1590                              <1> main_change_record_password:
  1591 00000EB5 B110                <1> 	mov cl, MAX_PASSWORD_LENGTH
  1592 00000EB7 8B36[1B4C]          <1>         mov si, [str_idx.new_record_passwd]
  1593 00000EBB E85315              <1>         call input_password
  1594 00000EBE 7237                <1>         jc .end
  1595 00000EC0 89C3                <1>         mov bx, ax
  1596 00000EC2 89D1                <1>         mov cx, dx
  1597                              <1> 
  1598 00000EC4 53                  <1>         push bx
  1599 00000EC5 51                  <1>         push cx
  1600 00000EC6 B110                <1> 	mov cl, MAX_PASSWORD_LENGTH
  1601 00000EC8 8B36[1F4C]          <1>         mov si, [str_idx.retype_passwd]
  1602 00000ECC E84215              <1>         call input_password
  1603 00000ECF 59                  <1>         pop cx
  1604 00000ED0 5B                  <1>         pop bx
  1605 00000ED1 7224                <1>         jc .end
  1606 00000ED3 39C3                <1>         cmp bx, ax
  1607 00000ED5 7519                <1>         jne .wrong
  1608 00000ED7 39D1                <1>         cmp cx, dx
  1609 00000ED9 7515                <1>         jne .wrong
  1610                              <1> 
  1611 00000EDB E80E0D              <1>         call main_get_focus_record_pointer
  1612 00000EDE 895C0E              <1>         mov [si+struc_bootrecord.password], bx
  1613 00000EE1 894C10              <1>         mov [si+struc_bootrecord.password+2], cx
  1614                              <1>         
  1615 00000EE4 8B36[534C]          <1>         mov si, [str_idx.passwd_changed]
  1616 00000EE8 E81113              <1>         call info_box
  1617                              <1> 
  1618 00000EEB FE06[352D]          <1>         inc byte [main_tmp.change_occured]         ; some changes occured.
  1619 00000EEF C3                  <1>         ret
  1620                              <1>         
  1621                              <1> .wrong:
  1622 00000EF0 8B36[574C]          <1>         mov si, [str_idx.wrong_passwd]
  1623 00000EF4 E8F312              <1>         call error_box
  1624                              <1> .end:
  1625 00000EF7 C3                  <1>         ret
  1626                              <1> 
  1627                              <1> ;=============================================================================
  1628                              <1> ;main_set_default_record ---- set the default boot record
  1629                              <1> ;=============================================================================
  1630                              <1> main_set_default_record:
  1631 00000EF8 8A0E[C149]          <1> 	mov cl, [FOCUS_RECORD]
  1632 00000EFC E8000D              <1> 	call main_get_record_pointer           ; get real record index
  1633                              <1> 
  1634 00000EFF 880E[2F00]          <1>         mov [ADDR_SBMK_DEFAULT_BOOT], cl
  1635 00000F03 FE06[352D]          <1>         inc byte [main_tmp.change_occured]      ; some changes occured.
  1636 00000F07 C3                  <1>         ret
  1637                              <1> 
  1638                              <1> ;=============================================================================
  1639                              <1> ;main_unset_default_record ---- unset the default boot record
  1640                              <1> ;=============================================================================
  1641                              <1> main_unset_default_record:
  1642 00000F08 C606[2F00]FF        <1>         mov byte [ADDR_SBMK_DEFAULT_BOOT], 0xFF
  1643 00000F0D FE06[352D]          <1>         inc byte [main_tmp.change_occured]      ; some changes occured.
  1644 00000F11 C3                  <1>         ret
  1645                              <1>         
  1646                              <1> ;=============================================================================
  1647                              <1> ;main_toggle_auto_active ---- toggle the auto active switch
  1648                              <1> ;=============================================================================
  1649                              <1> main_toggle_auto_active:
  1650 00000F12 E8D70C              <1>         call main_get_focus_record_pointer
  1651 00000F15 E8E829              <1>         call check_allow_act
  1652 00000F18 720D                <1>         jc .end
  1653                              <1> 
  1654 00000F1A E8DD0B              <1> 	call main_auth_record_action
  1655 00000F1D 7208                <1> 	jc .end
  1656                              <1> 
  1657 00000F1F 81340010            <1>         xor word [si + struc_bootrecord.flags], INFOFLAG_AUTOACTIVE
  1658 00000F23 FE06[352D]          <1>         inc byte [main_tmp.change_occured]        ; some changes occured.
  1659                              <1> .end:
  1660 00000F27 C3                  <1>         ret
  1661                              <1> 
  1662                              <1> ;=============================================================================
  1663                              <1> ;main_toggle_auto_hide ---- toggle the auto hide switch
  1664                              <1> ;=============================================================================
  1665                              <1> main_toggle_auto_hide:
  1666 00000F28 E8C10C              <1>         call main_get_focus_record_pointer
  1667 00000F2B E8AF29              <1>         call check_allow_hide
  1668 00000F2E 720D                <1>         jc .end
  1669                              <1> 
  1670 00000F30 E8C70B              <1> 	call main_auth_record_action
  1671 00000F33 7208                <1> 	jc .end
  1672                              <1>         
  1673 00000F35 81340004            <1>         xor word [si + struc_bootrecord.flags], INFOFLAG_AUTOHIDE
  1674 00000F39 FE06[352D]          <1>         inc byte [main_tmp.change_occured]        ; some changes occured.
  1675                              <1> 
  1676                              <1> .end:
  1677 00000F3D C3                  <1>         ret
  1678                              <1> 
  1679                              <1> ;=============================================================================
  1680                              <1> ;main_mark_active ---- mark the record active
  1681                              <1> ;=============================================================================
  1682                              <1> main_mark_active:
  1683 00000F3E E8AB0C              <1>         call main_get_focus_record_pointer
  1684 00000F41 E8BC29              <1>         call check_allow_act
  1685 00000F44 724F                <1>         jc .end
  1686                              <1> 
  1687 00000F46 E8B10B              <1> 	call main_auth_record_action
  1688 00000F49 724A                <1> 	jc .end
  1689                              <1> 
  1690 00000F4B 8A5402              <1>         mov dl, [si + struc_bootrecord.drive_id]
  1691                              <1> 
  1692 00000F4E 56                  <1>         push si
  1693 00000F4F 8D36[0F2D]          <1>         lea si, [main_tmp.good_record_list]
  1694 00000F53 8D3E[4000]          <1>         lea di, [ADDR_SBMK_BOOT_RECORDS]
  1695                              <1> 
  1696 00000F57 0FB60E[C049]        <1>         movzx cx, byte [GOOD_RECORD_NUMBER]
  1697 00000F5C B640                <1>         mov dh, SIZE_OF_BOOTRECORD
  1698 00000F5E 6631DB              <1>         xor ebx, ebx
  1699 00000F61 FC                  <1>         cld
  1700                              <1> .loop_clear_act:                                ; clear all active marks of
  1701 00000F62 57                  <1>         push di                                 ; the boot records in same
  1702 00000F63 AC                  <1>         lodsb                                   ; drive and father partition.
  1703 00000F64 F6E6                <1>         mul dh
  1704 00000F66 01C7                <1>         add di, ax
  1705 00000F68 3A5502              <1>         cmp dl, [di + struc_bootrecord.drive_id]
  1706 00000F6B 750A                <1>         jne .do_nothing
  1707 00000F6D 66395D06            <1>         cmp [di + struc_bootrecord.father_abs_addr], ebx
  1708 00000F71 7504                <1>         jne .do_nothing
  1709 00000F73 8125FFF7            <1>         and word [di + struc_bootrecord.flags], ~ INFOFLAG_ACTIVE
  1710                              <1> .do_nothing:
  1711 00000F77 5F                  <1>         pop di
  1712 00000F78 E2E8                <1>         loop .loop_clear_act
  1713                              <1> 
  1714 00000F7A 5E                  <1>         pop si
  1715                              <1>         
  1716 00000F7B E8B525              <1>         call mark_record_active
  1717 00000F7E 7206                <1>         jc .error                                ; mark active ok
  1718 00000F80 E8320C              <1>         call main_recheck_same_records           ; recheck same records
  1719 00000F83 7205                <1>         jc .disk_error
  1720 00000F85 C3                  <1>         ret
  1721                              <1> 
  1722                              <1> .error:
  1723 00000F86 09C0                <1>         or ax, ax
  1724 00000F88 7404                <1>         jz .cannot_act
  1725                              <1> 
  1726                              <1> .disk_error:
  1727 00000F8A E8100C              <1>         call main_show_disk_error
  1728 00000F8D C3                  <1>         ret
  1729                              <1> 
  1730                              <1> .cannot_act:
  1731 00000F8E 8B36[5B4C]          <1>         mov si, [str_idx.mark_act_failed]
  1732 00000F92 E85512              <1>         call error_box
  1733                              <1> .end:
  1734 00000F95 C3                  <1>         ret
  1735                              <1> 
  1736                              <1> ;=============================================================================
  1737                              <1> ;main_toggle_hidden ---- toggle a record's hidden attribute
  1738                              <1> ;=============================================================================
  1739                              <1> main_toggle_hidden:
  1740 00000F96 E8530C              <1>         call main_get_focus_record_pointer
  1741 00000F99 E84129              <1>         call check_allow_hide
  1742 00000F9C 721F                <1>         jc .end
  1743                              <1> 
  1744 00000F9E E8590B              <1> 	call main_auth_record_action
  1745 00000FA1 721A                <1> 	jc .end
  1746                              <1> 
  1747 00000FA3 E8F825              <1>         call toggle_record_hidden
  1748 00000FA6 7206                <1>         jc .error                                 ; toggle hidden ok
  1749 00000FA8 E80A0C              <1>         call main_recheck_same_records            ; recheck same records
  1750 00000FAB 7205                <1>         jc .disk_error
  1751 00000FAD C3                  <1>         ret
  1752                              <1> 
  1753                              <1> .error:
  1754 00000FAE 09C0                <1>         or ax, ax
  1755 00000FB0 7404                <1>         jz .cannot_hide
  1756                              <1> 
  1757                              <1> .disk_error:
  1758 00000FB2 E8E80B              <1>         call main_show_disk_error
  1759 00000FB5 C3                  <1>         ret
  1760                              <1> 
  1761                              <1> .cannot_hide:
  1762 00000FB6 8B36[5D4C]          <1>         mov si, [str_idx.toggle_hid_failed]
  1763 00000FBA E82D12              <1>         call error_box
  1764                              <1> .end:
  1765 00000FBD C3                  <1>         ret
  1766                              <1> 
  1767                              <1> ;=============================================================================
  1768                              <1> ;main_delete_record ---- delete a boot record
  1769                              <1> ;=============================================================================
  1770                              <1> main_delete_record:
  1771 00000FBE E82B0C              <1>         call main_get_focus_record_pointer
  1772 00000FC1 F7040002            <1>         test word [si + struc_bootrecord.flags], INFOFLAG_HIDDEN
  1773 00000FC5 7415                <1>         jz .del_it
  1774                              <1> 
  1775 00000FC7 E8D425              <1>         call toggle_record_hidden           ; unhide it first.
  1776 00000FCA 7310                <1>         jnc .del_it                         ; unhide ok, del it.
  1777                              <1> 
  1778 00000FCC 09C0                <1>         or ax, ax
  1779 00000FCE 7404                <1>         jz .cannot_hide
  1780 00000FD0 E8CA0B              <1>         call main_show_disk_error
  1781 00000FD3 C3                  <1>         ret
  1782                              <1> 
  1783                              <1> .cannot_hide:
  1784 00000FD4 8B36[5D4C]          <1>         mov si, [str_idx.toggle_hid_failed]
  1785 00000FD8 E80F12              <1>         call error_box
  1786 00000FDB C3                  <1>         ret
  1787                              <1> 
  1788                              <1> .del_it:
  1789 00000FDC 30C0                <1>         xor al, al
  1790 00000FDE 89F7                <1>         mov di, si
  1791 00000FE0 B94000              <1>         mov cx, SIZE_OF_BOOTRECORD
  1792 00000FE3 FC                  <1>         cld
  1793 00000FE4 F3AA                <1>         rep stosb
  1794                              <1> 
  1795 00000FE6 FE06[352D]          <1>         inc byte [main_tmp.change_occured]               ; some changes occured.
  1796                              <1> 
  1797 00000FEA E8DB07              <1>         call main_init_good_record_list
  1798 00000FED A0[C049]            <1>         mov al, [GOOD_RECORD_NUMBER]
  1799 00000FF0 08C0                <1>         or al, al
  1800 00000FF2 7415                <1>         jz .no_record
  1801                              <1>         
  1802 00000FF4 FEC8                <1>         dec al
  1803 00000FF6 3A06[C249]          <1>         cmp al, [FIRST_VISIBLE_RECORD]                  ; adjust the cursor
  1804 00000FFA 7303                <1>         jae .check_focus_pos                            ; and menu position.
  1805 00000FFC A2[C249]            <1>         mov [FIRST_VISIBLE_RECORD], al                  ;
  1806                              <1> .check_focus_pos:                                       ;
  1807 00000FFF 3A06[C149]          <1>         cmp al, [FOCUS_RECORD]                          ;
  1808 00001003 730A                <1>         jae .end                                        ;
  1809 00001005 A2[C149]            <1>         mov [FOCUS_RECORD], al                          ;
  1810 00001008 C3                  <1>         ret
  1811                              <1> 
  1812                              <1> .no_record:
  1813 00001009 A2[C249]            <1>         mov [FIRST_VISIBLE_RECORD], al
  1814 0000100C A2[C149]            <1>         mov [FOCUS_RECORD], al
  1815                              <1> .end:
  1816 0000100F C3                  <1>         ret
  1817                              <1>         
  1818                              <1> 
  1819                              <1> ;=============================================================================
  1820                              <1> ;main_rescan_all_drives ---- research all drives for boot records
  1821                              <1> ;=============================================================================
  1822                              <1> main_rescan_all_records:
  1823 00001010 8026[2C00]DF        <1>         and byte [ADDR_SBMK_FLAGS], ~ KNLFLAG_ONLYPARTS
  1824 00001015 EB05                <1>         jmp short main_rescan_records
  1825                              <1>         
  1826                              <1> ;=============================================================================
  1827                              <1> ;rescan_fixed_drives ---- research fixed drives for boot records
  1828                              <1> ;=============================================================================
  1829                              <1> main_rescan_all_partitions:
  1830 00001017 800E[2C00]20        <1>         or byte [ADDR_SBMK_FLAGS], KNLFLAG_ONLYPARTS
  1831                              <1>         
  1832                              <1> ;=============================================================================
  1833                              <1> ;rescan_records ---- research all drives for boot records
  1834                              <1> ;=============================================================================
  1835                              <1> main_rescan_records:
  1836 0000101C 0FB60E[C049]        <1>         movzx cx, byte [GOOD_RECORD_NUMBER]
  1837 00001021 08C9                <1>         or cl, cl                               ; if no good record then go to
  1838 00001023 7423                <1>         jz .init_it                             ; init directly.
  1839                              <1>         
  1840 00001025 8D3E[0F2D]          <1>         lea di, [main_tmp.good_record_list]
  1841 00001029 B240                <1>         mov dl, SIZE_OF_BOOTRECORD
  1842                              <1> 
  1843                              <1> ; unhide all hidden partition first.
  1844                              <1> .loop_unhide:
  1845 0000102B 8A05                <1>         mov al, [di]
  1846 0000102D 47                  <1>         inc di
  1847 0000102E F6E2                <1>         mul dl
  1848 00001030 8D36[4000]          <1>         lea si, [ADDR_SBMK_BOOT_RECORDS]
  1849 00001034 01C6                <1>         add si, ax
  1850 00001036 F7040002            <1>         test word [si + struc_bootrecord.flags], INFOFLAG_HIDDEN
  1851 0000103A 740A                <1>         jz .not_hidden
  1852 0000103C E85F25              <1>         call toggle_record_hidden
  1853 0000103F 721A                <1>         jc .hidden_error
  1854 00001041 E8710B              <1>         call main_recheck_same_records
  1855 00001044 7219                <1>         jc .disk_error
  1856                              <1> 
  1857                              <1> .not_hidden:
  1858 00001046 E2E3                <1>         loop .loop_unhide
  1859                              <1>         
  1860                              <1> .init_it:
  1861 00001048 FE06[352D]          <1>         inc byte [main_tmp.change_occured]               ; some changes occured.
  1862                              <1> 
  1863 0000104C E8A307              <1>         call main_init_boot_records
  1864 0000104F E87607              <1>         call main_init_good_record_list
  1865                              <1> 
  1866 00001052 30C0                <1>         xor al, al
  1867 00001054 A2[C149]            <1>         mov byte [FOCUS_RECORD], al
  1868 00001057 A2[C249]            <1>         mov byte [FIRST_VISIBLE_RECORD], al
  1869 0000105A C3                  <1> 	ret
  1870                              <1>         
  1871                              <1> .hidden_error:
  1872 0000105B 09C0                <1>         or ax, ax
  1873 0000105D 7404                <1>         jz .cannot_hide
  1874                              <1> 
  1875                              <1> .disk_error:
  1876 0000105F E83B0B              <1>         call main_show_disk_error
  1877 00001062 C3                  <1>         ret
  1878                              <1> 
  1879                              <1> .cannot_hide:
  1880 00001063 8B36[5D4C]          <1>         mov si, [str_idx.toggle_hid_failed]
  1881 00001067 E88011              <1>         call error_box
  1882                              <1> .end:
  1883 0000106A C3                  <1>         ret
  1884                              <1> 
  1885                              <1> ;=============================================================================
  1886                              <1> ;main_set_delay_time ---- set the delay time
  1887                              <1> ;=============================================================================
  1888                              <1> main_set_delay_time:
  1889 0000106B 0FB606[CF4B]        <1>         movzx ax, [color.input_box_msg]
  1890 00001070 8B1E[CD4B]          <1>         mov bx, [color.input_box]
  1891 00001074 B90303              <1>         mov cx, 0x0303
  1892 00001077 31D2                <1> 	xor dx, dx
  1893 00001079 8B36[134C]          <1>         mov si, [str_idx.delay_time]
  1894 0000107D BF[BE35]            <1>         mov di, main_tmp.dialog_buf
  1895 00001080 8835                <1>         mov [di], dh
  1896 00001082 E84913              <1>         call input_box
  1897 00001085 7213                <1>         jc .end
  1898                              <1> 
  1899 00001087 89FE                <1>         mov si, di
  1900 00001089 E85E1B              <1>         call atoi
  1901                              <1> 
  1902 0000108C 3DFF00              <1>         cmp ax, 255
  1903 0000108F 7602                <1>         jbe .set_time
  1904 00001091 B0FF                <1>         mov al, 255
  1905                              <1> .set_time:
  1906 00001093 A2[2D00]            <1>         mov [ADDR_SBMK_DELAY_TIME], al
  1907 00001096 FE06[352D]          <1>         inc byte [main_tmp.change_occured]         ; some changes occured.
  1908                              <1> .end:
  1909 0000109A C3                  <1>         ret
  1910                              <1> 
  1911                              <1> ;=============================================================================
  1912                              <1> ;main_boot_it ---- boot the selected record
  1913                              <1> ;=============================================================================
  1914                              <1> main_boot_it:
  1915 0000109B 8A0E[C149]          <1> 	mov cl, [FOCUS_RECORD]
  1916 0000109F E85D0B              <1> 	call main_get_record_pointer
  1917 000010A2 88C8                <1> 	mov al, cl
  1918 000010A4 50                  <1> 	push ax
  1919                              <1> 
  1920 000010A5 F606[2C00]10        <1>         test byte [ADDR_SBMK_FLAGS], KNLFLAG_REMLAST
  1921 000010AA 740D                <1>         jz .no_remlast
  1922                              <1> 
  1923 000010AC A2[2F00]            <1>         mov [ADDR_SBMK_DEFAULT_BOOT], al
  1924                              <1>        
  1925 000010AF E85D0C              <1>         call main_save_boot_manager
  1926 000010B2 7308                <1>         jnc .cont_boot
  1927                              <1> 
  1928 000010B4 E8E60A              <1>         call main_show_disk_error
  1929 000010B7 EB03                <1>         jmp short .cont_boot
  1930                              <1> 
  1931                              <1> .no_remlast:
  1932 000010B9 E83BFD              <1>         call main_ask_save_changes              ; ask if save the changes.
  1933                              <1> 
  1934                              <1> .cont_boot:
  1935 000010BC E8C50C              <1>         call main_hide_auto_hides
  1936 000010BF 58                  <1>         pop ax
  1937 000010C0 7203                <1>         jc .end
  1938                              <1>  
  1939 000010C2 E8760B              <1>         call main_do_boot_record
  1940                              <1> .end:
  1941 000010C5 C3                  <1>         ret
  1942                              <1> 
  1943                              <1> ;=============================================================================
  1944                              <1> ;main_return_to_bios ---- give control back to BIOS
  1945                              <1> ;=============================================================================
  1946                              <1> main_return_to_bios:
  1947 000010C6 E82EFD              <1>         call main_ask_save_changes              ; ask if save the changes.
  1948                              <1>         
  1949 000010C9 E8ED0F              <1>         call reset_video_mode
  1950                              <1>         
  1951 000010CC E8622C              <1> 	call uninstall_myint13h
  1952                              <1> %ifdef EMULATE_PROG
  1953                              <1>         mov ax, 0x4c00                          ; exit to dos
  1954                              <1>         int 0x21                                ;
  1955                              <1> %else
  1956 000010CF CD18                <1>         int 0x18                                ; return to BIOS
  1957                              <1> %endif
  1958                              <1> 
  1959                              <1> .end:
  1960 000010D1 C3                  <1>         ret
  1961                              <1> 
  1962                              <1> 
  1963                              <1> ;=============================================================================
  1964                              <1> ; Duplicate the boot record
  1965                              <1> ;=============================================================================
  1966                              <1> main_dup_record:
  1967 000010D2 B84000              <1>         mov ax, SIZE_OF_BOOTRECORD
  1968 000010D5 B92000              <1>         mov cx, MAX_RECORD_NUM
  1969 000010D8 BF[4000]            <1>         mov di, ADDR_SBMK_BOOT_RECORDS
  1970                              <1> 
  1971                              <1> .search_empty_slot:
  1972 000010DB F60509              <1>         test byte [di + struc_bootrecord.flags], DRVFLAG_DRIVEOK | INFOFLAG_ISSPECIAL
  1973 000010DE 7405                <1>         jz .found_empty
  1974 000010E0 01C7                <1>         add di, ax
  1975 000010E2 E2F7                <1>         loop .search_empty_slot
  1976 000010E4 C3                  <1> 	ret
  1977                              <1> 
  1978                              <1> .found_empty:
  1979                              <1> 
  1980 000010E5 FE06[352D]          <1>         inc byte [main_tmp.change_occured]
  1981                              <1> 
  1982 000010E9 E8000B              <1>         call main_get_focus_record_pointer
  1983 000010EC 89C1                <1>         mov cx, ax
  1984 000010EE FC                  <1>         cld
  1985 000010EF F3A4                <1>         rep movsb
  1986 000010F1 E8D406              <1>         call main_init_good_record_list
  1987 000010F4 C3                  <1>         ret
  1988                              <1> 
  1989                              <1> 
  1990                              <1> 
  1991                              <1> ;=============================================================================
  1992                              <1> ; move the boot record down 
  1993                              <1> ;=============================================================================
  1994                              <1> main_move_record_down:
  1995 000010F5 0FB61E[C149]        <1>         movzx bx, byte [FOCUS_RECORD]
  1996 000010FA 8A87[0F2D]          <1>         mov al, [main_tmp.good_record_list + bx]
  1997 000010FE FEC3                <1>         inc bl
  1998 00001100 8AA7[0F2D]          <1>         mov ah, [main_tmp.good_record_list + bx]
  1999 00001104 3A1E[C049]          <1>         cmp bl, [GOOD_RECORD_NUMBER]
  2000 00001108 731C                <1>         jae .end
  2001                              <1> 
  2002 0000110A 3A06[2F00]          <1>         cmp al, [ADDR_SBMK_DEFAULT_BOOT]
  2003 0000110E 7506                <1>         jne .chknext
  2004 00001110 8826[2F00]          <1>         mov [ADDR_SBMK_DEFAULT_BOOT], ah
  2005 00001114 EB09                <1>         jmp short .swap_record
  2006                              <1> .chknext:
  2007 00001116 3A26[2F00]          <1>         cmp ah, [ADDR_SBMK_DEFAULT_BOOT]
  2008 0000111A 7503                <1>         jne .swap_record
  2009 0000111C A2[2F00]            <1>         mov [ADDR_SBMK_DEFAULT_BOOT], al
  2010                              <1> 
  2011                              <1> .swap_record:
  2012 0000111F 881E[C149]          <1>         mov [FOCUS_RECORD], bl
  2013 00001123 E83100              <1>         call main_swap_records
  2014                              <1> .end:
  2015 00001126 C3                  <1>         ret
  2016                              <1> 
  2017                              <1> ;=============================================================================
  2018                              <1> ; move the boot record up
  2019                              <1> ;=============================================================================
  2020                              <1> main_move_record_up:
  2021 00001127 0FB61E[C149]        <1>         movzx bx, byte [FOCUS_RECORD]
  2022 0000112C 08DB                <1>         or bl, bl
  2023 0000112E 7426                <1>         jz .end
  2024 00001130 8A87[0F2D]          <1>         mov al, [main_tmp.good_record_list + bx]
  2025 00001134 FECB                <1>         dec bl
  2026 00001136 8AA7[0F2D]          <1>         mov ah, [main_tmp.good_record_list + bx]
  2027                              <1> 
  2028 0000113A 3A06[2F00]          <1>         cmp al, [ADDR_SBMK_DEFAULT_BOOT]
  2029 0000113E 7506                <1>         jne .chknext
  2030 00001140 8826[2F00]          <1>         mov [ADDR_SBMK_DEFAULT_BOOT], ah
  2031 00001144 EB09                <1>         jmp short .swap_record
  2032                              <1> .chknext:
  2033 00001146 3A26[2F00]          <1>         cmp ah, [ADDR_SBMK_DEFAULT_BOOT]
  2034 0000114A 7503                <1>         jne .swap_record
  2035 0000114C A2[2F00]            <1>         mov [ADDR_SBMK_DEFAULT_BOOT], al
  2036                              <1> 
  2037                              <1> .swap_record:
  2038                              <1>   
  2039 0000114F E80500              <1>         call main_swap_records
  2040 00001152 881E[C149]          <1>         mov [FOCUS_RECORD],bl
  2041                              <1> .end:
  2042 00001156 C3                  <1>         ret
  2043                              <1> 
  2044                              <1> ;=============================================================================
  2045                              <1> ; swap current and previous boot record
  2046                              <1> ;=============================================================================
  2047                              <1> main_swap_records:
  2048 00001157 60                  <1> 	pusha
  2049 00001158 FE0E[C149]          <1>         dec byte [FOCUS_RECORD]
  2050 0000115C E88D0A              <1>         call main_get_focus_record_pointer
  2051 0000115F 89F7                <1> 	mov di, si
  2052 00001161 FE06[C149]          <1> 	inc byte [FOCUS_RECORD]
  2053 00001165 E8840A              <1> 	call main_get_focus_record_pointer	; si -> current  di -> prev
  2054                              <1> 
  2055 00001168 B94000              <1>         mov cx, SIZE_OF_BOOTRECORD
  2056                              <1> 
  2057                              <1> .loop_swap:
  2058 0000116B 8A04                <1> 	mov al, [si]
  2059 0000116D 8A1D                <1> 	mov bl, [di]
  2060 0000116F 881C                <1> 	mov [si], bl
  2061 00001171 8805                <1> 	mov [di], al
  2062 00001173 46                  <1> 	inc si
  2063 00001174 47                  <1> 	inc di
  2064 00001175 E2F4                <1> 	loop .loop_swap
  2065 00001177 61                  <1> 	popa
  2066                              <1> 
  2067 00001178 C3                  <1>         ret
  2068                              <1> 
  2069                              <1> ;=============================================================================
  2070                              <1> ;main_toggle_swapid ---- toggle the swap driver id flag 
  2071                              <1> ;=============================================================================
  2072                              <1> main_toggle_swapid:
  2073 00001179 E8700A              <1> 	call main_get_focus_record_pointer
  2074 0000117C 09F6                <1> 	or si, si
  2075 0000117E 7416                <1> 	jz .end
  2076 00001180 F7041800            <1> 	test word [si + struc_bootrecord.flags], DRVFLAG_ISCDROM | INFOFLAG_ISSPECIAL
  2077 00001184 7510                <1> 	jnz .end
  2078                              <1> 
  2079 00001186 E87109              <1> 	call main_auth_record_action
  2080 00001189 720B                <1> 	jc .end
  2081                              <1> 
  2082 0000118B 81340020            <1>         xor word [si + struc_bootrecord.flags], INFOFLAG_SWAPDRVID
  2083 0000118F E8DB1F              <1>         call check_bootrecord
  2084 00001192 FE06[352D]          <1>         inc byte [main_tmp.change_occured]
  2085                              <1> .end:
  2086 00001196 C3                  <1>         ret
  2087                              <1> 
  2088                              <1> ;=============================================================================
  2089                              <1> ;main_toggle_schedule ---- toggle the schedule of the bootrecord
  2090                              <1> ;=============================================================================
  2091                              <1> main_toggle_schedule:
  2092 00001197 E8520A              <1>         call main_get_focus_record_pointer
  2093 0000119A F7040080            <1>         test word [si + struc_bootrecord.flags], INFOFLAG_SCHEDULED
  2094 0000119E 7512                <1>         jnz .clear_schedule
  2095                              <1> 
  2096 000011A0 56                  <1>         push si
  2097 000011A1 E81700              <1>         call main_input_schedule_time
  2098 000011A4 5E                  <1>         pop si
  2099 000011A5 7213                <1>         jc .end
  2100                              <1> 
  2101 000011A7 09D2                <1>         or dx, dx
  2102 000011A9 7502                <1>         jnz .set_schedule
  2103 000011AB F7D2                <1>         not dx
  2104                              <1> 
  2105                              <1> .set_schedule:
  2106 000011AD E85B24              <1>         call set_record_schedule
  2107 000011B0 EB04                <1>         jmp short .end_ok
  2108                              <1> 
  2109                              <1> .clear_schedule:
  2110 000011B2 8124FF7F            <1>         and word [si + struc_bootrecord.flags], ~INFOFLAG_SCHEDULED
  2111                              <1> 
  2112                              <1> .end_ok:
  2113 000011B6 FE06[352D]          <1>         inc byte [main_tmp.change_occured]
  2114                              <1> .end:
  2115 000011BA C3                  <1>         ret
  2116                              <1> 
  2117                              <1> ;=============================================================================
  2118                              <1> ;main_input_schedule_time ---- input the schedule time
  2119                              <1> ;input:
  2120                              <1> ;      none
  2121                              <1> ;output:
  2122                              <1> ;      cf = 0 success, 
  2123                              <1> ;           ax = begin time (in minutes)
  2124                              <1> ;           bx = end time (in minutes)
  2125                              <1> ;           dx = days info (bit 0 to bit 7 indicate Mon to Sun)
  2126                              <1> ;      cf = 1 cancel
  2127                              <1> ;=============================================================================
  2128                              <1> main_input_schedule_time:
  2129 000011BB 60                  <1>         pusha
  2130                              <1> 
  2131 000011BC 31C0                <1>         xor ax, ax
  2132 000011BE B90400              <1> 	mov cx, 4
  2133 000011C1 FC                  <1> 	cld
  2134 000011C2 BF[392D]            <1> 	mov di, main_tmp.schedule_begin
  2135 000011C5 F3AB                <1> 	rep stosw
  2136                              <1> 
  2137 000011C7 A0[CF4B]            <1>         mov al, [color.input_box_msg]
  2138 000011CA 8B1E[CD4B]          <1>         mov bx, [color.input_box_frame]
  2139 000011CE B91313              <1>         mov cx, 0x1313
  2140 000011D1 31D2                <1> 	xor dx, dx
  2141 000011D3 8B36[214C]          <1>         mov si, [str_idx.input_schedule]
  2142 000011D7 BF[BE35]            <1>         mov di, main_tmp.dialog_buf
  2143 000011DA C60500              <1> 	mov byte [di], 0 
  2144                              <1>         
  2145 000011DD E8EE11              <1>         call input_box
  2146 000011E0 724C                <1>         jc .exit
  2147                              <1> 
  2148                              <1> ;convert begin time
  2149 000011E2 89FE                <1>         mov si, di
  2150 000011E4 E85400              <1> 	call main_str_to_schtime
  2151 000011E7 723D                <1> 	jc .invalid_input
  2152 000011E9 A3[392D]            <1>         mov [main_tmp.schedule_begin], ax
  2153                              <1> 
  2154                              <1> ;convert end time
  2155 000011EC AC                  <1> 	lodsb
  2156 000011ED 3C2D                <1> 	cmp al,'-'
  2157 000011EF 7535                <1> 	jne .invalid_input
  2158                              <1> 
  2159 000011F1 E84700              <1> 	call main_str_to_schtime
  2160 000011F4 7230                <1> 	jc .invalid_input
  2161 000011F6 A3[3B2D]            <1>         mov [main_tmp.schedule_end], ax
  2162                              <1> 
  2163                              <1> ;convert day info
  2164 000011F9 AC                  <1>         lodsb
  2165 000011FA 08C0                <1>         or al, al
  2166 000011FC 7425                <1>         jz .end
  2167                              <1> 
  2168 000011FE 3C3B                <1>         cmp al, ';'
  2169 00001200 7524                <1>         jne .invalid_input
  2170                              <1> 
  2171 00001202 B90700              <1>         mov cx, 7
  2172 00001205 31D2                <1>         xor dx, dx
  2173                              <1> 
  2174                              <1> .loop_get_days:
  2175 00001207 AC                  <1>         lodsb
  2176 00001208 08C0                <1>         or al, al
  2177 0000120A 7413                <1>         jz .end_get_days
  2178 0000120C 2C30                <1>         sub al, '0'
  2179 0000120E 3C07                <1>         cmp al, 7
  2180 00001210 7314                <1>         jae .invalid_input
  2181 00001212 BB0100              <1>         mov bx, 1
  2182 00001215 51                  <1>         push cx
  2183 00001216 88C1                <1>         mov cl, al
  2184 00001218 D3E3                <1>         shl bx, cl
  2185 0000121A 59                  <1>         pop cx
  2186 0000121B 09DA                <1>         or dx, bx
  2187 0000121D E2E8                <1>         loop .loop_get_days
  2188                              <1> 
  2189                              <1> .end_get_days:
  2190 0000121F 8916[3D2D]          <1>         mov [main_tmp.schedule_day], dx
  2191                              <1> 
  2192                              <1> .end:
  2193 00001223 F8                  <1> 	clc
  2194 00001224 EB08                <1> 	jmp short .exit
  2195                              <1> 
  2196                              <1> .invalid_input:
  2197 00001226 8B36[634C]          <1>         mov si, [str_idx.invalid_schedule]
  2198 0000122A E8BD0F              <1>         call error_box
  2199 0000122D F9                  <1>         stc
  2200                              <1> .exit:
  2201 0000122E 61                  <1>         popa
  2202 0000122F A1[392D]            <1>         mov ax, [main_tmp.schedule_begin]
  2203 00001232 8B1E[3B2D]          <1>         mov bx, [main_tmp.schedule_end]
  2204 00001236 8B16[3D2D]          <1>         mov dx, [main_tmp.schedule_day]
  2205 0000123A C3                  <1>         ret
  2206                              <1> 
  2207                              <1> 
  2208                              <1> ;=============================================================================
  2209                              <1> ;input ds:si -> string
  2210                              <1> ;output cf =0 ok, ax = time in minutes
  2211                              <1> ;       cf =1 fail
  2212                              <1> ;=============================================================================
  2213                              <1> main_str_to_schtime:
  2214 0000123B 31DB                <1> 	xor bx, bx
  2215 0000123D 31C9                <1> 	xor cx, cx
  2216                              <1> 
  2217 0000123F E8A819              <1>         call atoi
  2218 00001242 3C18                <1>         cmp al, 24                          ; hh must be less than 24
  2219 00001244 771D                <1>         ja .fail
  2220                              <1> 
  2221 00001246 88C3                <1>         mov bl, al
  2222 00001248 AC                  <1> 	lodsb
  2223 00001249 3C3A                <1> 	cmp al, ':'
  2224 0000124B 7516                <1> 	jne .fail
  2225                              <1> 
  2226 0000124D E89A19              <1>         call atoi
  2227 00001250 3C3C                <1>         cmp al, 60                          ; mm must be less than 60
  2228 00001252 730F                <1>         jae .fail
  2229 00001254 88C1                <1>         mov cl, al
  2230                              <1> 
  2231 00001256 B03C                <1>         mov al, 60
  2232 00001258 F6E3                <1>         mul bl
  2233 0000125A 01C8                <1>         add ax, cx
  2234 0000125C 3DA005              <1>         cmp ax, 24*60                       ; begin time must be no more than
  2235 0000125F 7702                <1>         ja .fail                            ; 24*60 minutes
  2236 00001261 F8                  <1> 	clc
  2237 00001262 C3                  <1> 	ret
  2238                              <1> .fail:
  2239 00001263 F9                  <1> 	stc
  2240 00001264 C3                  <1> 	ret
  2241                              <1> 
  2242                              <1> ;=============================================================================
  2243                              <1> ;main_toggle_keystrokes ---- toggle the keystrokes switch of the bootrecord
  2244                              <1> ;=============================================================================
  2245                              <1> main_toggle_keystrokes:
  2246                              <1> 
  2247 00001265 E88409              <1>         call main_get_focus_record_pointer
  2248 00001268 F7040040            <1>         test word [si + struc_bootrecord.flags], INFOFLAG_HAVEKEYS
  2249 0000126C 7406                <1>         jz .input_keys
  2250                              <1> 
  2251 0000126E 8124FFBF            <1>         and word [si + struc_bootrecord.flags], ~INFOFLAG_HAVEKEYS
  2252 00001272 EB12                <1>         jmp short .end_ok
  2253                              <1> 
  2254                              <1> .input_keys:
  2255 00001274 8D7C26              <1>         lea di, [si + struc_bootrecord.keystrokes]
  2256 00001277 B10D                <1>         mov cl, MAX_KEYSTROKES
  2257 00001279 56                  <1>         push si
  2258 0000127A E89A00              <1>         call main_input_keystrokes
  2259 0000127D 5E                  <1>         pop si
  2260 0000127E 08ED                <1>         or ch, ch
  2261 00001280 7408                <1>         jz .end
  2262                              <1> 
  2263 00001282 810C0040            <1>         or word [si + struc_bootrecord.flags], INFOFLAG_HAVEKEYS
  2264                              <1> 
  2265                              <1> .end_ok:
  2266 00001286 FE06[352D]          <1>         inc byte [main_tmp.change_occured]
  2267                              <1> .end:
  2268 0000128A C3                  <1>         ret
  2269                              <1> 
  2270                              <1> ;=============================================================================
  2271                              <1> ; main_ikbox_event_handle ---- event handle for Input keystroke box
  2272                              <1> ;=============================================================================
  2273                              <1> main_ikbox_event_handle:
  2274 0000128B 80FCF0              <1>         cmp ah, EVTCODE_COMMAND
  2275 0000128E 720A                <1>         jb .normal_key
  2276                              <1> 
  2277 00001290 3D10F2              <1>         cmp ax, EVENT_SCROLL_OFF
  2278 00001293 7524                <1>         jne .end
  2279                              <1> 
  2280 00001295 E82616              <1>         call window_close
  2281 00001298 F8                  <1>         clc
  2282 00001299 C3                  <1>         ret
  2283                              <1> 
  2284                              <1> .normal_key:
  2285 0000129A FC                  <1>         cld
  2286 0000129B 8B3E[3F2D]          <1>         mov di, [main_tmp.keystroke_ptr]
  2287 0000129F 0FB60E[412D]        <1>         movzx cx, [main_tmp.keystroke_num]
  2288 000012A4 3A0E[422D]          <1>         cmp cl, [main_tmp.keystroke_max]
  2289 000012A8 730F                <1>         jae .end
  2290                              <1> 
  2291 000012AA D1E1                <1>         shl cx, 1
  2292 000012AC 01CF                <1>         add di, cx
  2293 000012AE AB                  <1>         stosw
  2294                              <1> 
  2295 000012AF FE06[412D]          <1>         inc byte [main_tmp.keystroke_num]
  2296 000012B3 E80500              <1>         call main_ikbox_prepare
  2297 000012B6 E8FA13              <1>         call window_draw_body
  2298                              <1> .end:
  2299 000012B9 F8                  <1>         clc
  2300 000012BA C3                  <1>         ret
  2301                              <1> 
  2302                              <1> ;=============================================================================
  2303                              <1> ;main_ikbox_prepare
  2304                              <1> ;input:
  2305                              <1> ;       ds:si -> the message_box struc
  2306                              <1> ;=============================================================================
  2307                              <1> main_ikbox_prepare:
  2308 000012BB C74416[8B12]        <1>         mov word [si + struc_window.event_handle],main_ikbox_event_handle
  2309 000012C0 31C0                <1> 	xor ax, ax
  2310                              <1> 
  2311 000012C2 56                  <1>         push si
  2312 000012C3 8B7C1A              <1>         mov di, [si + struc_message_box.message]
  2313 000012C6 8B36[234C]          <1>         mov si, [str_idx.input_keystrokes]
  2314 000012CA 57                  <1>         push di
  2315                              <1> 
  2316 000012CB E89919              <1>         call strcpy
  2317 000012CE 57                  <1>         push di
  2318 000012CF 0FB60E[412D]        <1>         movzx cx, byte [main_tmp.keystroke_num]
  2319                              <1> 
  2320 000012D4 D1E1                <1>         shl cx,1
  2321 000012D6 8B3E[3F2D]          <1>         mov di, [main_tmp.keystroke_ptr]
  2322 000012DA 01CF                <1>         add di, cx
  2323 000012DC 09C9                <1> 	or cx, cx
  2324 000012DE 7404                <1> 	jz .first_prepare
  2325 000012E0 81EF0200            <1> 	sub di, 2
  2326                              <1> .first_prepare:
  2327 000012E4 8B05                <1> 	mov ax, [di]
  2328                              <1> 
  2329 000012E6 5F                  <1>         pop di
  2330 000012E7 51                  <1>         push cx
  2331                              <1>         
  2332 000012E8 B104                <1>         mov cl, 4
  2333 000012EA E8AA19              <1>         call htoa                          ; fill in the key code string
  2334 000012ED 81C70400            <1>         add di, 4
  2335                              <1> 
  2336 000012F1 8B36[254C]          <1>         mov si, [str_idx.key_count]
  2337 000012F5 E86F19              <1>         call strcpy
  2338                              <1> 
  2339 000012F8 59                  <1>         pop cx
  2340 000012F9 D1E9                <1>         shr cx, 1
  2341 000012FB 0FB6C1              <1>         movzx ax, cl
  2342 000012FE B102                <1>         mov cl, 2
  2343 00001300 E8BD18              <1>         call itoa                          ; fill in the key cound string
  2344                              <1> 
  2345 00001303 5E                  <1>         pop si
  2346                              <1> 
  2347 00001304 E8D419              <1> 	call count_lines
  2348                              <1> 
  2349 00001307 020E[B04B]          <1> 	add cl, [size.box_width]
  2350 0000130B 022E[B14B]          <1> 	add ch, [size.box_height]
  2351                              <1> 
  2352 0000130F 5E                  <1>         pop si
  2353 00001310 894C08              <1> 	mov [si + struc_window.win_size], cx
  2354 00001313 E81916              <1> 	call window_center_window
  2355 00001316 C3                  <1>         ret
  2356                              <1> 
  2357                              <1> 
  2358                              <1> ;=============================================================================
  2359                              <1> ;main_input_keystrokes ---- input a set of key strokes
  2360                              <1> ;input:
  2361                              <1> ;      cl = max key strokes number
  2362                              <1> ;      es:di -> the buffer
  2363                              <1> ;output:
  2364                              <1> ;      es:di -> the buffer filled by key strokes
  2365                              <1> ;      ch = number of key strokes that inputed
  2366                              <1> ;=============================================================================
  2367                              <1> main_input_keystrokes:
  2368 00001317 57                  <1>         push di
  2369                              <1> 
  2370 00001318 31C0                <1>         xor ax, ax
  2371 0000131A 893E[3F2D]          <1>         mov [main_tmp.keystroke_ptr], di
  2372 0000131E 880E[422D]          <1>         mov [main_tmp.keystroke_max], cl
  2373 00001322 A2[412D]            <1>         mov [main_tmp.keystroke_num], al
  2374 00001325 8905                <1>         mov [di], ax
  2375                              <1> 
  2376 00001327 A0[CF4B]            <1>         mov al, [color.input_box_msg]
  2377 0000132A 8B1E[CD4B]          <1>         mov bx, [color.input_box]
  2378 0000132E BA[114C]            <1>         mov dx, str_idx.input
  2379 00001331 BE[BE35]            <1>         mov si, main_tmp.dialog_buf
  2380 00001334 BF[432D]            <1>         mov di, main_tmp.ikbox
  2381                              <1> 
  2382 00001337 8824                <1>         mov [si], ah
  2383 00001339 E8590E              <1>         call msgbox_prepare
  2384 0000133C 89FE                <1>         mov si, di
  2385 0000133E E87AFF              <1>         call main_ikbox_prepare
  2386                              <1> 
  2387 00001341 E8D80D              <1>         call turnon_scrolllock
  2388 00001344 E81F15              <1>         call window_run
  2389 00001347 E8E10D              <1>         call turnoff_scrolllock
  2390                              <1> 
  2391 0000134A 8A2E[412D]          <1>         mov ch, [main_tmp.keystroke_num]
  2392 0000134E 5F                  <1>         pop di
  2393 0000134F C3                  <1>         ret
  2394                              <1> 
  2395                              <1> ;=============================================================================
  2396                              <1> ;main_show_record_info ---- show the information of the boot record
  2397                              <1> ;=============================================================================
  2398                              <1> main_show_record_info:
  2399 00001350 E89908              <1>         call main_get_focus_record_pointer
  2400 00001353 BF[BE35]            <1>         mov di, main_tmp.dialog_buf
  2401                              <1> 
  2402 00001356 E8F122              <1>         call get_record_schedule
  2403 00001359 52                  <1>         push dx
  2404 0000135A 53                  <1>         push bx
  2405 0000135B 50                  <1>         push ax
  2406                              <1> 
  2407 0000135C 66FF740E            <1>         push dword [si + struc_bootrecord.password]
  2408                              <1> 
  2409 00001360 8B1C                <1>         mov bx, [si + struc_bootrecord.flags]
  2410 00001362 8B4402              <1>         mov ax, [si + struc_bootrecord.drive_id]
  2411                              <1> 
  2412 00001365 89F2                <1>         mov dx, si
  2413 00001367 81C61600            <1>         add si, struc_bootrecord.name
  2414 0000136B 56                  <1>         push si                               ; save record name pointer
  2415 0000136C 52                  <1>         push dx                               ; save record pointer
  2416 0000136D 50                  <1>         push ax                               ; save drive_id and part_id
  2417                              <1> 
  2418                              <1> ;write drive id
  2419 0000136E 8B36[2B4C]          <1>         mov si, [str_idx.drive_id]
  2420 00001372 E8F218              <1>         call strcpy
  2421                              <1> 
  2422 00001375 F7C30800            <1> 	test bx, INFOFLAG_ISSPECIAL
  2423 00001379 7407                <1> 	jz .drvid_ok
  2424                              <1> 
  2425 0000137B B02D                <1> 	mov al, '-'
  2426 0000137D AA                  <1> 	stosb
  2427 0000137E AA                  <1> 	stosb
  2428 0000137F AA                  <1> 	stosb
  2429 00001380 EB05                <1> 	jmp short .write_partid
  2430                              <1> 
  2431                              <1> .drvid_ok:
  2432 00001382 88C2                <1> 	mov dl, al
  2433 00001384 E82C29              <1> 	call get_drvid_str
  2434                              <1> 
  2435                              <1> .write_partid:
  2436                              <1> ;write part id
  2437 00001387 8B36[2D4C]          <1>         mov si, [str_idx.part_id]
  2438 0000138B E8D918              <1>         call strcpy
  2439                              <1> 
  2440 0000138E 58                  <1>         pop ax                          ; ax = drive id, partition id
  2441 0000138F F7C30800            <1> 	test bx, INFOFLAG_ISSPECIAL
  2442 00001393 7406                <1> 	jz .partid_ok
  2443 00001395 B02D                <1> 	mov al, '-'
  2444 00001397 AA                  <1> 	stosb
  2445 00001398 AA                  <1> 	stosb
  2446 00001399 EB0B                <1> 	jmp short .write_rectype
  2447                              <1> 
  2448                              <1> .partid_ok:
  2449 0000139B 0FB6C4              <1>         movzx ax, ah
  2450 0000139E B90200              <1>         mov cx, 2
  2451 000013A1 E81C18              <1>         call itoa
  2452 000013A4 01CF                <1>         add di, cx
  2453                              <1> 
  2454                              <1> .write_rectype:
  2455                              <1> ;write record type
  2456 000013A6 8B36[2F4C]          <1>         mov si, [str_idx.record_type]
  2457 000013AA E8BA18              <1>         call strcpy
  2458                              <1> 
  2459 000013AD 89FE                <1>         mov si, di
  2460 000013AF E85C18              <1>         call strlen
  2461                              <1> 
  2462 000013B2 89C8                <1>         mov ax, cx
  2463 000013B4 5E                  <1>         pop si                          ; si -> record pointer
  2464 000013B5 E86C20              <1>         call get_record_typestr
  2465 000013B8 89FE                <1>         mov si, di
  2466 000013BA E85118              <1>         call strlen
  2467 000013BD 29C1                <1>         sub cx, ax
  2468 000013BF 01CF                <1>         add di, cx
  2469                              <1> 
  2470                              <1> ;write record name 
  2471 000013C1 8B36[314C]          <1>         mov si, [str_idx.record_name]
  2472 000013C5 E89F18              <1>         call strcpy
  2473 000013C8 5E                  <1>         pop si
  2474 000013C9 E89B18              <1>         call strcpy
  2475                              <1> 
  2476                              <1> ;write flags
  2477 000013CC B90700              <1> 	mov cx, 7
  2478 000013CF 89DA                <1> 	mov dx, bx
  2479 000013D1 31DB                <1> 	xor bx, bx
  2480                              <1> .loop_copy_flags:
  2481 000013D3 8BB7[334C]          <1> 	mov si, [str_idx.auto_active + bx]
  2482 000013D7 8B87[3714]          <1> 	mov ax, [.flag_val + bx]
  2483 000013DB E84400              <1> 	call .copy_flag_stat
  2484 000013DE 43                  <1> 	inc bx
  2485 000013DF 43                  <1> 	inc bx
  2486 000013E0 E2F1                <1> 	loop .loop_copy_flags
  2487                              <1> 
  2488                              <1> ;write password flag
  2489 000013E2 8B36[414C]          <1>         mov si, [str_idx.password]
  2490 000013E6 E87E18              <1>         call strcpy
  2491 000013E9 6659                <1>         pop ecx
  2492 000013EB 6609C9              <1>         or ecx, ecx
  2493 000013EE 7406                <1>         jz .no_pswd
  2494 000013F0 8B36[454C]          <1>         mov si, [str_idx.yes]
  2495 000013F4 EB04                <1>         jmp short .pswd
  2496                              <1> .no_pswd:
  2497 000013F6 8B36[474C]          <1>         mov si, [str_idx.no]
  2498                              <1> .pswd:
  2499 000013FA E86A18              <1>         call strcpy
  2500                              <1> 
  2501                              <1> ;write schedule time
  2502 000013FD 8B36[434C]          <1>         mov si, [str_idx.schedule]
  2503 00001401 E86318              <1>         call strcpy
  2504 00001404 89D1                <1>         mov cx, dx
  2505                              <1> 
  2506 00001406 58                  <1>         pop ax
  2507 00001407 5B                  <1>         pop bx
  2508 00001408 5A                  <1>         pop dx
  2509                              <1> 
  2510 00001409 F7C10080            <1>         test cx, INFOFLAG_SCHEDULED
  2511 0000140D 7405                <1>         jz .no_sched
  2512 0000140F E86222              <1>         call schedule_to_str
  2513 00001412 EB07                <1>         jmp short .show_info
  2514                              <1> 
  2515                              <1> .no_sched:
  2516 00001414 8B36[474C]          <1>         mov si, [str_idx.no]
  2517 00001418 E84C18              <1>         call strcpy
  2518                              <1> 
  2519                              <1> .show_info:
  2520 0000141B BE[BE35]            <1>         mov si, main_tmp.dialog_buf
  2521 0000141E E8DB0D              <1>         call info_box
  2522                              <1> .end:
  2523 00001421 C3                  <1>         ret
  2524                              <1> 
  2525                              <1> ; si -> flag string
  2526                              <1> ; ax = flag
  2527                              <1> .copy_flag_stat:
  2528 00001422 E84218              <1> 	call strcpy
  2529 00001425 85C2                <1>         test dx, ax
  2530 00001427 7406                <1>         jz .no_this_flag
  2531 00001429 8B36[454C]          <1>         mov si, [str_idx.yes] 
  2532 0000142D EB04                <1>         jmp short .copy_flag
  2533                              <1> .no_this_flag:
  2534 0000142F 8B36[474C]          <1>         mov si, [str_idx.no]
  2535                              <1> .copy_flag:
  2536 00001433 E83118              <1>         call strcpy
  2537 00001436 C3                  <1> 	ret
  2538                              <1> 
  2539 00001437 001000080004000200- <1> .flag_val	dw INFOFLAG_AUTOACTIVE, INFOFLAG_ACTIVE, INFOFLAG_AUTOHIDE, INFOFLAG_HIDDEN, INFOFLAG_SWAPDRVID
  2540 00001440 20                  <1>
  2541 00001441 00010040            <1> 		dw INFOFLAG_LOGICAL, INFOFLAG_HAVEKEYS
  2542                              <1> 
  2543                              <1>        
  2544                              <1> ;=============================================================================
  2545                              <1> ;main_power_off ---- turn of the power
  2546                              <1> ;=============================================================================
  2547                              <1> main_power_off:
  2548 00001445 E9C618              <1>         jmp power_off
  2549                              <1> 
  2550                              <1> 
  2551                              <1> ;=============================================================================
  2552                              <1> ;main_change_bootmenu_style ---- change the boot menu's draw style
  2553                              <1> ;=============================================================================
  2554                              <1> main_change_bootmenu_style:
  2555 00001448 A0[3400]            <1> 	mov al, [ADDR_SBMK_BOOTMENU_STYLE]
  2556 0000144B FEC0                <1> 	inc al
  2557 0000144D 3C04                <1> 	cmp al, 4
  2558 0000144F 7202                <1> 	jb .ok
  2559 00001451 30C0                <1> 	xor al, al
  2560                              <1> 
  2561                              <1> .ok:
  2562 00001453 A2[3400]            <1> 	mov [ADDR_SBMK_BOOTMENU_STYLE], al
  2563 00001456 E81903              <1> 	call main_init_boot_menu
  2564                              <1> 
  2565 00001459 FE06[352D]          <1>         inc byte [main_tmp.change_occured]
  2566 0000145D C3                  <1>         ret
  2567                              <1> 
  2568                              <1> ;=============================================================================
  2569                              <1> ;main_toggle_rem_last ---- toggle the remember last switch.
  2570                              <1> ;=============================================================================
  2571                              <1> main_toggle_rem_last:
  2572 0000145E 8036[2C00]10        <1>         xor byte [ADDR_SBMK_FLAGS], KNLFLAG_REMLAST
  2573 00001463 FE06[352D]          <1>         inc byte [main_tmp.change_occured]
  2574 00001467 C3                  <1>         ret
  2575                              <1> 
  2576                              <1> 
  2577                              <1> ;=============================================================================
  2578                              <1> ;main_boot_prev_in_menu ---- boot previous MBR in command menu
  2579                              <1> ;=============================================================================
  2580                              <1> main_boot_prev_in_menu:
  2581 00001468 E8AC24              <1> 	call check_prev_mbr
  2582 0000146B 7208                <1> 	jc .end
  2583                              <1> 
  2584 0000146D E8C206              <1>         call main_confirm_root_passwd
  2585 00001470 7203                <1>         jc .end
  2586                              <1> 
  2587 00001472 E85509              <1> 	call main_boot_prev_mbr
  2588                              <1> .end:
  2589 00001475 C3                  <1> 	ret
  2590                              <1> 
  2591                              <1> ;=============================================================================
  2592                              <1> ;main_install_sbm
  2593                              <1> ;=============================================================================
  2594                              <1> main_install_sbm:
  2595                              <1> 
  2596                              <1> %ifndef EMULATE_PROG
  2597 00001476 803E[C049]00        <1>         cmp byte [GOOD_RECORD_NUMBER], 0
  2598 0000147B 744B                <1>         je .end
  2599                              <1> 
  2600 0000147D E86C07              <1>         call main_get_focus_record_pointer
  2601 00001480 8B04                <1> 	mov ax, [si + struc_bootrecord.flags]
  2602 00001482 A98000              <1>         test ax , INFOFLAG_ISDRIVER
  2603 00001485 7441                <1>         jz .end
  2604 00001487 A91000              <1>         test ax, DRVFLAG_ISCDROM
  2605 0000148A 753C                <1> 	jnz .end
  2606                              <1> 
  2607 0000148C E8A306              <1>         call main_confirm_root_passwd
  2608 0000148F 7237                <1>         jc .end
  2609                              <1> 
  2610 00001491 8A5402              <1>         mov dl, [si + struc_bootrecord.drive_id]
  2611 00001494 52                  <1> 	push dx
  2612                              <1> 
  2613 00001495 BF[BE35]            <1>         mov di, main_tmp.dialog_buf
  2614 00001498 8B36[654C]          <1>         mov si, [str_idx.inst_confirm]
  2615 0000149C 57                  <1>         push di
  2616 0000149D E8C717              <1>         call strcpy
  2617 000014A0 E81028              <1> 	call get_drvid_str
  2618                              <1> 
  2619 000014A3 B03F                <1>         mov al, '?'
  2620 000014A5 AA                  <1>         stosb
  2621 000014A6 B00D                <1>         mov al, 0x0d
  2622 000014A8 AA                  <1>         stosb
  2623                              <1> 
  2624 000014A9 8B36[714C]          <1>         mov si, [str_idx.confirm]
  2625 000014AD E8B717              <1>         call strcpy
  2626 000014B0 5E                  <1>         pop si
  2627 000014B1 E8480D              <1>         call info_box
  2628 000014B4 5A                  <1> 	pop dx
  2629                              <1> 
  2630 000014B5 3A06[A64B]          <1>         cmp al, [yes_key_lower]
  2631 000014B9 740E                <1>         je .go_inst
  2632 000014BB 3A06[A74B]          <1>         cmp al, [yes_key_upper]
  2633 000014BF 7408                <1>         je .go_inst
  2634                              <1> 
  2635 000014C1 8B36[694C]          <1>         mov si, [str_idx.inst_abort]
  2636 000014C5 E8220D              <1>         call error_box
  2637                              <1> .end:
  2638 000014C8 C3                  <1>         ret
  2639                              <1> 
  2640                              <1> .go_inst:
  2641 000014C9 FC                  <1> 	cld
  2642                              <1> ;read mbr into buf1
  2643 000014CA 6631DB              <1>         xor ebx, ebx
  2644 000014CD B80102              <1>         mov ax, (INT13H_READ << 8) | 0x01
  2645 000014D0 BF[741A]            <1>         mov di, knl_tmp.disk_buf1
  2646 000014D3 E89427              <1>         call disk_access
  2647 000014D6 0F827C00            <1>         jmpc .disk_error
  2648                              <1> 
  2649                              <1> ;backup old previous mbr into buf1, put new mbr into previous_mbr
  2650 000014DA BE[FE09]            <1> 	mov si, ADDR_SBMK_PREVIOUS_MBR
  2651 000014DD B90002              <1> 	mov cx, SECTOR_SIZE
  2652 000014E0 E87700              <1> 	call main_xchg_buffer
  2653                              <1> 
  2654                              <1> ;backup sbmk header data into buf2
  2655 000014E3 31F6                <1>         xor si, si
  2656 000014E5 BF[7422]            <1> 	mov di, knl_tmp.disk_buf2
  2657 000014E8 B9[4000]            <1> 	mov cx, end_of_sbmk_header
  2658 000014EB F3A4                <1> 	rep movsb
  2659                              <1> 
  2660                              <1> ;set some variate
  2661 000014ED 6631C0              <1>         xor eax, eax
  2662 000014F0 FEC0                <1> 	inc al
  2663 000014F2 8A0E[0F00]          <1> 	mov cl, [ADDR_SBMK_SECTORS]
  2664                              <1> 
  2665 000014F6 8816[1000]          <1> 	mov [ADDR_SBMK_DRVID], dl
  2666 000014FA 880E[1100]          <1> 	mov [ADDR_SBMK_BLOCK_MAP], cl
  2667 000014FE 66A3[1200]          <1> 	mov [ADDR_SBMK_BLOCK_MAP+1], eax    ; kernel address = 1
  2668 00001502 8826[1600]          <1> 	mov [ADDR_SBMK_BLOCK_MAP+SIZE_OF_STRUC_BLOCK_MAP], ah
  2669                              <1>                                               ; only one block of kernel
  2670 00001506 8826[0E00]          <1> 	mov [ADDR_SBMK_CHECKSUM], ah        ; set checksum to zero
  2671                              <1> 
  2672 0000150A 880E[8608]          <1>         mov [ADDR_SBMK_SBML_CODES + struc_sbml_header.block_map], cl
  2673 0000150E 66A3[8708]          <1>         mov [ADDR_SBMK_SBML_CODES + struc_sbml_header.block_map+1], eax
  2674 00001512 8826[8B08]          <1> 	mov [ADDR_SBMK_SBML_CODES + struc_sbml_header.block_map+SIZE_OF_STRUC_BLOCK_MAP], ah
  2675                              <1> 
  2676                              <1> ;write sbmk to disk
  2677 00001516 E8F607              <1>         call main_save_boot_manager
  2678 00001519 9C                  <1> 	pushf
  2679                              <1> 
  2680                              <1> ;restore sbmk header data
  2681 0000151A 31FF                <1> 	xor di, di
  2682 0000151C BE[7422]            <1> 	mov si, knl_tmp.disk_buf2
  2683 0000151F B9[4000]            <1> 	mov cx, end_of_sbmk_header
  2684 00001522 F3A4                <1> 	rep movsb
  2685                              <1> 	
  2686                              <1> ;restore previous mbr
  2687 00001524 BE[FE09]            <1> 	mov si, ADDR_SBMK_PREVIOUS_MBR
  2688 00001527 BF[741A]            <1> 	mov di, knl_tmp.disk_buf1
  2689                              <1> 
  2690 0000152A B90002              <1> 	mov cx, SECTOR_SIZE
  2691 0000152D E82A00              <1> 	call main_xchg_buffer
  2692                              <1> 
  2693 00001530 9D                  <1> 	popf
  2694 00001531 7223                <1>         jc .disk_error
  2695                              <1> 
  2696                              <1> ;copy sbml to disk_buf1
  2697 00001533 57                  <1> 	push di
  2698 00001534 BE[4008]            <1> 	mov si, ADDR_SBMK_SBML_CODES
  2699 00001537 B9BE01              <1> 	mov cx, SIZE_OF_MBR
  2700 0000153A F3A4                <1> 	rep movsb
  2701 0000153C 5F                  <1> 	pop di
  2702 0000153D C785FE0155AA        <1> 	mov word [di + BR_FLAG_OFF], BR_GOOD_FLAG
  2703                              <1> 
  2704                              <1> ;write loader to disk
  2705 00001543 B80103              <1>         mov ax, (INT13H_WRITE << 8) | 0x01
  2706 00001546 6631DB              <1> 	xor ebx,ebx
  2707 00001549 E81E27              <1>         call disk_access
  2708 0000154C 7208                <1>         jc .disk_error
  2709                              <1> 
  2710                              <1> ;install ok
  2711 0000154E 8B36[674C]          <1>         mov si, [str_idx.inst_ok]
  2712 00001552 E8A70C              <1>         call info_box
  2713 00001555 C3                  <1>         ret
  2714                              <1> 
  2715                              <1> .disk_error:
  2716 00001556 E84406              <1>         call main_show_disk_error
  2717                              <1> 
  2718                              <1> %endif
  2719 00001559 C3                  <1>         ret
  2720                              <1> 
  2721                              <1> ; cx = count
  2722                              <1> ; si -> source
  2723                              <1> ; di -> dest
  2724                              <1> main_xchg_buffer:
  2725 0000155A 60                  <1> 	pusha
  2726                              <1> .xchg:
  2727 0000155B 8A04                <1> 	mov al, [si]
  2728 0000155D 8605                <1> 	xchg al, [di]
  2729 0000155F 8804                <1> 	mov [si], al
  2730 00001561 46                  <1> 	inc si
  2731 00001562 47                  <1> 	inc di
  2732 00001563 E2F6                <1> 	loop .xchg
  2733 00001565 61                  <1> 	popa
  2734 00001566 C3                  <1> 	ret
  2735                              <1> 
  2736                              <1> ;=============================================================================
  2737                              <1> ; main_uninstall_sbm
  2738                              <1> ;=============================================================================
  2739                              <1> main_uninstall_sbm:
  2740                              <1> %ifndef EMULATE_PROG
  2741                              <1> 
  2742 00001567 BF[BE35]            <1>         mov di, main_tmp.dialog_buf
  2743 0000156A 8B36[6B4C]          <1>         mov si, [str_idx.uninst_confirm]
  2744 0000156E 57                  <1>         push di
  2745 0000156F E8F516              <1>         call strcpy
  2746 00001572 8B36[714C]          <1>         mov si, [str_idx.confirm]
  2747 00001576 E8EE16              <1>         call strcpy
  2748 00001579 5E                  <1>         pop si
  2749 0000157A E87F0C              <1>         call info_box
  2750                              <1> 
  2751 0000157D 3A06[A64B]          <1>         cmp al, [yes_key_lower]
  2752 00001581 740E                <1>         je .go_uninst
  2753 00001583 3A06[A74B]          <1>         cmp al, [yes_key_upper]
  2754 00001587 7408                <1>         je .go_uninst
  2755                              <1> 
  2756 00001589 8B36[6F4C]          <1>         mov si, [str_idx.uninst_abort]
  2757 0000158D E85A0C              <1>         call error_box
  2758                              <1> .end:
  2759 00001590 C3                  <1>         ret
  2760                              <1> 
  2761                              <1> .go_uninst:
  2762                              <1>         
  2763                              <1> ;read mbr into buf1
  2764 00001591 8A16[1000]          <1>         mov dl, [ADDR_SBMK_DRVID]
  2765 00001595 6631DB              <1>         xor ebx, ebx
  2766 00001598 B80102              <1>         mov ax, (INT13H_READ << 8) | 0x01
  2767 0000159B BF[741A]            <1>         mov di, knl_tmp.disk_buf1
  2768 0000159E E8C926              <1>         call disk_access
  2769 000015A1 723B                <1>         jc .disk_error
  2770                              <1> 
  2771                              <1> ;check if sbm is present
  2772 000015A3 66817D4053424D4C    <1>         cmp dword [di + struc_sbml_header.magic], SBML_MAGIC
  2773 000015AB 7535                <1>         jne .no_sbml
  2774                              <1> 
  2775 000015AD 817D440103          <1>         cmp word [di + struc_sbml_header.version], SBML_VERSION
  2776 000015B2 752E                <1>         jne .no_sbml
  2777                              <1> 
  2778                              <1> ;restore previous mbr
  2779 000015B4 57                  <1>         push di
  2780 000015B5 BE[FE09]            <1>         mov si, ADDR_SBMK_PREVIOUS_MBR
  2781 000015B8 B9BE01              <1>         mov cx, SIZE_OF_MBR
  2782 000015BB FC                  <1>         cld
  2783 000015BC F3A4                <1>         rep movsb
  2784 000015BE 5F                  <1>         pop di
  2785 000015BF C785FE0155AA        <1>         mov word [di + BR_FLAG_OFF], BR_GOOD_FLAG
  2786                              <1> 
  2787                              <1> ;write mbr back to disk
  2788 000015C5 6631DB              <1>         xor ebx, ebx
  2789 000015C8 B80103              <1>         mov ax, (INT13H_WRITE << 8) | 0x01
  2790 000015CB BF[741A]            <1>         mov di, knl_tmp.disk_buf1
  2791 000015CE E89926              <1>         call disk_access
  2792 000015D1 720B                <1>         jc .disk_error
  2793 000015D3 8B36[6D4C]          <1>         mov si, [str_idx.uninst_ok]
  2794 000015D7 E8220C              <1>         call info_box
  2795 000015DA E85718              <1>         call reboot
  2796 000015DD C3                  <1>         ret
  2797                              <1> 
  2798                              <1> .disk_error:
  2799 000015DE E8BC05              <1>         call main_show_disk_error
  2800 000015E1 C3                  <1>         ret
  2801                              <1> 
  2802                              <1> .no_sbml:
  2803 000015E2 8B36[734C]          <1>         mov si, [str_idx.no_sbml]
  2804 000015E6 E8010C              <1>         call error_box
  2805                              <1> %endif
  2806 000015E9 C3                  <1>         ret
  2807                              <1> 
  2808                              <1> ;=============================================================================
  2809                              <1> ; main_toggle_int13ext
  2810                              <1> ;=============================================================================
  2811                              <1> main_toggle_int13ext:
  2812 000015EA A0[2C00]            <1>         mov al, [ADDR_SBMK_FLAGS]
  2813 000015ED 3404                <1>         xor al, KNLFLAG_NOINT13EXT
  2814 000015EF A2[2C00]            <1>         mov [ADDR_SBMK_FLAGS], al
  2815                              <1> 
  2816 000015F2 A804                <1>         test al, KNLFLAG_NOINT13EXT
  2817 000015F4 7507                <1>         jnz .no_int13ext
  2818 000015F6 C606[EA3C]01        <1>         mov byte [use_int13_ext], 1
  2819 000015FB EB05                <1>         jmp short .endok
  2820                              <1> 
  2821                              <1> .no_int13ext:
  2822 000015FD C606[EA3C]00        <1>         mov byte [use_int13_ext], 0
  2823                              <1> .endok:
  2824 00001602 FE06[352D]          <1>         inc byte [main_tmp.change_occured]
  2825 00001606 C3                  <1>         ret
  2826                              <1> 
  2827                              <1> ;=============================================================================
  2828                              <1> ; main_set_cdrom_ioports
  2829                              <1> ;=============================================================================
  2830                              <1> 
  2831                              <1> main_set_cdrom_ioports:
  2832                              <1> %ifndef DISABLE_CDBOOT
  2833 00001607 F606[2C00]08        <1> 	test byte [ADDR_SBMK_FLAGS], KNLFLAG_NOCDROM
  2834 0000160C 7570                <1> 	jnz .end
  2835                              <1> 
  2836 0000160E E82105              <1>         call main_confirm_root_passwd
  2837 00001611 726B                <1>         jc .end
  2838                              <1> 
  2839 00001613 8D3E[BE35]          <1>         lea di, [main_tmp.dialog_buf]
  2840 00001617 57                  <1> 	push di
  2841 00001618 C60500              <1> 	mov byte [di], 0 
  2842 0000161B A1[3600]            <1> 	mov ax, [ADDR_SBMK_CDROM_IOPORTS]
  2843 0000161E 09C0                <1> 	or ax, ax
  2844 00001620 7412                <1> 	jz .no_ports
  2845 00001622 B104                <1> 	mov cl, 4
  2846 00001624 E87016              <1> 	call htoa
  2847 00001627 81C70400            <1> 	add di, 4
  2848 0000162B B02C                <1> 	mov al, ','
  2849 0000162D AA                  <1> 	stosb
  2850 0000162E A1[3800]            <1> 	mov ax, [ADDR_SBMK_CDROM_IOPORTS+2]
  2851 00001631 E86316              <1> 	call htoa
  2852                              <1> .no_ports:
  2853 00001634 5F                  <1> 	pop di
  2854                              <1> 
  2855 00001635 0FB606[CF4B]        <1>         movzx ax, [color.input_box_msg]
  2856 0000163A 8B1E[CD4B]          <1>         mov bx, [color.input_box]
  2857 0000163E B90909              <1>         mov cx, 0x0909
  2858 00001641 31D2                <1>         xor dx, dx
  2859 00001643 8B36[274C]          <1>         mov si, [str_idx.io_port]
  2860                              <1> 	
  2861 00001647 E8840D              <1>         call input_box
  2862 0000164A 7232                <1>         jc .end
  2863                              <1> 
  2864 0000164C 89FE                <1>         mov si, di
  2865 0000164E E86116              <1> 	call atoh
  2866 00001651 803C2C              <1> 	cmp byte [si], ','
  2867 00001654 751E                <1> 	jne .invalid
  2868 00001656 89C3                <1> 	mov bx, ax
  2869 00001658 46                  <1> 	inc si
  2870 00001659 E85616              <1> 	call atoh
  2871 0000165C 803C00              <1> 	cmp byte [si], 0
  2872 0000165F 7513                <1> 	jne .invalid
  2873                              <1> 
  2874 00001661 89C1                <1> 	mov cx, ax
  2875 00001663 891E[3600]          <1> 	mov [ADDR_SBMK_CDROM_IOPORTS], bx
  2876 00001667 890E[3800]          <1> 	mov [ADDR_SBMK_CDROM_IOPORTS+2], cx
  2877                              <1> 
  2878 0000166B FE06[352D]          <1>         inc byte [main_tmp.change_occured]               ; some changes occured.
  2879 0000166F E8EA26              <1> 	call set_io_ports
  2880 00001672 EB0A                <1> 	jmp short .end
  2881                              <1> 
  2882                              <1> .invalid:
  2883 00001674 8B36[754C]          <1> 	mov si, [str_idx.invalid_ioports]
  2884 00001678 E86F0B              <1> 	call error_box
  2885 0000167B E90000              <1> 	jmp .end
  2886                              <1> .end:
  2887                              <1> %endif
  2888 0000167E C3                  <1>         ret
  2889                              <1> 
  2890                              <1> ;=============================================================================
  2891                              <1> ;main_set_y2k_year
  2892                              <1> ;=============================================================================
  2893                              <1> 
  2894                              <1> main_set_y2k_year:
  2895                              <1> %ifdef Y2K_BUGFIX
  2896 0000167F 8D3E[BE35]          <1>         lea di, [main_tmp.dialog_buf]
  2897 00001683 C60500              <1> 	mov byte [di], 0 
  2898 00001686 B104                <1> 	mov cl,4
  2899 00001688 A1[3A00]            <1> 	mov ax,[ADDR_SBMK_Y2K_LAST_YEAR]
  2900 0000168B 09C0                <1> 	or ax,ax
  2901 0000168D 7403                <1> 	jz .nofix
  2902 0000168F E87D17              <1> 	call bcd_to_str
  2903                              <1> .nofix:
  2904 00001692 0FB606[CF4B]        <1>         movzx ax, [color.input_box_msg]
  2905 00001697 8B1E[CD4B]          <1>         mov bx, [color.input_box]
  2906 0000169B 8B36[294C]          <1>         mov si, [str_idx.year]
  2907 0000169F 88CD                <1>         mov ch, cl
  2908 000016A1 31D2                <1> 	xor dx, dx
  2909                              <1> 
  2910 000016A3 E8280D              <1>         call input_box
  2911 000016A6 7227                <1>         jc .end
  2912                              <1> 
  2913 000016A8 31DB                <1> 	xor bx,bx
  2914 000016AA 08ED                <1> 	or ch,ch
  2915 000016AC 7419                <1> 	jz .set
  2916                              <1> 
  2917 000016AE 89FE                <1>         mov si,di
  2918                              <1> .loop:
  2919 000016B0 D3E3                <1> 	shl bx,cl
  2920 000016B2 AC                  <1> 	lodsb
  2921 000016B3 2C30                <1> 	sub al,'0'
  2922 000016B5 08C3                <1> 	or bl,al
  2923 000016B7 FECD                <1> 	dec ch
  2924 000016B9 75F5                <1> 	jnz .loop
  2925                              <1> 
  2926 000016BB B404                <1> 	mov ah,4
  2927 000016BD CD1A                <1> 	int 0x1a
  2928 000016BF 720E                <1> 	jc .end
  2929                              <1> 
  2930 000016C1 89D9                <1> 	mov cx,bx
  2931 000016C3 B405                <1> 	mov ah,5
  2932 000016C5 CD1A                <1> 	int 0x1a
  2933                              <1> .set:
  2934 000016C7 891E[3A00]          <1> 	mov [ADDR_SBMK_Y2K_LAST_YEAR],bx
  2935 000016CB FE06[352D]          <1>         inc byte [main_tmp.change_occured]               ; some changes occured.
  2936                              <1> .end:
  2937                              <1> %endif
  2938 000016CF C3                  <1>         ret
  2939                              <1> 
  2940                              <1> %endif  ; END OF MAIN
  2941                                  %include "main-utils.asm"
  2942                              <1> ; asmsyntax=nasm
  2943                              <1> ;
  2944                              <1> ; main-utils.asm
  2945                              <1> ;
  2946                              <1> ; utility functions for main program
  2947                              <1> ;
  2948                              <1> ; Copyright (C) 2000, Suzhe. See file COPYING for details.
  2949                              <1> ;
  2950                              <1> 
  2951                              <1> %ifdef MAIN
  2952                              <1> 
  2953                              <1> 
  2954                              <1> ;=============================================================================
  2955                              <1> ; >>>>>>>>>>>>>>>>>>>>>>>>> Initialization Functions <<<<<<<<<<<<<<<<<<<<<<<<<
  2956                              <1> ;=============================================================================
  2957                              <1> 
  2958                              <1> ;=============================================================================
  2959                              <1> ; main_init_theme ---- initialize the theme data.
  2960                              <1> ;=============================================================================
  2961                              <1> main_init_theme:
  2962 000016D0 8B1E[E84B]          <1>         mov bx, [icon.brand]
  2963 000016D4 09DB                <1>         or bx, bx
  2964 000016D6 7406                <1>         jz .adjust_bkgnd                            ; no brand icon
  2965 000016D8 8106[E84B][924B]    <1>         add word [icon.brand], theme_start          ;
  2966                              <1> .adjust_bkgnd:
  2967 000016DE 8B1E[EC4B]          <1>         mov bx, [icon.background]
  2968 000016E2 09DB                <1>         or bx, bx
  2969 000016E4 7406                <1>         jz .adjust_font                             ; no background icon
  2970 000016E6 8106[EC4B][924B]    <1>         add word [icon.background], theme_start
  2971                              <1> .adjust_font:
  2972 000016EC 8B1E[F04B]          <1>         mov bx, [font.data]
  2973 000016F0 09DB                <1>         or bx, bx
  2974 000016F2 7406                <1>         jz .adjust_keymap
  2975 000016F4 8106[F04B][924B]    <1>         add word [font.data], theme_start
  2976                              <1> .adjust_keymap:
  2977 000016FA 8B1E[FD4B]          <1>         mov bx, [keymap.data]
  2978 000016FE 09DB                <1>         or bx, bx
  2979 00001700 7406                <1>         jz .adjust_str
  2980 00001702 8106[FD4B][924B]    <1>         add word [keymap.data], theme_start
  2981                              <1> 
  2982                              <1> .adjust_str:
  2983 00001708 8D36[FF4B]          <1>         lea si, [str_idx]
  2984 0000170C B97800              <1>         mov cx, (end_of_str_idx - str_idx)/2
  2985                              <1>         
  2986                              <1> .loop_adjust:
  2987 0000170F 8B1C                <1>         mov bx, [si]
  2988 00001711 81C3[924B]          <1>         add bx, theme_start
  2989 00001715 891C                <1>         mov [si], bx
  2990 00001717 81C60200            <1>         add si, 2
  2991 0000171B E2F2                <1>         loop .loop_adjust
  2992                              <1> 
  2993 0000171D B010                <1>         mov al, 0x10
  2994 0000171F 2006[A34B]          <1>         and [keyboard_type], al
  2995                              <1> 
  2996 00001723 C3                  <1>         ret
  2997                              <1>         
  2998                              <1> ;=============================================================================
  2999                              <1> ; main_init_all_menus ---- initialize the menus
  3000                              <1> ;=============================================================================
  3001                              <1> main_init_all_menus:
  3002 00001724 BE[BD4B]            <1>         mov si, color.cmd_menu
  3003                              <1> ;initialize main menu
  3004 00001727 BF[C549]            <1>         mov di, main_windows_data.main_menu
  3005 0000172A E82800              <1>         call main_init_menu
  3006 0000172D A1[000C]            <1> 	mov ax, [ADDR_SBMK_MAIN_MENU_POS]
  3007 00001730 A3[CB49]            <1> 	mov [main_windows_data.main_menu + struc_window.win_pos], ax
  3008                              <1> ;initialize record menu
  3009 00001733 BF[F049]            <1>         mov di, main_windows_data.record_menu
  3010 00001736 E81C00              <1>         call main_init_menu
  3011 00001739 A1[020C]            <1> 	mov ax, [ADDR_SBMK_RECORD_MENU_POS]
  3012 0000173C A3[F649]            <1> 	mov [main_windows_data.record_menu + struc_window.win_pos], ax
  3013                              <1> ;initialize system menu
  3014 0000173F BF[1B4A]            <1>         mov di, main_windows_data.sys_menu
  3015 00001742 E81000              <1>         call main_init_menu
  3016 00001745 A1[040C]            <1> 	mov ax, [ADDR_SBMK_SYS_MENU_POS]
  3017 00001748 A3[214A]            <1> 	mov [main_windows_data.sys_menu + struc_window.win_pos], ax
  3018                              <1> ;initialize boot menu
  3019 0000174B A1[FE0B]            <1> 	mov ax, [ADDR_SBMK_BOOT_MENU_POS]
  3020 0000174E A3[A049]            <1> 	mov [main_windows_data.boot_menu + struc_window.win_pos], ax
  3021 00001751 E81E00              <1>         call main_init_boot_menu
  3022 00001754 C3                  <1>         ret
  3023                              <1> 
  3024                              <1> ;=============================================================================
  3025                              <1> ; main_init_menu
  3026                              <1> ;input:
  3027                              <1> ;       ds:si -> colors
  3028                              <1> ;       ds:di -> struc_menu_box
  3029                              <1> ;=============================================================================
  3030                              <1> main_init_menu:
  3031 00001755 56                  <1>         push si
  3032 00001756 FC                  <1>         cld
  3033 00001757 AD                  <1>         lodsw
  3034 00001758 894504              <1>         mov [di + struc_window.win_attr], ax
  3035 0000175B AC                  <1>         lodsb
  3036 0000175C 88451C              <1>         mov [di + struc_menu_box.menu_header_attr], al
  3037 0000175F AD                  <1>         lodsw
  3038 00001760 89451D              <1>         mov [di + struc_menu_box.menu_norm_attr], ax
  3039 00001763 AD                  <1>         lodsw
  3040 00001764 89451F              <1>         mov [di + struc_menu_box.menu_focus_attr], ax
  3041 00001767 AC                  <1>         lodsb
  3042 00001768 884525              <1>         mov [di + struc_menu_box.scrollbar_attr], al
  3043 0000176B 89FE                <1>         mov si, di
  3044 0000176D E8C70C              <1>         call menubox_adjust_geometry
  3045 00001770 5E                  <1>         pop si
  3046 00001771 C3                  <1>         ret
  3047                              <1> 
  3048                              <1> ;=============================================================================
  3049                              <1> ; main_init_boot_menu
  3050                              <1> ;=============================================================================
  3051                              <1> main_init_boot_menu:
  3052 00001772 60                  <1>         pusha
  3053                              <1> ;initialize boot menu
  3054 00001773 BF[9A49]            <1>         mov di, main_windows_data.boot_menu
  3055 00001776 A0[B24B]            <1>         mov al, [size.boot_menu_win_height]
  3056 00001779 884509              <1>         mov [di + struc_window.win_size + 1], al        ; set boot menu height
  3057                              <1> 
  3058                              <1> ;set boot menu header
  3059 0000177C 0FB606[3400]        <1>         movzx ax, byte [ADDR_SBMK_BOOTMENU_STYLE]
  3060 00001781 BB[014C]            <1>         mov bx, str_idx.boot_menu_header
  3061 00001784 3C03                <1>         cmp al, 3
  3062 00001786 7602                <1>         jbe .bmstyle_ok
  3063 00001788 30C0                <1>         xor al, al
  3064                              <1> 
  3065                              <1> .bmstyle_ok:
  3066 0000178A D0E0                <1>         shl al, 1
  3067 0000178C 01C3                <1>         add bx, ax
  3068 0000178E 895D1A              <1>         mov [di + struc_menu_box.menu_header], bx
  3069                              <1> 
  3070                              <1> ;init the color and geometry of boot menu
  3071 00001791 BE[B54B]            <1>         mov si, color.boot_menu
  3072 00001794 E8BEFF              <1>         call main_init_menu
  3073                              <1> 
  3074                              <1> ; set position of boot menu window 
  3075                              <1> 
  3076 00001797 8B4506              <1>         mov ax, [di + struc_window.win_pos]
  3077 0000179A 88C3                <1>         mov bl, al
  3078                              <1> 
  3079 0000179C 025D08              <1>         add bl, [di + struc_window.win_size]
  3080 0000179F 80C302              <1>         add bl, 2
  3081 000017A2 3A1E[ED2A]          <1>         cmp bl, [ui_screen_width]
  3082 000017A6 7208                <1>         jb .bmpos_ok
  3083                              <1> 
  3084 000017A8 A0[ED2A]            <1>         mov al, [ui_screen_width]
  3085 000017AB 2A4508              <1>         sub al, [di + struc_window.win_size]
  3086 000017AE 2C02                <1>         sub al, 2
  3087                              <1> 
  3088                              <1> .bmpos_ok:
  3089 000017B0 894506              <1>         mov [di + struc_window.win_pos], ax
  3090 000017B3 61                  <1>         popa
  3091 000017B4 C3                  <1>         ret
  3092                              <1> 
  3093                              <1> ;=============================================================================
  3094                              <1> ;main_init_video ---- init the video mode
  3095                              <1> ;input:
  3096                              <1> ;      none
  3097                              <1> ;output:
  3098                              <1> ;      none
  3099                              <1> ;=============================================================================
  3100                              <1> main_init_video:
  3101 000017B5 60                  <1> 	pusha
  3102 000017B6 A0[A24B]            <1>         mov al, [video_mode]
  3103 000017B9 B308                <1>         mov bl, 8
  3104 000017BB 8B2E[F04B]          <1>         mov bp, [font.data]
  3105 000017BF 8B0E[EE4B]          <1>         mov cx, [font.number]
  3106                              <1>         
  3107 000017C3 E83508              <1>         call set_video_mode
  3108 000017C6 61                  <1> 	popa
  3109 000017C7 C3                  <1>         ret
  3110                              <1> 
  3111                              <1> ;=============================================================================
  3112                              <1> ;main_init_good_record_list ---- init the good boot record list
  3113                              <1> ;input:
  3114                              <1> ;      none
  3115                              <1> ;output:
  3116                              <1> ;      cf = 0 sucess
  3117                              <1> ;      cf = 1 failed, no good record
  3118                              <1> ;=============================================================================
  3119                              <1> main_init_good_record_list:
  3120 000017C8 FC                  <1>         cld
  3121 000017C9 60                  <1>         pusha
  3122 000017CA B92000              <1>         mov cx, MAX_RECORD_NUM
  3123 000017CD 8D3E[0F2D]          <1>         lea di, [main_tmp.good_record_list]
  3124 000017D1 8D36[4000]          <1>         lea si, [ADDR_SBMK_BOOT_RECORDS]
  3125 000017D5 31C0                <1>         xor ax, ax
  3126                              <1> 
  3127                              <1> .loop_check:
  3128 000017D7 E89319              <1>         call check_bootrecord                   ; check if it's valid
  3129 000017DA 7203                <1>         jc .check_next
  3130 000017DC AA                  <1>         stosb                                   ; store it's index to buffer
  3131 000017DD FEC4                <1>         inc ah
  3132                              <1>         
  3133                              <1> .check_next:
  3134 000017DF FEC0                <1>         inc al
  3135 000017E1 81C64000            <1>         add si, SIZE_OF_BOOTRECORD
  3136 000017E5 E2F0                <1>         loop .loop_check
  3137                              <1> 
  3138 000017E7 8826[C049]          <1>         mov [GOOD_RECORD_NUMBER], ah
  3139 000017EB 08E4                <1>         or ah, ah
  3140 000017ED 7501                <1>         jnz .ok
  3141 000017EF F9                  <1>         stc
  3142                              <1> .ok:
  3143 000017F0 61                  <1>         popa
  3144 000017F1 C3                  <1>         ret
  3145                              <1> 
  3146                              <1> ;=============================================================================
  3147                              <1> ;init_boot_records ---- init the boot records list
  3148                              <1> ;input:
  3149                              <1> ;      none
  3150                              <1> ;output:
  3151                              <1> ;      none
  3152                              <1> ;=============================================================================
  3153                              <1> main_init_boot_records:
  3154 000017F2 60                  <1>         pusha
  3155 000017F3 FE06[352D]          <1>         inc byte [main_tmp.change_occured]         ; some changes occured.
  3156                              <1> 
  3157 000017F7 FC                  <1>         cld
  3158 000017F8 BE[4000]            <1>         mov si, ADDR_SBMK_BOOT_RECORDS
  3159 000017FB BF[6E2D]            <1>         mov di, main_tmp.records_buf
  3160                              <1> 
  3161 000017FE B90008              <1> 	mov cx, MAX_RECORD_NUM * SIZE_OF_BOOTRECORD
  3162 00001801 E82D18              <1> 	call clear_memory
  3163                              <1> 
  3164 00001804 B84000              <1>         mov ax, SIZE_OF_BOOTRECORD        ; ax = size of bootrecord
  3165 00001807 B92000              <1>         mov cx, MAX_RECORD_NUM            ; cx = max record number
  3166                              <1> 
  3167 0000180A 88CB                <1>         mov bl, cl
  3168                              <1> 
  3169 0000180C 56                  <1>         push si
  3170 0000180D 51                  <1>         push cx                           ; cx = MAX_RECORD_NUM
  3171                              <1> .bkp_good_records:
  3172 0000180E E85C19              <1>         call check_bootrecord
  3173 00001811 720A                <1>         jc .bad_record
  3174                              <1> 
  3175 00001813 56                  <1>         push si
  3176 00001814 51                  <1>         push cx
  3177 00001815 89C1                <1>         mov cx, ax
  3178 00001817 F3A4                <1>         rep movsb
  3179 00001819 59                  <1>         pop cx
  3180 0000181A 5E                  <1>         pop si
  3181                              <1> 
  3182 0000181B FECB                <1>         dec bl
  3183                              <1>         
  3184                              <1> .bad_record:
  3185 0000181D 01C6                <1>         add si, ax
  3186 0000181F E2ED                <1>         loop .bkp_good_records
  3187                              <1> 
  3188 00001821 59                  <1>         pop cx                           ; cx = MAX_RECORD_NUM
  3189 00001822 5E                  <1>         pop si                           ; si -> boot_records
  3190 00001823 87F7                <1>         xchg si, di                      ; di -> boot_records
  3191                              <1> 
  3192 00001825 57                  <1>         push di
  3193 00001826 50                  <1> 	push ax
  3194 00001827 30D2                <1>         xor dl, dl
  3195 00001829 F606[2C00]20        <1>         test byte [ADDR_SBMK_FLAGS], KNLFLAG_ONLYPARTS
  3196 0000182E 0F95C0              <1> 	setnz al
  3197 00001831 E8A81B              <1>         call search_records
  3198 00001834 58                  <1> 	pop ax
  3199 00001835 5F                  <1>         pop di
  3200                              <1> 
  3201                              <1> ;search finished, find out new records
  3202 00001836 B92000              <1>         mov cx, MAX_RECORD_NUM
  3203 00001839 87F7                <1>         xchg si, di                      ; si -> boot_records
  3204                              <1> 
  3205 0000183B 56                  <1>         push si
  3206                              <1> 
  3207 0000183C 08DB                <1>         or bl, bl
  3208 0000183E 741C                <1>         jz .no_space
  3209                              <1> 
  3210                              <1> .search_news:
  3211 00001840 57                  <1>         push di
  3212 00001841 BF[6E2D]            <1>         mov di, main_tmp.records_buf
  3213 00001844 E82000              <1>         call main_find_record_in_buf
  3214 00001847 5F                  <1>         pop di
  3215                              <1> 
  3216 00001848 730A                <1>         jnc .found
  3217                              <1> 
  3218 0000184A 51                  <1>         push cx
  3219 0000184B 56                  <1>         push si
  3220 0000184C 89C1                <1>         mov cx, ax
  3221 0000184E F3A4                <1>         rep movsb
  3222 00001850 5E                  <1>         pop si
  3223 00001851 59                  <1>         pop cx
  3224                              <1> 
  3225 00001852 FECB                <1>         dec bl
  3226                              <1> 
  3227                              <1> .found:
  3228 00001854 08DB                <1>         or bl, bl
  3229 00001856 7404                <1>         jz .no_space
  3230 00001858 01C6                <1>         add si, ax
  3231 0000185A E2E4                <1>         loop .search_news
  3232                              <1> 
  3233                              <1> .no_space:
  3234                              <1> 
  3235 0000185C 5F                  <1>         pop di
  3236 0000185D BE[6E2D]            <1>         mov si, main_tmp.records_buf
  3237 00001860 B90008              <1> 	mov cx, MAX_RECORD_NUM * SIZE_OF_BOOTRECORD
  3238 00001863 F3A4                <1>         rep movsb
  3239                              <1> 
  3240 00001865 61                  <1>         popa
  3241 00001866 C3                  <1>         ret
  3242                              <1> 
  3243                              <1> ;=============================================================================
  3244                              <1> ; main_find_record_in_buf ---- find a record in a buffer
  3245                              <1> ; input:
  3246                              <1> ;      ds:si -> the record
  3247                              <1> ;      es:di -> the buffer
  3248                              <1> ; output:
  3249                              <1> ;      cf = 1 not found
  3250                              <1> ;=============================================================================
  3251                              <1> main_find_record_in_buf:
  3252 00001867 60                  <1>         pusha
  3253 00001868 8B1C                <1> 	mov bx, [si]				; flags
  3254 0000186A F7C30900            <1>         test bx, DRVFLAG_DRIVEOK|INFOFLAG_ISSPECIAL
  3255                              <1> 
  3256 0000186E 7443                <1>         jz .not_found
  3257                              <1> 
  3258 00001870 B92000              <1>         mov cx, MAX_RECORD_NUM
  3259                              <1> 
  3260                              <1> .compare_next:
  3261 00001873 F7C30800            <1> 	test bx, INFOFLAG_ISSPECIAL
  3262 00001877 7408                <1> 	jz .normal_rec
  3263 00001879 F7050800            <1> 	test word [di], INFOFLAG_ISSPECIAL
  3264 0000187D 7524                <1> 	jnz .special_rec
  3265 0000187F EB2C                <1> 	jmp short .not_same
  3266                              <1> 
  3267                              <1> .normal_rec:
  3268 00001881 F7050100            <1> 	test word [di], DRVFLAG_DRIVEOK
  3269 00001885 7426                <1> 	jz .not_same
  3270 00001887 8B4502              <1>         mov ax, [di + struc_bootrecord.drive_id]
  3271 0000188A 394402              <1>         cmp [si + struc_bootrecord.drive_id], ax
  3272 0000188D 751E                <1>         jne .not_same
  3273 0000188F 668B4506            <1>         mov eax, [di + struc_bootrecord.father_abs_addr]
  3274 00001893 66394406            <1>         cmp [si + struc_bootrecord.father_abs_addr], eax
  3275 00001897 7514                <1>         jne .not_same
  3276 00001899 668B450A            <1>         mov eax, [di + struc_bootrecord.abs_addr]
  3277 0000189D 6639440A            <1>         cmp [si + struc_bootrecord.abs_addr], eax
  3278 000018A1 750A                <1>         jne .not_same
  3279                              <1> 
  3280                              <1> .special_rec:
  3281 000018A3 8A4504              <1>         mov al, [di + struc_bootrecord.type]
  3282 000018A6 384404              <1>         cmp [si + struc_bootrecord.type], al
  3283 000018A9 7502                <1>         jne .not_same
  3284                              <1> 
  3285 000018AB EB09                <1>         jmp short .found_same
  3286                              <1> 
  3287                              <1> .not_same:
  3288 000018AD 81C74000            <1>         add di, SIZE_OF_BOOTRECORD
  3289 000018B1 E2C0                <1>         loop .compare_next
  3290                              <1> 
  3291                              <1> .not_found:
  3292 000018B3 F9                  <1>         stc
  3293 000018B4 61                  <1>         popa
  3294 000018B5 C3                  <1>         ret
  3295                              <1> 
  3296                              <1> .found_same:
  3297 000018B6 F8                  <1>         clc
  3298 000018B7 61                  <1>         popa
  3299 000018B8 C3                  <1>         ret
  3300                              <1> 
  3301                              <1> 
  3302                              <1> ;=============================================================================
  3303                              <1> ; >>>>>>>>>>>>>>>>>>>>>>>>> User Interface Functions <<<<<<<<<<<<<<<<<<<<<<<<<
  3304                              <1> ;=============================================================================
  3305                              <1> 
  3306                              <1> ;=============================================================================
  3307                              <1> ;root_window_draw_body_proc ---- draw the root window
  3308                              <1> ;input:
  3309                              <1> ;      none
  3310                              <1> ;output:
  3311                              <1> ;      none
  3312                              <1> ;=============================================================================
  3313                              <1> root_window_draw_body_proc:
  3314 000018B9 8A3E[DD4B]          <1>         mov bh, [color.background]              ;
  3315 000018BD 8B36[EC4B]          <1>         mov si, [icon.background]               ; draw background
  3316 000018C1 8B0E[EA4B]          <1>         mov cx, [icon.background_size]          ;
  3317 000018C5 E82308              <1>         call draw_background                    ;
  3318                              <1> 
  3319 000018C8 31D2                <1>         xor dx, dx                              ;
  3320 000018CA 8B1E[DE4B]          <1>         mov bx, [color.copyright]               ;
  3321 000018CE A0[ED2A]            <1>         mov al, [ui_screen_width]               ; draw copyright message
  3322 000018D1 50                  <1>         push ax                                 ; save screen width
  3323 000018D2 8A0E[AE4B]          <1>         mov cl, [size.copyright]
  3324 000018D6 F6E1                <1>         mul cl
  3325 000018D8 89C1                <1>         mov cx, ax
  3326 000018DA B020                <1>         mov al, ' '                             ;
  3327 000018DC E8A705              <1>         call draw_char                          ;
  3328 000018DF 8B36[494C]          <1>         mov si, [str_idx.copyright]
  3329 000018E3 E87905              <1>         call draw_string_hl
  3330                              <1>         
  3331 000018E6 8B1E[E04B]          <1>         mov bx, [color.hint]                    ;
  3332 000018EA 8A36[EE2A]          <1>         mov dh, [ui_screen_height]              ;
  3333 000018EE 8A0E[AF4B]          <1>         mov cl, [size.hint]                     ;
  3334 000018F2 28CE                <1>         sub dh, cl                              ; draw hint message
  3335 000018F4 58                  <1>         pop ax                                  ; get screen width
  3336 000018F5 F6E1                <1>         mul cl                                  ;
  3337 000018F7 89C1                <1>         mov cx, ax                              ;
  3338 000018F9 B020                <1>         mov al, ' '                             ;
  3339 000018FB E88805              <1>         call draw_char                          ;
  3340 000018FE 8B36[4B4C]          <1>         mov si, [str_idx.hint]                  ;
  3341 00001902 E85A05              <1>         call draw_string_hl                     ;
  3342                              <1> 
  3343 00001905 8B16[A84B]          <1>         mov dx, [position.brand]                ; draw brand icon
  3344 00001909 8B0E[E64B]          <1>         mov cx, [icon.brand_size]               ;
  3345 0000190D 80FAFF              <1>         cmp dl, 0xFF                            ;
  3346 00001910 7506                <1>         jne .not_justify                        ;
  3347 00001912 8A16[ED2A]          <1>         mov dl, [ui_screen_width]               ; right justify
  3348 00001916 28CA                <1>         sub dl, cl                              ;
  3349                              <1> .not_justify:                                   ;
  3350 00001918 8B36[E84B]          <1>         mov si, [icon.brand]                    ;
  3351 0000191C E8A507              <1>         call draw_icon                          ;
  3352                              <1> 
  3353 0000191F E80A00              <1>         call root_window_draw_date
  3354 00001922 E82000              <1>         call root_window_draw_time
  3355 00001925 E8D100              <1>         call root_window_draw_delay_time
  3356 00001928 E83300              <1>         call root_window_draw_knl_flags
  3357                              <1> 
  3358 0000192B C3                  <1>         ret
  3359                              <1>         
  3360                              <1> ;=============================================================================
  3361                              <1> ;root_window_draw_date ---- draw the date string
  3362                              <1> ;input:
  3363                              <1> ;      none
  3364                              <1> ;output:
  3365                              <1> ;      none
  3366                              <1> ;=============================================================================
  3367                              <1> root_window_draw_date:
  3368 0000192C 60                  <1>         pusha
  3369 0000192D BF[BE36]            <1>         mov di, main_tmp.root_buf               ; draw date
  3370 00001930 A0[A44B]            <1>         mov al, [show_date_method]              ;
  3371 00001933 E84216              <1>         call get_current_date_string            ;
  3372 00001936 89FE                <1>         mov si, di                              ;
  3373 00001938 8A1E[E44B]          <1>         mov bl, [color.date]                    ;
  3374 0000193C 8B16[AA4B]          <1>         mov dx, [position.date]                 ;
  3375 00001940 E81C05              <1>         call draw_string                        ;
  3376 00001943 61                  <1>         popa
  3377 00001944 C3                  <1>         ret
  3378                              <1> 
  3379                              <1> ;=============================================================================
  3380                              <1> ;draw_time ---- draw the time string
  3381                              <1> ;input:
  3382                              <1> ;      none
  3383                              <1> ;output:
  3384                              <1> ;      none
  3385                              <1> ;=============================================================================
  3386                              <1> root_window_draw_time:
  3387 00001945 60                  <1>         pusha
  3388 00001946 BF[BE36]            <1>         mov di, main_tmp.root_buf               ; draw date
  3389 00001949 A0[A54B]            <1>         mov al, [show_time_method]              ;
  3390 0000194C E80216              <1>         call get_current_time_string            ;
  3391 0000194F 89FE                <1>         mov si, di                              ;
  3392 00001951 8A1E[E54B]          <1>         mov bl, [color.time]                    ;
  3393 00001955 8B16[AC4B]          <1>         mov dx, [position.time]                 ;
  3394 00001959 E80305              <1>         call draw_string                        ;
  3395 0000195C 61                  <1>         popa
  3396 0000195D C3                  <1>         ret
  3397                              <1> 
  3398                              <1> ;=============================================================================
  3399                              <1> ;root_window_draw_knl_flags ---- draw root passwd, login, secure mode, 
  3400                              <1> ;                                remember last and int13 ext flags.
  3401                              <1> ;=============================================================================
  3402                              <1> root_window_draw_knl_flags:
  3403 0000195E 8B16[ED2A]          <1>         mov dx, [ui_screen_size]
  3404 00001962 81EA1301            <1>         sub dx, 0x0113
  3405 00001966 B90100              <1>         mov cx, 1
  3406                              <1> 
  3407                              <1> ; draw seperators
  3408 00001969 8A1E[E04B]          <1>         mov bl, [color.hint]
  3409 0000196D B07C                <1>         mov al, '|'
  3410 0000196F E81405              <1>         call draw_char
  3411 00001972 80C204              <1> 	add dl,4
  3412 00001975 E80E05              <1> 	call draw_char
  3413 00001978 80C206              <1> 	add dl,6
  3414 0000197B E80805              <1> 	call draw_char
  3415 0000197E 80EA09              <1> 	sub dl,9
  3416                              <1> 
  3417                              <1> ; draw driver id
  3418 00001981 BF[BE36]            <1>         mov di, main_tmp.root_buf
  3419 00001984 57                  <1> 	push di
  3420 00001985 52                  <1> 	push dx
  3421 00001986 8A16[1000]          <1> 	mov dl, [ADDR_SBMK_DRVID]
  3422 0000198A E82623              <1> 	call get_drvid_str
  3423 0000198D 5A                  <1> 	pop dx
  3424 0000198E 5E                  <1> 	pop si
  3425                              <1> 
  3426 0000198F 8A1E[E34B]          <1>         mov bl, [color.knl_drvid]
  3427                              <1> 
  3428 00001993 E8C904              <1>         call draw_string
  3429 00001996 80C204              <1>         add dl, 4
  3430                              <1> 
  3431                              <1> ; draw flags
  3432 00001999 8A1E[E24B]          <1>         mov bl, [color.knl_flags]
  3433 0000199D 66813E[3000]000000- <1>         cmp dword [ADDR_SBMK_ROOT_PASSWORD], 0
  3434 000019A5 00                  <1>
  3435 000019A6 7404                <1>         jz .no_root_password
  3436                              <1>         
  3437 000019A8 B050                <1>         mov al, 'P'
  3438 000019AA EB02                <1>         jmp short .draw_pwd
  3439                              <1> .no_root_password:
  3440 000019AC B02D                <1>         mov al, '-'
  3441                              <1> .draw_pwd:
  3442 000019AE E8D504              <1>         call draw_char
  3443 000019B1 FEC2                <1>         inc dl
  3444                              <1> 
  3445 000019B3 8A26[2C00]          <1> 	mov ah, [ADDR_SBMK_FLAGS]
  3446                              <1> 
  3447 000019B7 F6C402              <1>         test ah, KNLFLAG_SECURITY
  3448 000019BA 7404                <1>         jz .no_security
  3449                              <1> 
  3450 000019BC B053                <1>         mov al, 'S'
  3451 000019BE EB02                <1>         jmp short .draw_security
  3452                              <1> .no_security:
  3453 000019C0 B02D                <1>         mov al, '-'
  3454                              <1> .draw_security:
  3455 000019C2 E8C104              <1>         call draw_char
  3456 000019C5 FEC2                <1>         inc dl
  3457                              <1> 
  3458 000019C7 803E[362D]00        <1>         cmp byte [main_tmp.root_login],0
  3459 000019CC 7404                <1>         jz .no_root_login
  3460                              <1> 
  3461 000019CE B041                <1>         mov al, 'A'
  3462 000019D0 EB02                <1>         jmp short .draw_login
  3463                              <1> .no_root_login:
  3464 000019D2 B02D                <1>         mov al, '-'
  3465                              <1> .draw_login:
  3466 000019D4 E8AF04              <1>         call draw_char
  3467                              <1> 
  3468 000019D7 FEC2                <1>         inc dl
  3469                              <1> 
  3470 000019D9 F6C410              <1>         test ah, KNLFLAG_REMLAST
  3471 000019DC 7404                <1>         jz .no_remlast
  3472 000019DE B04C                <1>         mov al, 'L'
  3473 000019E0 EB02                <1>         jmp short .draw_remlast
  3474                              <1> .no_remlast:
  3475 000019E2 B02D                <1>         mov al, '-'
  3476                              <1> .draw_remlast:
  3477 000019E4 E89F04              <1>         call draw_char
  3478                              <1> 
  3479 000019E7 FEC2                <1>         inc dl
  3480                              <1> 
  3481 000019E9 F6C404              <1>         test ah, KNLFLAG_NOINT13EXT
  3482 000019EC 7505                <1>         jnz .no_int13ext
  3483 000019EE B045                <1>         mov al, 'E'
  3484 000019F0 E90200              <1>         jmp .draw_int13ext
  3485                              <1> .no_int13ext:
  3486 000019F3 B02D                <1>         mov al, '-'
  3487                              <1> .draw_int13ext:
  3488 000019F5 E88E04              <1>         call draw_char
  3489 000019F8 C3                  <1>         ret
  3490                              <1> 
  3491                              <1> ;=============================================================================
  3492                              <1> ;root_window_draw_delay_time ---- draw the delay_time and time_count
  3493                              <1> ;=============================================================================
  3494                              <1> root_window_draw_delay_time:
  3495 000019F9 0FB606[2F2D]        <1>         movzx ax, byte [main_tmp.time_count]
  3496 000019FE B90300              <1>         mov cx, 3
  3497 00001A01 BF[BE36]            <1>         mov di, main_tmp.root_buf
  3498 00001A04 E8B911              <1>         call itoa
  3499                              <1>         
  3500 00001A07 8A1E[DC4B]          <1>         mov bl, [color.delay_time]
  3501 00001A0B 8B16[ED2A]          <1>         mov dx, [ui_screen_size]
  3502 00001A0F 81EA0801            <1>         sub dx, 0x0108
  3503 00001A13 89FE                <1>         mov si, di
  3504 00001A15 E84704              <1>         call draw_string
  3505                              <1> 
  3506 00001A18 0FB606[2D00]        <1>         movzx ax, byte [ADDR_SBMK_DELAY_TIME]
  3507 00001A1D B90300              <1>         mov cx, 3
  3508 00001A20 E89D11              <1>         call itoa
  3509                              <1> 
  3510 00001A23 B03A                <1>         mov al, ':'
  3511 00001A25 B101                <1>         mov cl, 1
  3512 00001A27 80C203              <1>         add dl, 3
  3513 00001A2A E85904              <1>         call draw_char
  3514 00001A2D FEC2                <1>         inc dl
  3515 00001A2F E82D04              <1>         call draw_string
  3516 00001A32 B020                <1>         mov al, ' '
  3517 00001A34 80C203              <1>         add dl, 3
  3518 00001A37 E84C04              <1>         call draw_char
  3519 00001A3A C3                  <1>         ret
  3520                              <1> 
  3521                              <1> 
  3522                              <1> ;=============================================================================
  3523                              <1> ; boot_menu_item_str_proc ---- get item string of boot menu
  3524                              <1> ; input:
  3525                              <1> ;	cx = index
  3526                              <1> ; output:
  3527                              <1> ;	ds:si -> item string
  3528                              <1> ;=============================================================================
  3529                              <1> boot_menu_item_str_proc:
  3530 00001A3B E8C101              <1> 	call main_get_record_pointer
  3531                              <1> 
  3532 00001A3E FC                  <1> 	cld
  3533 00001A3F 8D3E[6E35]          <1>         lea di, [main_tmp.record_string]
  3534 00001A43 57                  <1> 	push di
  3535                              <1> 
  3536 00001A44 3A0E[2F00]          <1> 	cmp cl, [ADDR_SBMK_DEFAULT_BOOT]
  3537 00001A48 7502                <1> 	jne .not_def
  3538 00001A4A B02A                <1> 	mov al, '*'
  3539                              <1> .not_def:
  3540 00001A4C AA                  <1> 	stosb
  3541                              <1> 
  3542 00001A4D A0[3400]            <1>         mov al, [ADDR_SBMK_BOOTMENU_STYLE]
  3543 00001A50 E83D1A              <1>         call get_record_string
  3544 00001A53 5E                  <1> 	pop si
  3545 00001A54 C3                  <1> 	ret
  3546                              <1> 
  3547                              <1> ;=============================================================================
  3548                              <1> ; main_menu_item_str_proc ---- get item string of main menu
  3549                              <1> ; input:
  3550                              <1> ;	cx = index
  3551                              <1> ; output:
  3552                              <1> ;	ds:si -> item string
  3553                              <1> ;=============================================================================
  3554                              <1> main_menu_item_str_proc:
  3555 00001A55 BE[794C]            <1> 	mov si, str_idx.main_menu_strings
  3556 00001A58 EB0A                <1> 	jmp short main_get_cmd_menu_item_str
  3557                              <1> 
  3558                              <1> ;=============================================================================
  3559                              <1> ; record_menu_item_str_proc ---- get item string of record menu
  3560                              <1> ; input:
  3561                              <1> ;	cx = index
  3562                              <1> ; output:
  3563                              <1> ;	ds:si -> item string
  3564                              <1> ;=============================================================================
  3565                              <1> record_menu_item_str_proc:
  3566 00001A5A BE[914C]            <1> 	mov si, str_idx.record_menu_strings
  3567 00001A5D EB05                <1> 	jmp short main_get_cmd_menu_item_str
  3568                              <1> 
  3569                              <1> ;=============================================================================
  3570                              <1> ; sys_menu_item_str_proc ---- get item string of sys menu
  3571                              <1> ; input:
  3572                              <1> ;	cx = index
  3573                              <1> ; output:
  3574                              <1> ;	ds:si -> item string
  3575                              <1> ;=============================================================================
  3576                              <1> sys_menu_item_str_proc:
  3577 00001A5F BE[B34C]            <1> 	mov si, str_idx.sys_menu_strings
  3578 00001A62 EB00                <1> 	jmp short main_get_cmd_menu_item_str
  3579                              <1> 
  3580                              <1> ;=============================================================================
  3581                              <1> ; main_get_cmd_menu_item_str ---- get item string of a command menu
  3582                              <1> ; input:
  3583                              <1> ;	cx = index
  3584                              <1> ;	ds:si -> str_idx
  3585                              <1> ; output:
  3586                              <1> ;	ds:si -> item string
  3587                              <1> ;=============================================================================
  3588                              <1> main_get_cmd_menu_item_str:
  3589 00001A64 D1E1                <1> 	shl cx,1
  3590 00001A66 01CE                <1> 	add si, cx
  3591 00001A68 8B34                <1> 	mov si, [si]
  3592 00001A6A C3                  <1> 	ret
  3593                              <1> 
  3594                              <1> ;=============================================================================
  3595                              <1> ;main_check_update_time ---- check if the time message needs update.
  3596                              <1> ;output:
  3597                              <1> ;	cf = 0 not changed
  3598                              <1> ;	cf = 1 changed
  3599                              <1> ;=============================================================================
  3600                              <1> main_check_update_time:
  3601 00001A6B 50                  <1> 	push ax
  3602 00001A6C B402                <1>         mov ah, 0x02
  3603 00001A6E CD1A                <1>         int 0x1a
  3604                              <1> 
  3605 00001A70 390E[372D]          <1>         cmp [main_tmp.last_time], cx
  3606 00001A74 7407                <1>         je .end
  3607                              <1> 
  3608 00001A76 890E[372D]          <1>         mov [main_tmp.last_time], cx
  3609 00001A7A F9                  <1> 	stc
  3610 00001A7B 58                  <1> 	pop ax
  3611 00001A7C C3                  <1> 	ret
  3612                              <1> .end:
  3613 00001A7D F8                  <1> 	clc
  3614 00001A7E 58                  <1> 	pop ax
  3615 00001A7F C3                  <1>         ret
  3616                              <1> 
  3617                              <1> 
  3618                              <1> ;=============================================================================
  3619                              <1> ;main_check_delay_time ---- check if the delay time is up
  3620                              <1> ; output:
  3621                              <1> ;	cf = 0 not zero
  3622                              <1> ;	cf = 1 zero
  3623                              <1> ;=============================================================================
  3624                              <1> main_check_delay_time:
  3625 00001A80 30E4                <1>         xor ah, ah                                      ; get time ticks
  3626 00001A82 CD1A                <1>         int 0x1a                                        ;
  3627                              <1> 
  3628 00001A84 3B16[302D]          <1>         cmp dx, [main_tmp.ticks_count]
  3629 00001A88 7304                <1>         jae .next_time                                  ; dx must greater than
  3630 00001A8A 8916[302D]          <1>         mov [main_tmp.ticks_count], dx                  ; ticks_count
  3631                              <1> .next_time:
  3632 00001A8E 31C0                <1> 	xor ax, ax
  3633 00001A90 89D1                <1>         mov cx, dx                                      ; every 18 ticks approxmiately
  3634 00001A92 2B0E[302D]          <1>         sub cx, [main_tmp.ticks_count]                  ; equal to 1 second,
  3635 00001A96 81F91200            <1>         cmp cx, 18                                      ; decrease time_count
  3636 00001A9A 7609                <1>         jbe .not_add                                    ; until to zero.
  3637 00001A9C 8916[302D]          <1>         mov [main_tmp.ticks_count], dx
  3638 00001AA0 FE0E[2F2D]          <1>         dec byte [main_tmp.time_count]
  3639 00001AA4 40                  <1> 	inc ax
  3640                              <1> .not_add:
  3641 00001AA5 803E[2F2D]00        <1>         cmp byte [main_tmp.time_count], 0               ; if time is up, then
  3642 00001AAA 7502                <1>         jne .no_up                                      ; send ESC key.
  3643 00001AAC F9                  <1> 	stc
  3644 00001AAD C3                  <1> 	ret
  3645                              <1> 
  3646                              <1> .no_up:
  3647 00001AAE F8                  <1> 	clc
  3648 00001AAF C3                  <1> 	ret
  3649                              <1> 
  3650                              <1> ;=============================================================================
  3651                              <1> ;get_event ---- get a event, if no key is pressed then count down the 
  3652                              <1> ;               delay time until to zero and send an EVENT_BOOT_DEFAULT event
  3653                              <1> ;input:
  3654                              <1> ;      none
  3655                              <1> ;output:
  3656                              <1> ;      ax = the key code
  3657                              <1> ;=============================================================================
  3658                              <1> get_event:
  3659 00001AB0 60                  <1> 	pusha
  3660                              <1> 
  3661 00001AB1 31C0                <1> 	xor ax, ax
  3662                              <1> 
  3663                              <1> .loop_get_event:
  3664 00001AB3 E8B5FF              <1> 	call main_check_update_time
  3665 00001AB6 7305                <1> 	jnc .no_update_time
  3666                              <1> 
  3667 00001AB8 B801F4              <1> 	mov ax, EVENT_REDRAW_ROOT
  3668 00001ABB EB31                <1> 	jmp short .cont_loop
  3669                              <1> 
  3670                              <1> .no_update_time:
  3671                              <1> 
  3672 00001ABD 803E[2D00]00        <1> 	cmp byte [ADDR_SBMK_DELAY_TIME], 0
  3673 00001AC2 741E                <1> 	je .no_count
  3674 00001AC4 803E[322D]00        <1> 	cmp byte [main_tmp.key_pressed], 0
  3675 00001AC9 7517                <1> 	jne .no_count
  3676                              <1> 
  3677 00001ACB E8B2FF              <1> 	call main_check_delay_time
  3678 00001ACE 7309                <1> 	jnc .has_delay
  3679 00001AD0 B802F4              <1> 	mov ax, EVENT_BOOT_DEFAULT
  3680 00001AD3 FE06[322D]          <1> 	inc byte [main_tmp.key_pressed]
  3681 00001AD7 EB15                <1> 	jmp short .cont_loop
  3682                              <1> 
  3683                              <1> .has_delay
  3684 00001AD9 09C0                <1> 	or ax, ax
  3685 00001ADB 7405                <1> 	jz .no_count
  3686 00001ADD B801F4              <1> 	mov ax, EVENT_REDRAW_ROOT
  3687 00001AE0 EB0C                <1> 	jmp short .cont_loop
  3688                              <1> 
  3689                              <1> .no_count:
  3690 00001AE2 E8A613              <1> 	call check_keyevent
  3691 00001AE5 09C0                <1> 	or ax, ax
  3692 00001AE7 7405                <1> 	jz .cont_loop
  3693                              <1> 
  3694                              <1> .key_pressed:
  3695 00001AE9 C606[322D]01        <1> 	mov byte [main_tmp.key_pressed], 1
  3696                              <1> 
  3697                              <1> .cont_loop:
  3698 00001AEE 09C0                <1> 	or ax, ax
  3699 00001AF0 74C1                <1> 	jz .loop_get_event
  3700                              <1> 
  3701 00001AF2 A3[332D]            <1> 	mov [main_tmp.keycode], ax
  3702 00001AF5 61                  <1> 	popa
  3703 00001AF6 A1[332D]            <1> 	mov ax, [main_tmp.keycode]
  3704 00001AF9 C3                  <1> 	ret
  3705                              <1>         
  3706                              <1> 
  3707                              <1> ;=============================================================================
  3708                              <1> ; main_auth_record_action
  3709                              <1> ;=============================================================================
  3710                              <1> main_auth_record_action:
  3711 00001AFA B0D0                <1> 	mov al, ACTFLAG_CHK_RECNUM | ACTFLAG_AUTH_SECURITY | ACTFLAG_AUTH_RECORD
  3712                              <1> 
  3713                              <1> ;=============================================================================
  3714                              <1> ; main_auth_action  ---- auth an action
  3715                              <1> ; input:
  3716                              <1> ;	al = auth type
  3717                              <1> ; output:
  3718                              <1> ;	cf = 0, success
  3719                              <1> ;	cf = 1, failed
  3720                              <1> ;=============================================================================
  3721                              <1> main_auth_action:
  3722 00001AFC 60                  <1> 	pusha
  3723                              <1> 
  3724 00001AFD A810                <1> 	test al, ACTFLAG_CHK_RECNUM
  3725 00001AFF 7407                <1> 	jz .test_security
  3726                              <1> 
  3727 00001B01 803E[C049]00        <1> 	cmp byte [GOOD_RECORD_NUMBER], 0
  3728 00001B06 7427                <1> 	jz .auth_failed
  3729                              <1> 
  3730                              <1> .test_security:
  3731 00001B08 803E[362D]00        <1>         cmp byte [main_tmp.root_login], 0
  3732 00001B0D 7514                <1>         jnz .auth_ok
  3733                              <1> 
  3734 00001B0F F606[2C00]02        <1> 	test byte [ADDR_SBMK_FLAGS], KNLFLAG_SECURITY
  3735 00001B14 7404                <1> 	jz .test_root
  3736                              <1> 
  3737 00001B16 A880                <1> 	test al, ACTFLAG_AUTH_SECURITY
  3738 00001B18 7504                <1> 	jnz .auth_root
  3739                              <1> 
  3740                              <1> .test_root:
  3741 00001B1A A820                <1> 	test al, ACTFLAG_AUTH_ROOT
  3742 00001B1C 7408                <1> 	jz .test_record
  3743                              <1> 
  3744                              <1> .auth_root:
  3745 00001B1E E81100              <1> 	call main_confirm_root_passwd
  3746 00001B21 720C                <1> 	jc .auth_failed
  3747                              <1> 
  3748                              <1> .auth_ok:
  3749 00001B23 F8                  <1> 	clc
  3750 00001B24 61                  <1> 	popa
  3751 00001B25 C3                  <1> 	ret
  3752                              <1> 
  3753                              <1> .test_record:
  3754 00001B26 A840                <1> 	test al, ACTFLAG_AUTH_RECORD
  3755 00001B28 74F9                <1> 	jz .auth_ok
  3756 00001B2A E82100              <1> 	call main_confirm_record_passwd
  3757 00001B2D 73F4                <1> 	jnc .auth_ok
  3758                              <1> 
  3759                              <1> .auth_failed:
  3760 00001B2F F9                  <1> 	stc
  3761 00001B30 61                  <1> 	popa
  3762 00001B31 C3                  <1> 	ret
  3763                              <1> 
  3764                              <1> 	
  3765                              <1> ;=============================================================================
  3766                              <1> ;main_confirm_root_passwd ---- confirm the root password
  3767                              <1> ;input:
  3768                              <1> ;      none
  3769                              <1> ;output:
  3770                              <1> ;      cf = 0 success
  3771                              <1> ;      cf = 1 failed or cancel
  3772                              <1> ;=============================================================================
  3773                              <1> main_confirm_root_passwd:
  3774 00001B32 60                  <1>         pusha
  3775 00001B33 8B1E[3000]          <1>         mov bx, [ADDR_SBMK_ROOT_PASSWORD]
  3776 00001B37 8B0E[3200]          <1>         mov cx, [ADDR_SBMK_ROOT_PASSWORD+2]
  3777 00001B3B 09DB                <1>         or bx, bx
  3778 00001B3D 7506                <1>         jnz .have_password
  3779 00001B3F 09C9                <1>         or cx, cx
  3780 00001B41 7502                <1>         jnz .have_password
  3781 00001B43 EB07                <1>         jmp short .auth_ok
  3782                              <1>         
  3783                              <1> .have_password:                                     
  3784 00001B45 8B36[194C]          <1>         mov si, [str_idx.root_passwd]               ; check root
  3785 00001B49 E81F00              <1>         call main_confirm_passwd                    ; password
  3786                              <1> .auth_ok:
  3787 00001B4C 61                  <1>         popa
  3788 00001B4D C3                  <1>         ret
  3789                              <1> 
  3790                              <1> ;=============================================================================
  3791                              <1> ;main_confirm_record_passwd ---- confirm the record password
  3792                              <1> ;=============================================================================
  3793                              <1> main_confirm_record_passwd:
  3794 00001B4E 60                  <1>         pusha
  3795 00001B4F E89A00              <1>         call main_get_focus_record_pointer
  3796 00001B52 8B5C0E              <1>         mov bx, [si + struc_bootrecord.password]
  3797 00001B55 8B4C10              <1>         mov cx, [si + struc_bootrecord.password+2]
  3798 00001B58 09DB                <1>         or bx, bx
  3799 00001B5A 7506                <1>         jnz .have_password
  3800 00001B5C 09C9                <1>         or cx, cx
  3801 00001B5E 7502                <1>         jnz .have_password
  3802 00001B60 EB07                <1>         jmp short .auth_ok
  3803                              <1>         
  3804                              <1> .have_password:
  3805 00001B62 8B36[1D4C]          <1>         mov si, [str_idx.record_passwd]             ; check record
  3806 00001B66 E80200              <1>         call main_confirm_passwd                    ; password
  3807                              <1> .auth_ok:
  3808 00001B69 61                  <1>         popa
  3809 00001B6A C3                  <1>         ret
  3810                              <1> 
  3811                              <1> ;=============================================================================
  3812                              <1> ;main_confirm_passwd ---- let user input a password and confirm it.
  3813                              <1> ;input:
  3814                              <1> ;      bx:cx = password
  3815                              <1> ;      ds:si -> message string
  3816                              <1> ;output:
  3817                              <1> ;      cf = 0 success
  3818                              <1> ;      cf = 1 failed or cancel
  3819                              <1> ;=============================================================================
  3820                              <1> main_confirm_passwd:
  3821 00001B6B 803E[362D]00        <1>         cmp byte [main_tmp.root_login],0       ; check if root has logined
  3822 00001B70 7520                <1>         jnz .ok
  3823                              <1> 
  3824 00001B72 51                  <1> 	push cx
  3825 00001B73 B110                <1> 	mov cl, MAX_PASSWORD_LENGTH
  3826 00001B75 E89908              <1>         call input_password
  3827 00001B78 59                  <1> 	pop cx
  3828 00001B79 7220                <1>         jc .cancel
  3829                              <1> 
  3830 00001B7B 39C3                <1>         cmp bx, ax
  3831 00001B7D 7507                <1>         jne .cmp_root
  3832 00001B7F 39D1                <1>         cmp cx, dx
  3833 00001B81 7503                <1>         jne .cmp_root
  3834 00001B83 E90C00              <1>         jmp .ok
  3835                              <1>         
  3836                              <1> .cmp_root:
  3837 00001B86 3906[3000]          <1>         cmp [ADDR_SBMK_ROOT_PASSWORD], ax
  3838 00001B8A 7508                <1>         jne .failed
  3839 00001B8C 3916[3200]          <1>         cmp [ADDR_SBMK_ROOT_PASSWORD+2], dx
  3840 00001B90 7502                <1>         jne .failed
  3841                              <1> .ok:
  3842 00001B92 F8                  <1>         clc
  3843 00001B93 C3                  <1>         ret
  3844                              <1>         
  3845                              <1> .failed:
  3846 00001B94 8B36[574C]          <1>         mov si, [str_idx.wrong_passwd]
  3847 00001B98 E84F06              <1>         call error_box
  3848                              <1>         
  3849                              <1> .cancel:
  3850 00001B9B F9                  <1>         stc
  3851 00001B9C C3                  <1>         ret
  3852                              <1> 
  3853                              <1> ;=============================================================================
  3854                              <1> ; main_show_disk_error ---- show the disk error box.
  3855                              <1> ;=============================================================================
  3856                              <1> main_show_disk_error:
  3857 00001B9D 8B36[594C]          <1>         mov si, [str_idx.disk_error]
  3858 00001BA1 BF[BE35]            <1>         mov di, main_tmp.dialog_buf
  3859 00001BA4 57                  <1>         push di
  3860 00001BA5 E8BF10              <1>         call strcpy
  3861 00001BA8 E80421              <1> 	call get_last_disk_errno
  3862 00001BAB B102                <1>         mov cl, 2
  3863 00001BAD E8E710              <1>         call htoa
  3864 00001BB0 5E                  <1>         pop si
  3865 00001BB1 E83606              <1>         call error_box
  3866 00001BB4 C3                  <1>         ret
  3867                              <1> 
  3868                              <1> 
  3869                              <1> ;=============================================================================
  3870                              <1> ;>>>>>>>>>>>>>>>>>>>>>>>>>> Miscellaneous Functions <<<<<<<<<<<<<<<<<<<<<<<<<<
  3871                              <1> ;=============================================================================
  3872                              <1> 
  3873                              <1> ;=============================================================================
  3874                              <1> ;main_recheck_same_records ---- recheck all records that same as given record
  3875                              <1> ;input:
  3876                              <1> ;      ds:si -> record
  3877                              <1> ;output:
  3878                              <1> ;      cf = 0  success
  3879                              <1> ;      cf = 1  failed
  3880                              <1> ;=============================================================================
  3881                              <1> main_recheck_same_records:
  3882 00001BB5 60                  <1>         pusha
  3883 00001BB6 8B4402              <1>         mov ax, [si + struc_bootrecord.drive_id]
  3884 00001BB9 668B5C06            <1>         mov ebx, [si + struc_bootrecord.father_abs_addr]
  3885 00001BBD 668B540A            <1>         mov edx, [si + struc_bootrecord.abs_addr]
  3886                              <1> 
  3887 00001BC1 8D36[4000]          <1>         lea si, [ADDR_SBMK_BOOT_RECORDS]
  3888 00001BC5 B92000              <1>         mov cx, MAX_RECORD_NUM
  3889                              <1> 
  3890                              <1> .loop_check:
  3891 00001BC8 F60401              <1>         test byte [si + struc_bootrecord.flags], DRVFLAG_DRIVEOK
  3892 00001BCB 7416                <1>         jz .check_next
  3893 00001BCD 394402              <1>         cmp [si + struc_bootrecord.drive_id], ax
  3894 00001BD0 7511                <1>         jne .check_next
  3895 00001BD2 66395C06            <1>         cmp [si + struc_bootrecord.father_abs_addr], ebx
  3896 00001BD6 750B                <1>         jne .check_next
  3897 00001BD8 6639540A            <1>         cmp [si + struc_bootrecord.abs_addr], edx
  3898 00001BDC 7505                <1>         jne .check_next
  3899                              <1> 
  3900 00001BDE E88C15              <1>         call check_bootrecord
  3901 00001BE1 7207                <1>         jc .end
  3902                              <1> 
  3903                              <1> .check_next:
  3904 00001BE3 81C64000            <1>         add si, SIZE_OF_BOOTRECORD
  3905 00001BE7 E2DF                <1>         loop .loop_check
  3906 00001BE9 F8                  <1>         clc
  3907                              <1> .end:
  3908 00001BEA 61                  <1>         popa
  3909 00001BEB C3                  <1>         ret
  3910                              <1> 
  3911                              <1> ;=============================================================================
  3912                              <1> ;main_get_focus_record_pointer ---- get current boot record's pointer
  3913                              <1> ;input:
  3914                              <1> ;	none
  3915                              <1> ;output:
  3916                              <1> ;       ds:si -> record pointer
  3917                              <1> ;=============================================================================
  3918                              <1> main_get_focus_record_pointer:
  3919 00001BEC 31F6                <1>         xor si, si
  3920 00001BEE 803E[C049]00        <1>         cmp byte [GOOD_RECORD_NUMBER], 0
  3921 00001BF3 7409                <1>         jz .end
  3922 00001BF5 51                  <1> 	push cx
  3923 00001BF6 8A0E[C149]          <1> 	mov cl, [FOCUS_RECORD]
  3924 00001BFA E80200              <1> 	call main_get_record_pointer
  3925 00001BFD 59                  <1> 	pop cx
  3926                              <1> .end:
  3927 00001BFE C3                  <1> 	ret
  3928                              <1> 
  3929                              <1> ;=============================================================================
  3930                              <1> ;main_get_record_pointer ---- get boot record's pointer
  3931                              <1> ;input:
  3932                              <1> ;      cl = record index in good record list
  3933                              <1> ;output:
  3934                              <1> ;      cl = real index in boot_records list
  3935                              <1> ;      ds:si -> record pointer
  3936                              <1> ;=============================================================================
  3937                              <1> main_get_record_pointer:
  3938 00001BFF 50                  <1>         push ax
  3939 00001C00 30ED                <1>         xor ch, ch
  3940 00001C02 BE[0F2D]            <1>         mov si, main_tmp.good_record_list       ;
  3941 00001C05 01CE                <1>         add si, cx                              ;
  3942 00001C07 AC                  <1>         lodsb                                   ;
  3943 00001C08 50                  <1> 	push ax
  3944                              <1> 
  3945 00001C09 B140                <1>         mov cl, SIZE_OF_BOOTRECORD              ; get the pointer to
  3946 00001C0B F6E1                <1>         mul cl                                  ; the record.
  3947 00001C0D BE[4000]            <1>         mov si, ADDR_SBMK_BOOT_RECORDS          ;
  3948 00001C10 01C6                <1>         add si, ax                              ;
  3949 00001C12 59                  <1> 	pop cx
  3950 00001C13 30ED                <1> 	xor ch, ch
  3951 00001C15 58                  <1>         pop ax
  3952 00001C16 C3                  <1>         ret
  3953                              <1> 
  3954                              <1> ;=============================================================================
  3955                              <1> ;main_boot_default ---- boot the default record
  3956                              <1> ;=============================================================================
  3957                              <1> main_boot_default:
  3958 00001C17 8A26[2F00]          <1>         mov ah, [ADDR_SBMK_DEFAULT_BOOT]
  3959 00001C1B BE[0F2D]            <1>         mov si, main_tmp.good_record_list
  3960 00001C1E 0FB60E[C049]        <1>         movzx cx, [GOOD_RECORD_NUMBER]
  3961 00001C23 08C9                <1>         or cl, cl
  3962 00001C25 7408                <1>         jz .no_default
  3963 00001C27 FC                  <1>         cld
  3964                              <1> 
  3965                              <1> .loop_search:
  3966 00001C28 AC                  <1>         lodsb
  3967 00001C29 38E0                <1>         cmp al, ah
  3968 00001C2B 7403                <1>         je .found_it
  3969 00001C2D E2F9                <1>         loop .loop_search
  3970                              <1>         
  3971                              <1> .no_default:                                ; no default record, do nothing.
  3972 00001C2F C3                  <1>         ret
  3973                              <1>         
  3974                              <1> .found_it:
  3975 00001C30 50                  <1> 	push ax
  3976 00001C31 E85001              <1> 	call main_hide_auto_hides
  3977 00001C34 58                  <1> 	pop ax
  3978 00001C35 30E4                <1> 	xor ah, ah
  3979 00001C37 E80100              <1>         call main_do_boot_record
  3980 00001C3A C3                  <1>         ret
  3981                              <1>         
  3982                              <1> ;=============================================================================
  3983                              <1> ;main_do_boot_record ---- really boot the given record.
  3984                              <1> ;input:
  3985                              <1> ;      ax =  the boot record number.
  3986                              <1> ;=============================================================================
  3987                              <1> main_do_boot_record:
  3988 00001C3B B340                <1>         mov bl, SIZE_OF_BOOTRECORD
  3989 00001C3D F6E3                <1>         mul bl
  3990                              <1> 
  3991 00001C3F BE[4000]            <1>         mov si, ADDR_SBMK_BOOT_RECORDS
  3992 00001C42 01C6                <1>         add si, ax
  3993                              <1> 
  3994 00001C44 8B1C                <1> 	mov bx, [si + struc_bootrecord.flags]
  3995                              <1> 
  3996 00001C46 F7C30800            <1> 	test bx, INFOFLAG_ISSPECIAL
  3997 00001C4A 7405                <1> 	jz .boot_drv_part
  3998                              <1> 
  3999 00001C4C E85B00              <1> 	call main_do_special_record
  4000 00001C4F EB58                <1> 	jmp short .end
  4001                              <1> 
  4002                              <1> .boot_drv_part:
  4003                              <1> %ifndef DISABLE_CDBOOT
  4004 00001C51 F7C31000            <1> 	test bx, DRVFLAG_ISCDROM
  4005 00001C55 743D                <1> 	jz .normal_boot
  4006                              <1> 
  4007 00001C57 8A5402              <1> 	mov dl, [si + struc_bootrecord.drive_id]
  4008 00001C5A BF[7422]            <1> 	mov di, knl_tmp.disk_buf2
  4009 00001C5D E82720              <1> 	call get_cdrom_boot_catalog
  4010 00001C60 723C                <1> 	jc .disk_error
  4011                              <1> 
  4012 00001C62 56                  <1> 	push si
  4013 00001C63 89FE                <1> 	mov si, di
  4014 00001C65 BF[741A]            <1> 	mov di, knl_tmp.disk_buf1
  4015 00001C68 E8951B              <1> 	call find_cdboot_catalog
  4016 00001C6B 5E                  <1> 	pop si
  4017                              <1> 
  4018 00001C6C 09C9                <1> 	or cx, cx
  4019 00001C6E 7432                <1> 	jz .no_system
  4020 00001C70 81F90100            <1> 	cmp cx, 1
  4021 00001C74 740F                <1> 	je .go_boot_cdrom
  4022                              <1> 
  4023 00001C76 56                  <1> 	push si
  4024 00001C77 89FE                <1> 	mov si, di
  4025 00001C79 E89201              <1> 	call main_choose_cdimg
  4026 00001C7C 5E                  <1> 	pop si
  4027 00001C7D 722A                <1> 	jc .end
  4028                              <1> 
  4029 00001C7F B120                <1> 	mov cl, SIZE_OF_BOOT_CATALOG
  4030 00001C81 F6E1                <1> 	mul cl
  4031                              <1> 
  4032 00001C83 01C7                <1> 	add di, ax
  4033                              <1> 
  4034                              <1> .go_boot_cdrom:
  4035 00001C85 52                  <1> 	push dx
  4036 00001C86 57                  <1> 	push di
  4037 00001C87 E8B01B              <1>         call preload_keystrokes     ; preload the keystrokes into key buffer.
  4038 00001C8A E82C04              <1>         call reset_video_mode
  4039 00001C8D 5F                  <1> 	pop di
  4040 00001C8E 5A                  <1> 	pop dx
  4041 00001C8F E80F1B              <1> 	call boot_cdrom
  4042 00001C92 EB03                <1> 	jmp short .boot_fail
  4043                              <1> 
  4044                              <1> %endif
  4045                              <1> 
  4046                              <1> .normal_boot:
  4047 00001C94 E84A1A              <1>         call boot_normal_record
  4048                              <1> 
  4049                              <1> .boot_fail:
  4050 00001C97 E81BFB              <1> 	call main_init_video
  4051                              <1> 
  4052 00001C9A 08C0                <1>         or al, al
  4053 00001C9C 7404                <1>         jz .no_system
  4054                              <1> 
  4055                              <1> .disk_error:
  4056 00001C9E E8FCFE              <1>         call main_show_disk_error
  4057 00001CA1 C3                  <1>         ret
  4058                              <1> 
  4059                              <1> .no_system:
  4060 00001CA2 8B36[5F4C]          <1>         mov si, [str_idx.no_system]
  4061 00001CA6 E84105              <1>         call error_box
  4062                              <1> 
  4063                              <1> .end:
  4064 00001CA9 C3                  <1>         ret
  4065                              <1>         
  4066                              <1> 
  4067                              <1> ;=============================================================================
  4068                              <1> ;main_do_special_record ---- execute a special boot record.
  4069                              <1> ;input:
  4070                              <1> ;      si ->  the boot record.
  4071                              <1> ;=============================================================================
  4072                              <1> main_do_special_record:
  4073 00001CAA E80C04              <1> 	call reset_video_mode
  4074 00001CAD 8A4404              <1> 	mov al, [si + struc_bootrecord.type]
  4075                              <1> 
  4076 00001CB0 3C02                <1> 	cmp al, SPREC_POWEROFF
  4077 00001CB2 7503                <1> 	jne .chk_rst
  4078 00001CB4 E85710              <1> 	call power_off
  4079                              <1> 
  4080                              <1> .chk_rst:
  4081 00001CB7 3C03                <1> 	cmp al, SPREC_RESTART
  4082 00001CB9 7503                <1> 	jne .chk_quit
  4083 00001CBB E87611              <1> 	call reboot
  4084                              <1> 
  4085                              <1> .chk_quit:
  4086 00001CBE 3C01                <1> 	cmp al, SPREC_QUIT
  4087 00001CC0 7502                <1> 	jne .chk_bootprev
  4088                              <1> 
  4089                              <1> %ifdef EMULATE_PROG
  4090                              <1>         mov ax, 0x4c00                          ; exit to dos
  4091                              <1>         int 0x21                                ;
  4092                              <1> %else
  4093 00001CC2 CD18                <1>         int 0x18                                ; return to BIOS
  4094                              <1> %endif
  4095                              <1> 
  4096                              <1> .chk_bootprev:
  4097 00001CC4 3C00                <1> 	cmp al, SPREC_BOOTPREV
  4098 00001CC6 7503                <1> 	jne .end
  4099 00001CC8 E8FF00              <1> 	call main_boot_prev_mbr
  4100                              <1> 
  4101                              <1> .end:
  4102 00001CCB C3                  <1> 	ret
  4103                              <1> 
  4104                              <1> ;=============================================================================
  4105                              <1> ;main_do_schedule ---- implement the schedule table
  4106                              <1> ;input:
  4107                              <1> ;      none
  4108                              <1> ;output:
  4109                              <1> ;      default_boot set to the scheduled record
  4110                              <1> ;=============================================================================
  4111                              <1> main_do_schedule:
  4112 00001CCC 60                  <1>         pusha
  4113 00001CCD E83A12              <1>         call get_realtime
  4114 00001CD0 723B                <1>         jc .end
  4115                              <1> 
  4116 00001CD2 A3[392D]            <1>         mov [main_tmp.schedule_begin], ax
  4117 00001CD5 8916[3D2D]          <1>         mov [main_tmp.schedule_day], dx
  4118 00001CD9 31C9                <1>         xor cx, cx
  4119 00001CDB BE[4000]            <1>         mov si, ADDR_SBMK_BOOT_RECORDS
  4120                              <1> 
  4121                              <1> .loop_check:
  4122 00001CDE F7040080            <1>         test word [si + struc_bootrecord.flags], INFOFLAG_SCHEDULED
  4123 00001CE2 741E                <1>         jz .check_next
  4124                              <1> 
  4125 00001CE4 E88614              <1>         call check_bootrecord
  4126 00001CE7 7219                <1>         jc .check_next
  4127                              <1> 
  4128 00001CE9 E85E19              <1>         call get_record_schedule
  4129                              <1> 
  4130 00001CEC 3906[392D]          <1>         cmp [main_tmp.schedule_begin], ax 
  4131 00001CF0 7210                <1>         jb .check_next
  4132 00001CF2 391E[392D]          <1>         cmp [main_tmp.schedule_begin], bx
  4133 00001CF6 770A                <1>         ja .check_next
  4134                              <1> 
  4135 00001CF8 8516[3D2D]          <1>         test dx, [main_tmp.schedule_day]
  4136 00001CFC 7404                <1>         jz .check_next
  4137                              <1> 
  4138 00001CFE 880E[2F00]          <1>         mov [ADDR_SBMK_DEFAULT_BOOT], cl
  4139                              <1> 
  4140                              <1> .check_next:
  4141 00001D02 FEC1                <1>         inc cl
  4142 00001D04 81C64000            <1>         add si, SIZE_OF_BOOTRECORD
  4143 00001D08 80F920              <1>         cmp cl, MAX_RECORD_NUM
  4144 00001D0B 72D1                <1>         jb .loop_check
  4145                              <1> 
  4146                              <1> .end:
  4147 00001D0D 61                  <1>         popa
  4148 00001D0E C3                  <1>         ret
  4149                              <1> 
  4150                              <1> ;=============================================================================
  4151                              <1> ;main_save_boot_manager ---- save boot manager to disk.
  4152                              <1> ;input:
  4153                              <1> ;      none
  4154                              <1> ;output:
  4155                              <1> ;      cf = 0 success
  4156                              <1> ;      cf = 1 failed
  4157                              <1> ;=============================================================================
  4158                              <1> main_save_boot_manager:
  4159 00001D0F 60                  <1> 	pusha
  4160 00001D10 06                  <1> 	push es
  4161 00001D11 1E                  <1> 	push ds
  4162                              <1> 
  4163                              <1> ; Backup the menus' pos
  4164 00001D12 A1[A049]            <1> 	mov ax, [main_windows_data.boot_menu + struc_window.win_pos]
  4165 00001D15 A3[FE0B]            <1> 	mov [ADDR_SBMK_BOOT_MENU_POS], ax
  4166 00001D18 A1[CB49]            <1> 	mov ax, [main_windows_data.main_menu + struc_window.win_pos]
  4167 00001D1B A3[000C]            <1> 	mov [ADDR_SBMK_MAIN_MENU_POS], ax
  4168 00001D1E A1[F649]            <1> 	mov ax, [main_windows_data.record_menu + struc_window.win_pos]
  4169 00001D21 A3[020C]            <1> 	mov [ADDR_SBMK_RECORD_MENU_POS], ax
  4170 00001D24 A1[214A]            <1> 	mov ax, [main_windows_data.sys_menu + struc_window.win_pos]
  4171 00001D27 A3[040C]            <1> 	mov [ADDR_SBMK_SYS_MENU_POS], ax
  4172                              <1> 
  4173                              <1> ;Copy data area to backup seg
  4174 00001D2A 31F6                <1> 	xor si, si
  4175 00001D2C 31FF                <1> 	xor di, di
  4176                              <1> 
  4177 00001D2E 680020              <1> 	push word KNLBACKUP_SEG
  4178 00001D31 07                  <1> 	pop es
  4179                              <1> 
  4180 00001D32 B9[060C]            <1> 	mov cx, sbm_start
  4181 00001D35 FC                  <1> 	cld
  4182 00001D36 F3A4                <1> 	rep movsb
  4183                              <1> 
  4184                              <1> ;calculate checksum
  4185 00001D38 06                  <1> 	push es
  4186 00001D39 1F                  <1> 	pop ds
  4187                              <1> 
  4188 00001D3A 31F6                <1> 	xor si, si
  4189 00001D3C 8B0E[0A00]          <1> 	mov cx, [ADDR_SBMK_TOTAL_SIZE]
  4190 00001D40 C606[0E00]00        <1> 	mov byte [ADDR_SBMK_CHECKSUM], 0
  4191 00001D45 E8DA12              <1> 	call calc_checksum                      ; calculate the checksum.
  4192 00001D48 F6DB                <1> 	neg bl
  4193 00001D4A 881E[0E00]          <1> 	mov [ADDR_SBMK_CHECKSUM], bl
  4194                              <1> 
  4195 00001D4E 8A16[1000]          <1> 	mov dl, [ADDR_SBMK_DRVID]
  4196 00001D52 8D36[1100]          <1> 	lea si, [ADDR_SBMK_BLOCK_MAP]
  4197 00001D56 B90500              <1> 	mov cx, SBM_SAVE_NBLKS
  4198 00001D59 31FF                <1> 	xor di, di
  4199                              <1> 
  4200 00001D5B 1F                  <1> 	pop ds
  4201                              <1> 
  4202                              <1> .loop_save_blk:
  4203 00001D5C 51                  <1> 	push cx
  4204                              <1> 
  4205 00001D5D AC                  <1> 	lodsb
  4206 00001D5E 88C1                <1> 	mov cl, al			; number of sectors for this block
  4207 00001D60 66AD                <1> 	lodsd
  4208 00001D62 6689C3              <1> 	mov ebx,eax			; lba address for this block
  4209                              <1>         
  4210 00001D65 B80103              <1> 	mov ax, ( INT13H_WRITE << 8 ) | 1 
  4211                              <1> 
  4212 00001D68 F8                  <1> 	clc
  4213 00001D69 09C9                <1> 	or cx, cx
  4214 00001D6B 7413                <1> 	jz .write_end
  4215                              <1> 
  4216                              <1> .loop_write:
  4217 00001D6D E8FA1E              <1> 	call disk_access
  4218 00001D70 720E                <1> 	jc .write_end
  4219                              <1>         
  4220 00001D72 81C70002            <1> 	add di, SECTOR_SIZE
  4221 00001D76 6643                <1> 	inc ebx
  4222 00001D78 E2F3                <1> 	loop .loop_write
  4223                              <1> 
  4224 00001D7A 59                  <1> 	pop cx
  4225 00001D7B E2DF                <1> 	loop .loop_save_blk
  4226                              <1> 
  4227 00001D7D F8                  <1> 	clc
  4228 00001D7E EB01                <1> 	jmp short .end
  4229                              <1> 
  4230                              <1> .write_end:
  4231 00001D80 59                  <1> 	pop cx
  4232                              <1> 
  4233                              <1> .end:
  4234 00001D81 07                  <1> 	pop es
  4235 00001D82 61                  <1> 	popa
  4236 00001D83 C3                  <1> 	ret
  4237                              <1> 
  4238                              <1> 
  4239                              <1> ;=============================================================================
  4240                              <1> ;main_hide_auto_hides ---- hide all partitions that marked auto hide,
  4241                              <1> ;                          except the focus record.
  4242                              <1> ;input:
  4243                              <1> ;      none
  4244                              <1> ;output:
  4245                              <1> ;      cf = 0 success
  4246                              <1> ;      cf = 1 failed
  4247                              <1> ;=============================================================================
  4248                              <1> main_hide_auto_hides:
  4249 00001D84 0FB60E[C049]        <1>         movzx cx, byte [GOOD_RECORD_NUMBER]
  4250 00001D89 08C9                <1>         or cl, cl                               ; if no good record then go to
  4251 00001D8B 7429                <1>         jz .end_ok                              ; init directly.
  4252                              <1> 
  4253 00001D8D 86E9                <1> 	xchg ch, cl
  4254                              <1>         
  4255                              <1> ; hide all auto hide partitions.
  4256                              <1> .loop_hide:
  4257 00001D8F 3A0E[C149]          <1>         cmp cl, [FOCUS_RECORD]                  ; do not hide the focus record.
  4258 00001D93 741B                <1>         je .not_hide
  4259                              <1> 
  4260 00001D95 51                  <1> 	push cx
  4261 00001D96 E866FE              <1> 	call main_get_record_pointer
  4262 00001D99 59                  <1> 	pop cx
  4263                              <1> 
  4264 00001D9A 8B04                <1>         mov ax, [si + struc_bootrecord.flags]
  4265 00001D9C A90004              <1>         test ax, INFOFLAG_AUTOHIDE
  4266 00001D9F 740F                <1>         jz .not_hide
  4267 00001DA1 A90002              <1>         test ax, INFOFLAG_HIDDEN
  4268 00001DA4 750A                <1>         jnz .not_hide
  4269                              <1> 
  4270 00001DA6 E8F517              <1>         call toggle_record_hidden
  4271 00001DA9 720D                <1>         jc .hidden_error
  4272                              <1> 
  4273 00001DAB E807FE              <1>         call main_recheck_same_records
  4274 00001DAE 720C                <1>         jc .disk_error
  4275                              <1> 
  4276                              <1> .not_hide:
  4277 00001DB0 FEC1                <1>         inc cl
  4278 00001DB2 38E9                <1>         cmp cl, ch
  4279 00001DB4 72D9                <1>         jb .loop_hide
  4280                              <1>         
  4281                              <1> .end_ok:
  4282 00001DB6 F8                  <1>         clc
  4283 00001DB7 C3                  <1>         ret
  4284                              <1>         
  4285                              <1> .hidden_error:
  4286 00001DB8 09C0                <1>         or ax, ax
  4287 00001DBA 7405                <1>         jz .cannot_hide
  4288                              <1> 
  4289                              <1> .disk_error:
  4290 00001DBC E8DEFD              <1>         call main_show_disk_error
  4291 00001DBF EB07                <1>         jmp short .end
  4292                              <1> 
  4293                              <1> .cannot_hide:
  4294 00001DC1 8B36[5D4C]          <1>         mov si, [str_idx.toggle_hid_failed]
  4295 00001DC5 E82204              <1>         call error_box
  4296                              <1> .end:
  4297 00001DC8 F9                  <1>         stc
  4298 00001DC9 C3                  <1>         ret
  4299                              <1> 
  4300                              <1> ;=============================================================================
  4301                              <1> ; main_boot_prev_mbr ---- boot previous MBR
  4302                              <1> ;=============================================================================
  4303                              <1> main_boot_prev_mbr:
  4304                              <1> ; read partition table
  4305 00001DCA 06                  <1>         push es
  4306 00001DCB 6631DB              <1>         xor ebx, ebx
  4307 00001DCE 8EC3                <1>         mov es, bx
  4308 00001DD0 8A16[1000]          <1>         mov dl, [ADDR_SBMK_DRVID]
  4309 00001DD4 BF007C              <1>         mov di, BOOT_OFF
  4310 00001DD7 B80102              <1>         mov ax, (INT13H_READ << 8) | 0x01
  4311 00001DDA E88D1E              <1>         call disk_access
  4312 00001DDD 07                  <1>         pop es
  4313 00001DDE 722A                <1>         jc .disk_failed
  4314                              <1> 
  4315 00001DE0 52                  <1>         push dx
  4316 00001DE1 57                  <1>         push di
  4317 00001DE2 E812F0              <1>         call main_ask_save_changes
  4318 00001DE5 E89CFF              <1>         call main_hide_auto_hides
  4319 00001DE8 E8CE02              <1>         call reset_video_mode
  4320 00001DEB 5F                  <1>         pop di
  4321 00001DEC 5A                  <1>         pop dx
  4322                              <1> 
  4323 00001DED E8411F              <1> 	call uninstall_myint13h
  4324                              <1> 
  4325                              <1> ; copy previous mbr to Boot Offset 0x7c00
  4326 00001DF0 FC                  <1>         cld
  4327 00001DF1 B9BE01              <1>         mov cx, SIZE_OF_MBR
  4328 00001DF4 8D36[FE09]          <1>         lea si, [ADDR_SBMK_PREVIOUS_MBR]
  4329 00001DF8 31C0                <1>         xor ax, ax
  4330 00001DFA 50                  <1>         push ax
  4331 00001DFB 07                  <1>         pop es
  4332 00001DFC F3A4                <1>         rep movsb
  4333                              <1> 
  4334 00001DFE 50                  <1>         push ax
  4335 00001DFF 1F                  <1>         pop ds
  4336                              <1> 
  4337 00001E00 31ED                <1>         xor bp, bp                          ; might help some boot problems
  4338 00001E02 B855AA              <1>         mov ax, BR_GOOD_FLAG                ; boot signature (just in case ...)
  4339 00001E05 EA007C0000          <1>         jmp 0:BOOT_OFF                      ; start boot sector
  4340                              <1> 
  4341                              <1> .disk_failed:
  4342 00001E0A E890FD              <1>         call main_show_disk_error
  4343                              <1> .end:
  4344 00001E0D C3                  <1>         ret
  4345                              <1> 
  4346                              <1> 
  4347                              <1> ;==============================================================================
  4348                              <1> ; CD-ROM Boot Stuff
  4349                              <1> ;==============================================================================
  4350                              <1> 
  4351                              <1> %ifndef DISABLE_CDBOOT
  4352                              <1> ;==============================================================================
  4353                              <1> ;main_choose_cdimg ---- let user choose a cdimg to boot
  4354                              <1> ;input ds:si -> buffer to store boot catalogs
  4355                              <1> ;      cl = number of entries
  4356                              <1> ;output cf =0 ok, al = user choice
  4357                              <1> ;       cf =1 cancel
  4358                              <1> ;==============================================================================
  4359                              <1> main_choose_cdimg:
  4360 00001E0E 53                  <1> 	push bx
  4361 00001E0F 51                  <1> 	push cx
  4362 00001E10 52                  <1> 	push dx
  4363 00001E11 56                  <1> 	push si
  4364                              <1> 
  4365 00001E12 31D2                <1> 	xor dx, dx
  4366 00001E14 8936[5D1E]          <1> 	mov [.catalogs_buf], si
  4367 00001E18 8A2E[B34B]          <1> 	mov ch, [size.list_box_win_height]
  4368 00001E1C BB[D74C]            <1> 	mov bx, str_idx.cdimg_menu_title
  4369                              <1> 
  4370 00001E1F BE[2C1E]            <1> 	mov si, .item_str_proc
  4371 00001E22 E85B08              <1> 	call list_box
  4372 00001E25 88C8                <1> 	mov al, cl
  4373                              <1> 
  4374 00001E27 5E                  <1> 	pop si
  4375 00001E28 5A                  <1> 	pop dx
  4376 00001E29 59                  <1> 	pop cx
  4377 00001E2A 5B                  <1> 	pop bx
  4378 00001E2B C3                  <1> 	ret
  4379                              <1> 
  4380                              <1> .item_str_proc:
  4381 00001E2C 8B36[5D1E]          <1> 	mov si, [.catalogs_buf]
  4382 00001E30 BF[BE35]            <1> 	mov di, main_tmp.dialog_buf
  4383 00001E33 57                  <1> 	push di
  4384 00001E34 B82000              <1> 	mov ax, SIZE_OF_BOOT_CATALOG
  4385 00001E37 F6E1                <1> 	mul cl
  4386 00001E39 01C6                <1> 	add si, ax
  4387                              <1> 
  4388 00001E3B 89C8                <1> 	mov ax, cx
  4389 00001E3D B102                <1> 	mov cl, 2
  4390 00001E3F E87E0D              <1> 	call itoa
  4391 00001E42 81C70200            <1> 	add di, 2
  4392 00001E46 B82E20              <1> 	mov ax, '. '
  4393 00001E49 FC                  <1> 	cld
  4394 00001E4A AB                  <1> 	stosw
  4395                              <1> 
  4396 00001E4B 0FB64401            <1> 	movzx ax, [si + struc_boot_catalog.media_type]
  4397                              <1> 
  4398 00001E4F D0E0                <1> 	shl al, 1
  4399                              <1> 
  4400 00001E51 BE[D94C]            <1> 	mov si, str_idx.cdimg_menu_strings
  4401 00001E54 01C6                <1> 	add si, ax
  4402 00001E56 8B34                <1> 	mov si, [si]
  4403 00001E58 E80C0E              <1> 	call strcpy
  4404 00001E5B 5E                  <1> 	pop si
  4405 00001E5C C3                  <1> 	ret
  4406                              <1> 
  4407 00001E5D 0000                <1> .catalogs_buf dw 0
  4408                              <1> 
  4409                              <1> %endif
  4410                              <1> 
  4411                              <1> %endif
  4412                                  %include "ui.asm"
  4413                              <1> ; asmsyntax=nasm
  4414                              <1> ;
  4415                              <1> ; ui.asm
  4416                              <1> ;
  4417                              <1> ; Functions for User Interface
  4418                              <1> ;
  4419                              <1> ; Copyright (C) 2000, Suzhe. See file COPYING for details.
  4420                              <1> ;
  4421                              <1> 
  4422                              <1> %ifndef HAVE_UI
  4423                              <1> 
  4424                              <1> %ifndef MAIN
  4425                              <1> %include "ui.h"
  4426                              <1> %include "evtcode.h"
  4427                              <1> %include "utils.asm"
  4428                              <1> 	section .text
  4429                              <1> %endif
  4430                              <1> 
  4431                              <1> %define HAVE_UI
  4432                              <1> %define DIRECT_DRAW
  4433                              <1> 
  4434                              <1> %define SCR_BUF_SEG0    0xB800
  4435                              <1> %define SCR_BUF_SEG1    0xB900
  4436                              <1> %define SCR_BUF_SEG2    0xBA00
  4437                              <1> %define SCR_PAGE_SEGS   0x0100
  4438                              <1> 
  4439                              <1> %define SCR_BAK_SEG     0x0900
  4440                              <1> %define BIOS_DATA_SEG   0x0040
  4441                              <1> 
  4442                              <1> %define BIOS_KEYSTAT_OFF 0x0017
  4443                              <1> 
  4444                              <1> %define WINDOW_DEF_ACTION_NUM  (window_def_action_table.end_of_table - window_def_action_table) / SIZE_OF_STRUC_ACTION
  4445                              <1> %define MENUBOX_DEF_ACTION_NUM  (menubox_def_action_table.end_of_table - menubox_def_action_table) / SIZE_OF_STRUC_ACTION
  4446                              <1> %define LISTBOX_ACTION_NUM  (listbox_action_table.end_of_table - listbox_action_table) / SIZE_OF_STRUC_ACTION
  4447                              <1> %define INPUTBOX_ACTION_NUM  (inputbox_action_table.end_of_table - inputbox_action_table) / SIZE_OF_STRUC_ACTION
  4448                              <1>       bits 16
  4449                              <1> 
  4450                              <1> 
  4451                              <1> ;=============================================================================
  4452                              <1> ; <<<<<<<<<<<<<<<<<<< Basic Drawing and Screen functions >>>>>>>>>>>>>>>>>>>>>
  4453                              <1> ;=============================================================================
  4454                              <1> 
  4455                              <1> %if 1
  4456                              <1> ;=============================================================================
  4457                              <1> ;draw_string_hl ---- Draw a zero ending string with highlighted characters 
  4458                              <1> ;                    at special position
  4459                              <1> ;input:
  4460                              <1> ;      bl = attribute for normal characters
  4461                              <1> ;           high 4 bit Background color and low 4 bit Foreground color
  4462                              <1> ;      bh = attribute for hightlight characters
  4463                              <1> ;      dh = start row
  4464                              <1> ;      dl = start column
  4465                              <1> ;      ds:si -> the string to be displayed
  4466                              <1> ;output:
  4467                              <1> ;      none
  4468                              <1> ;=============================================================================
  4469                              <1> draw_string:
  4470                              <1> draw_string_hl:
  4471 00001E5F 60                  <1>         pusha
  4472 00001E60 52                  <1>         push dx
  4473 00001E61 B90100              <1>         mov cx,1
  4474 00001E64 FC                  <1>         cld
  4475                              <1> .start:
  4476                              <1> 
  4477 00001E65 AC                  <1>         lodsb
  4478 00001E66 08C0                <1>         or al,al
  4479 00001E68 7419                <1>         jz .end
  4480                              <1> 
  4481 00001E6A 3C0D                <1>         cmp al,0x0d                ; if need Change row
  4482 00001E6C 7506                <1>         jne .no_cr
  4483 00001E6E 5A                  <1>         pop dx
  4484 00001E6F FEC6                <1>         inc dh
  4485 00001E71 52                  <1>         push dx
  4486 00001E72 EBF1                <1>         jmp short .start
  4487                              <1> 
  4488                              <1> .no_cr:
  4489 00001E74 3C7E                <1>         cmp al, '~'
  4490 00001E76 7504                <1>         jne .draw_it
  4491 00001E78 86FB                <1>         xchg bh, bl
  4492 00001E7A EB05                <1>         jmp short .next_char
  4493                              <1> 
  4494                              <1> .draw_it:
  4495 00001E7C E80700              <1>         call draw_char
  4496                              <1> 
  4497 00001E7F FEC2                <1>         inc dl
  4498                              <1> .next_char:
  4499 00001E81 EBE2                <1>         jmp short .start
  4500                              <1> .end:
  4501 00001E83 5A                  <1>         pop dx
  4502 00001E84 61                  <1>         popa
  4503 00001E85 C3                  <1>         ret
  4504                              <1> ;=============================================================================
  4505                              <1> %endif
  4506                              <1> 
  4507                              <1> %if 0
  4508                              <1> ;=============================================================================
  4509                              <1> ;draw_string ---- Draw a zero ending string at special position
  4510                              <1> ;input:
  4511                              <1> ;      bl = high 4 bit Background color and low 4 bit Foreground color
  4512                              <1> ;      dh = start row
  4513                              <1> ;      dl = start column
  4514                              <1> ;      ds:si -> the string to be displayed
  4515                              <1> ;output:
  4516                              <1> ;      none
  4517                              <1> ;=============================================================================
  4518                              <1> draw_string_hl:
  4519                              <1> draw_string:
  4520                              <1>         pusha
  4521                              <1>         push dx
  4522                              <1>         mov cx,1
  4523                              <1>         cld
  4524                              <1> .start:
  4525                              <1> 
  4526                              <1>         lodsb
  4527                              <1>         or al,al
  4528                              <1>         jz .end
  4529                              <1> 
  4530                              <1>         cmp al,0x0d                ; if need Change row
  4531                              <1>         jne .no_cr
  4532                              <1>         pop dx
  4533                              <1>         inc dh
  4534                              <1>         push dx
  4535                              <1>         jmp short .start
  4536                              <1> 
  4537                              <1> .no_cr:
  4538                              <1>         call draw_char
  4539                              <1> 
  4540                              <1>         inc dl
  4541                              <1>         jmp short .start
  4542                              <1> .end:
  4543                              <1>         pop dx
  4544                              <1>         popa
  4545                              <1>         ret
  4546                              <1> ;=============================================================================
  4547                              <1> %endif
  4548                              <1> 
  4549                              <1> ;=============================================================================
  4550                              <1> ;draw_char ---- Draw chars at special position
  4551                              <1> ;input:
  4552                              <1> ;      bl = high 4 bit Background color and low 4 bit Foreground color
  4553                              <1> ;      dh = start row
  4554                              <1> ;      dl = start column
  4555                              <1> ;      al = the char to be displayed
  4556                              <1> ;      cx = repeat times
  4557                              <1> ;output:
  4558                              <1> ;      none
  4559                              <1> ;=============================================================================
  4560                              <1> draw_char:
  4561                              <1> %ifdef DIRECT_DRAW                            ; directly write to video buffer
  4562 00001E86 60                  <1>         pusha
  4563 00001E87 06                  <1>         push es
  4564 00001E88 FC                  <1> 	cld
  4565                              <1> 
  4566 00001E89 88DC                <1>         mov ah, bl
  4567 00001E8B 50                  <1>         push ax
  4568                              <1> 
  4569 00001E8C FF36[EF2A]          <1> 	push word [ui_screen_bufseg]
  4570 00001E90 07                  <1> 	pop es
  4571                              <1> 
  4572 00001E91 A0[ED2A]            <1>         mov al, [ui_screen_width]
  4573 00001E94 F6E6                <1>         mul dh
  4574 00001E96 30F6                <1>         xor dh, dh
  4575 00001E98 01D0                <1>         add ax, dx
  4576 00001E9A D1E0                <1>         shl ax, 1
  4577 00001E9C 89C7                <1>         mov di, ax
  4578                              <1> 
  4579 00001E9E 58                  <1>         pop ax
  4580 00001E9F F3AB                <1>         rep stosw
  4581 00001EA1 07                  <1>         pop es
  4582 00001EA2 61                  <1>         popa
  4583                              <1> %else
  4584                              <1>         push bx
  4585                              <1>         mov ah,2
  4586                              <1>         mov bh, [ui_screen_page]
  4587                              <1>         int 0x10
  4588                              <1>         mov ah,0x09
  4589                              <1>         int 0x10
  4590                              <1>         pop bx
  4591                              <1> %endif
  4592 00001EA3 C3                  <1>         ret
  4593                              <1> ;=============================================================================
  4594                              <1> 
  4595                              <1> ;=============================================================================
  4596                              <1> ;clear_screen ---- clear a screen area
  4597                              <1> ;input:
  4598                              <1> ;      ch = row of top left corner
  4599                              <1> ;      cl = column of top left corner
  4600                              <1> ;      dh = row of bottom right corner
  4601                              <1> ;      dl = column of bottom right corner
  4602                              <1> ;      bh = attribute
  4603                              <1> ;output:
  4604                              <1> ;      none
  4605                              <1> ;=============================================================================
  4606                              <1> clear_screen:
  4607 00001EA4 60                  <1>         pusha
  4608                              <1> %ifdef DIRECT_DRAW
  4609 00001EA5 06                  <1>         push es
  4610 00001EA6 FC                  <1> 	cld
  4611                              <1> 
  4612 00001EA7 88FC                <1>         mov ah, bh
  4613 00001EA9 B020                <1>         mov al, ' '
  4614                              <1> 
  4615 00001EAB FF36[EF2A]          <1> 	push word [ui_screen_bufseg]
  4616 00001EAF 07                  <1> 	pop es
  4617                              <1> 
  4618 00001EB0 28CA                <1>         sub dl, cl
  4619 00001EB2 FEC2                <1>         inc dl
  4620                              <1> 
  4621                              <1> .loop_fill:
  4622 00001EB4 51                  <1>         push cx
  4623 00001EB5 50                  <1>         push ax
  4624                              <1> 
  4625 00001EB6 A0[ED2A]            <1>         mov al, [ui_screen_width]
  4626 00001EB9 F6E5                <1>         mul ch
  4627 00001EBB 30ED                <1>         xor ch, ch
  4628 00001EBD 01C8                <1>         add ax, cx
  4629 00001EBF D1E0                <1>         shl ax, 1
  4630 00001EC1 89C7                <1>         mov di, ax
  4631 00001EC3 88D1                <1>         mov cl, dl
  4632                              <1> 
  4633 00001EC5 58                  <1>         pop ax
  4634 00001EC6 F3AB                <1>         rep stosw
  4635 00001EC8 59                  <1>         pop cx
  4636 00001EC9 FEC5                <1>         inc ch
  4637 00001ECB 38F5                <1>         cmp ch, dh
  4638 00001ECD 76E5                <1>         jbe .loop_fill
  4639                              <1> 
  4640 00001ECF 07                  <1>         pop es
  4641                              <1> %else
  4642                              <1>         mov ax, 0x0600
  4643                              <1>         int 0x10
  4644                              <1> %endif
  4645 00001ED0 61                  <1>         popa
  4646 00001ED1 C3                  <1>         ret
  4647                              <1> 
  4648                              <1> ;=============================================================================
  4649                              <1> ;read_scrchar ---- read a char from the screen
  4650                              <1> ;input:
  4651                              <1> ;       dh = row
  4652                              <1> ;       dl = column
  4653                              <1> ;output:
  4654                              <1> ;       ax = char with attribute
  4655                              <1> ;=============================================================================
  4656                              <1> read_scrchar:
  4657                              <1> %ifdef DIRECT_DRAW
  4658 00001ED2 1E                  <1>         push ds
  4659 00001ED3 52                  <1>         push dx
  4660 00001ED4 56                  <1>         push si
  4661                              <1> 
  4662 00001ED5 A0[ED2A]            <1>         mov al, [ui_screen_width]
  4663 00001ED8 F6E6                <1>         mul dh
  4664 00001EDA 30F6                <1>         xor dh, dh
  4665 00001EDC 01D0                <1>         add ax, dx
  4666 00001EDE D1E0                <1>         shl ax, 1
  4667 00001EE0 89C6                <1>         mov si, ax
  4668                              <1> 
  4669 00001EE2 FF36[EF2A]          <1> 	push word [ui_screen_bufseg]
  4670 00001EE6 1F                  <1> 	pop ds
  4671                              <1> 
  4672 00001EE7 AD                  <1>         lodsw
  4673 00001EE8 5E                  <1>         pop si
  4674 00001EE9 5A                  <1>         pop dx
  4675 00001EEA 1F                  <1>         pop ds
  4676                              <1> %else
  4677                              <1>         push bx
  4678                              <1>         mov bh, [ui_screen_page]
  4679                              <1>         mov ah,0x02
  4680                              <1>         int 0x10
  4681                              <1>         mov ah,0x08
  4682                              <1>         int 0x10
  4683                              <1>         pop bx
  4684                              <1> %endif
  4685 00001EEB C3                  <1>         ret
  4686                              <1> 
  4687                              <1> %if 0
  4688                              <1> ;=============================================================================
  4689                              <1> ;draw_string_tty ---- Draw a string ending by zero ( tty mode )
  4690                              <1> ;input:
  4691                              <1> ;      ds:si -> string
  4692                              <1> ;output:
  4693                              <1> ;      none
  4694                              <1> ;=============================================================================
  4695                              <1> draw_string_tty:
  4696                              <1>         pusha
  4697                              <1>         cld
  4698                              <1> .draw1:
  4699                              <1>         lodsb
  4700                              <1>         or al, al
  4701                              <1>         jz .end
  4702                              <1>         mov bx,7
  4703                              <1>         mov ah,0x0e
  4704                              <1>         int 0x10
  4705                              <1>         jmp short .draw1
  4706                              <1> .end:
  4707                              <1>         popa
  4708                              <1>         ret
  4709                              <1> ;=============================================================================
  4710                              <1> %endif
  4711                              <1> 
  4712                              <1> ;=============================================================================
  4713                              <1> ;draw_window ---- Draw a framed window
  4714                              <1> ;input:
  4715                              <1> ;      ch = row of top left corner
  4716                              <1> ;      cl = column of top left corner
  4717                              <1> ;      dh = row of bottom right corner
  4718                              <1> ;      dl = column of bottom right corner
  4719                              <1> ;      bl = high 4 bit Background color and low 4 bit Foreground color
  4720                              <1> ;      bh = title attribute (define same as bl)
  4721                              <1> ;      ds:si -> title
  4722                              <1> ;output:
  4723                              <1> ;      none
  4724                              <1> ;=============================================================================
  4725                              <1> draw_window:
  4726 00001EEC 60                  <1>         pusha
  4727 00001EED 890E[742A]          <1>         mov [ui_tmp.left_col], cx          ;
  4728 00001EF1 8916[762A]          <1>         mov [ui_tmp.right_col], dx         ; save window pos and attribute
  4729 00001EF5 891E[782A]          <1>         mov [ui_tmp.frame_attr], bx        ;
  4730                              <1> 
  4731                              <1> ;Clear frame background
  4732 00001EF9 86FB                <1>         xchg bh,bl
  4733 00001EFB E8A6FF              <1>         call clear_screen
  4734                              <1> 
  4735 00001EFE 87D1                <1>         xchg dx,cx
  4736 00001F00 B90100              <1>         mov cx,1
  4737                              <1> 
  4738                              <1> ;Draw four corners
  4739 00001F03 8A1E[782A]          <1>         mov bl, [ui_tmp.frame_attr]
  4740 00001F07 803E[FA4B]02        <1>         cmp byte [draw_frame_method], 2             ; check draw method.
  4741 00001F0C 7204                <1>         jb .draw_top_corner
  4742 00001F0E 8A1E[792A]          <1>         mov bl, [ui_tmp.title_attr]
  4743                              <1> .draw_top_corner:
  4744 00001F12 A0[F64B]            <1>         mov al, [frame_char.tl_corner]
  4745 00001F15 E86EFF              <1>         call draw_char
  4746                              <1> 
  4747 00001F18 8A16[762A]          <1>         mov dl, [ui_tmp.right_col]
  4748 00001F1C A0[F74B]            <1>         mov al, [frame_char.tr_corner]
  4749 00001F1F E864FF              <1>         call draw_char
  4750                              <1> 
  4751 00001F22 8A1E[782A]          <1>         mov bl, [ui_tmp.frame_attr]
  4752 00001F26 8A36[772A]          <1>         mov dh, [ui_tmp.bottom_row]
  4753 00001F2A A0[F94B]            <1>         mov al, [frame_char.br_corner]
  4754 00001F2D E856FF              <1>         call draw_char
  4755                              <1>   
  4756 00001F30 8A16[742A]          <1>         mov dl, [ui_tmp.left_col]
  4757 00001F34 A0[F84B]            <1>         mov al, [frame_char.bl_corner]
  4758 00001F37 E84CFF              <1>         call draw_char
  4759                              <1> 
  4760                              <1> ;Draw bottom horizontal line
  4761 00001F3A FEC2                <1>         inc dl
  4762 00001F3C 8A0E[762A]          <1>         mov cl, [ui_tmp.right_col]
  4763 00001F40 28D1                <1>         sub cl, dl
  4764 00001F42 A0[F34B]            <1>         mov al, [frame_char.bottom]
  4765 00001F45 E83EFF              <1>         call draw_char
  4766                              <1> 
  4767                              <1> ;Draw top horizontal line
  4768 00001F48 8A1E[782A]          <1>         mov bl, [ui_tmp.frame_attr]
  4769 00001F4C 803E[FA4B]01        <1>         cmp byte [draw_frame_method], 1             ; check draw method.
  4770 00001F51 7204                <1>         jb .draw_top_line
  4771 00001F53 8A1E[792A]          <1>         mov bl, [ui_tmp.title_attr]
  4772                              <1> .draw_top_line:
  4773 00001F57 8A36[752A]          <1>         mov dh, [ui_tmp.top_row]
  4774 00001F5B A0[F24B]            <1>         mov al, [frame_char.top]
  4775 00001F5E E825FF              <1>         call draw_char
  4776                              <1> 
  4777                              <1> ;Draw title
  4778 00001F61 E8AA0C              <1>         call strlen
  4779 00001F64 09C9                <1>         or cx,cx
  4780 00001F66 741E                <1>         jz .no_title
  4781                              <1> 
  4782 00001F68 A0[762A]            <1>         mov al, [ui_tmp.right_col]
  4783 00001F6B 2A06[742A]          <1>         sub al, [ui_tmp.left_col]
  4784 00001F6F 28C8                <1>         sub al, cl
  4785 00001F71 FEC0                <1>         inc al
  4786 00001F73 D0E8                <1>         shr al,1
  4787 00001F75 8A16[742A]          <1>         mov dl, [ui_tmp.left_col]
  4788 00001F79 00C2                <1>         add dl,al
  4789 00001F7B 8A36[752A]          <1>         mov dh, [ui_tmp.top_row]
  4790                              <1> 
  4791 00001F7F 8A1E[792A]          <1>         mov bl, [ui_tmp.title_attr]
  4792 00001F83 E8D9FE              <1>         call draw_string
  4793                              <1> 
  4794                              <1> .no_title:
  4795                              <1> 
  4796                              <1> ;Draw vertical line
  4797 00001F86 8A1E[782A]          <1>         mov bl, [ui_tmp.frame_attr]
  4798 00001F8A 8A36[752A]          <1>         mov dh, [ui_tmp.top_row]
  4799 00001F8E FEC6                <1>         inc dh
  4800                              <1> 
  4801 00001F90 B90100              <1>         mov cx,1
  4802                              <1> 
  4803                              <1> .draw_vert_line:
  4804 00001F93 A0[F44B]            <1>         mov al, [frame_char.left]
  4805 00001F96 8A16[742A]          <1>         mov dl, [ui_tmp.left_col]
  4806 00001F9A E8E9FE              <1>         call draw_char
  4807 00001F9D A0[F54B]            <1>         mov al, [frame_char.right]
  4808 00001FA0 8A16[762A]          <1>         mov dl, [ui_tmp.right_col]
  4809 00001FA4 E8DFFE              <1>         call draw_char
  4810                              <1> 
  4811 00001FA7 FEC6                <1>         inc dh
  4812 00001FA9 3A36[772A]          <1>         cmp dh, [ui_tmp.bottom_row]
  4813 00001FAD 72E4                <1>         jb .draw_vert_line
  4814                              <1> 
  4815                              <1> ;Draw shadow
  4816 00001FAF B308                <1>         mov bl, 0x08
  4817 00001FB1 8A2E[772A]          <1>         mov ch, [ui_tmp.bottom_row]
  4818 00001FB5 8A0E[742A]          <1>         mov cl, [ui_tmp.left_col]
  4819 00001FB9 FEC5                <1>         inc ch
  4820 00001FBB 80C102              <1> 	add cl, 2
  4821 00001FBE 8A36[772A]          <1>         mov dh, [ui_tmp.bottom_row]
  4822 00001FC2 8A16[762A]          <1>         mov dl, [ui_tmp.right_col]
  4823 00001FC6 FEC6                <1>         inc dh
  4824 00001FC8 E81400              <1>         call draw_shadow
  4825 00001FCB 8A2E[752A]          <1>         mov ch, [ui_tmp.top_row]
  4826 00001FCF 8A0E[762A]          <1>         mov cl, [ui_tmp.right_col]
  4827 00001FD3 FEC5                <1>         inc ch
  4828 00001FD5 FEC1                <1>         inc cl
  4829 00001FD7 80C202              <1> 	add dl, 2
  4830 00001FDA E80200              <1>         call draw_shadow
  4831                              <1> 
  4832 00001FDD 61                  <1>         popa
  4833 00001FDE C3                  <1>         ret
  4834                              <1> ;=============================================================================
  4835                              <1> 
  4836                              <1> ;=============================================================================
  4837                              <1> ;draw_shadow ---- Draw shadow block
  4838                              <1> ;input:
  4839                              <1> ;      ch = row of top left corner
  4840                              <1> ;      cl = column of top left corner
  4841                              <1> ;      dh = row of bottom right corner
  4842                              <1> ;      dl = column of bottom right corner
  4843                              <1> ;      bl = high 4 bit Background color and low 4 bit Foreground color
  4844                              <1> ;output:
  4845                              <1> ;      none
  4846                              <1> ;=============================================================================
  4847                              <1> draw_shadow:
  4848 00001FDF 60                  <1>         pusha
  4849                              <1> .loop_row:
  4850 00001FE0 52                  <1>         push dx
  4851                              <1> .loop_col:
  4852 00001FE1 51                  <1>         push cx
  4853 00001FE2 B90100              <1>         mov cx,1
  4854 00001FE5 E8EAFE              <1>         call read_scrchar
  4855 00001FE8 E89BFE              <1>         call draw_char
  4856 00001FEB 59                  <1>         pop cx
  4857 00001FEC FECA                <1>         dec dl
  4858 00001FEE 38D1                <1>         cmp cl, dl
  4859 00001FF0 76EF                <1>         jbe .loop_col
  4860 00001FF2 5A                  <1>         pop dx
  4861 00001FF3 FECE                <1>         dec dh
  4862 00001FF5 38F5                <1>         cmp ch, dh
  4863 00001FF7 76E7                <1>         jbe .loop_row
  4864                              <1> 
  4865 00001FF9 61                  <1>         popa
  4866 00001FFA C3                  <1>         ret
  4867                              <1> ;=============================================================================
  4868                              <1> 
  4869                              <1> 
  4870                              <1> ;=============================================================================
  4871                              <1> ;set_video_mode ---- Set the Alphabet Video Mode
  4872                              <1> ;input:
  4873                              <1> ;      al = 0 , set screen resolution to 90x25,
  4874                              <1> ;           otherwise set to 80x25
  4875                              <1> ;      bl = character bit size ( 8 or 9 )
  4876                              <1> ;      cx = fonts number
  4877                              <1> ;      es:bp -> fonts data
  4878                              <1> ;output:
  4879                              <1> ;      none
  4880                              <1> ;=============================================================================
  4881                              <1> BIOS_CRT_COLS        equ 0x4A
  4882                              <1> BIOS_ADDR_6845       equ 0x63
  4883                              <1> 
  4884                              <1> set_video_mode:
  4885 00001FFB 06                  <1>         push es
  4886 00001FFC 53                  <1>         push bx
  4887 00001FFD 50                  <1>         push ax
  4888                              <1> 
  4889 00001FFE E8B800              <1>         call reset_video_mode
  4890                              <1> 
  4891                              <1> ;Establish CRTC vertical timing and cursor position in character matrix
  4892                              <1> ;and set user fonts table
  4893 00002001 09C9                <1>         or cx, cx
  4894 00002003 741E                <1>         jz .set_res                          ; no font data
  4895 00002005 09ED                <1>         or bp, bp
  4896 00002007 741A                <1>         jz .set_res                          ; no font data
  4897                              <1>         
  4898                              <1> .loop_set_fonts:                             ; set user defined chars
  4899 00002009 51                  <1>         push cx
  4900 0000200A 31C9                <1>         xor cx,cx
  4901 0000200C FEC1                <1>         inc cl
  4902 0000200E 260FB65600          <1>         movzx dx, byte [es:bp]
  4903 00002013 45                  <1>         inc bp
  4904 00002014 B80011              <1>         mov ax,0x1100
  4905 00002017 BB0010              <1>         mov bx,0x1000
  4906 0000201A CD10                <1>         int 0x10
  4907 0000201C 59                  <1>         pop cx
  4908 0000201D 81C51000            <1>         add bp, 16
  4909 00002021 E2E6                <1>         loop .loop_set_fonts
  4910                              <1> 
  4911                              <1> .set_res:
  4912 00002023 C606[ED2A]50        <1>         mov byte [ui_screen_width], 80
  4913 00002028 C606[EE2A]19        <1>         mov byte [ui_screen_height], 25
  4914                              <1> 
  4915 0000202D B84000              <1>         mov ax,0x40
  4916 00002030 8EC0                <1>         mov es,ax
  4917 00002032 58                  <1>         pop ax
  4918                              <1> 
  4919 00002033 08C0                <1>         or al,al
  4920 00002035 7540                <1>         jnz .skip_res_set
  4921                              <1> 
  4922 00002037 268B166300          <1>         mov dx,[es:BIOS_ADDR_6845]                   ; CRTC I/O port
  4923                              <1> 
  4924                              <1> ;Enable I/O writes to CRTC registers
  4925 0000203C B011                <1>         mov al,0x11
  4926 0000203E EE                  <1>         out dx,al
  4927 0000203F 42                  <1>         inc dx
  4928 00002040 EC                  <1>         in al,dx
  4929 00002041 4A                  <1>         dec dx
  4930 00002042 88C4                <1>         mov ah,al
  4931 00002044 B011                <1>         mov al,0x11
  4932 00002046 50                  <1>         push ax
  4933 00002047 80E47F              <1>         and ah,01111111b
  4934 0000204A EF                  <1>         out dx,ax
  4935                              <1> 
  4936                              <1> ;Establish CRTC horizontal timing
  4937 0000204B 8D36[DF2A]          <1>         lea si, [ui_VideoHorizParams]
  4938                              <1> 
  4939 0000204F B90700              <1>         mov cx,7
  4940                              <1>         
  4941 00002052 FC                  <1>         cld
  4942                              <1> .set_CRTC:
  4943 00002053 AD                  <1>         lodsw
  4944 00002054 EF                  <1>         out dx,ax
  4945 00002055 E2FC                <1>         loop .set_CRTC
  4946                              <1> 
  4947                              <1> ;write-protect CRTC registers
  4948 00002057 58                  <1>         pop ax
  4949 00002058 EF                  <1>         out dx,ax
  4950                              <1> 
  4951                              <1> ;Program the Sequencer and Attribute Controller for 9 dots per character
  4952                              <1>         
  4953 00002059 BAC403              <1>         mov dx, 0x3c4
  4954 0000205C B80001              <1>         mov ax, 0x0100
  4955 0000205F FA                  <1>         cli
  4956 00002060 EF                  <1>         out dx,ax
  4957                              <1> 
  4958 00002061 B80101              <1>         mov ax,0x0101
  4959 00002064 EF                  <1>         out dx,ax
  4960 00002065 B80003              <1>         mov ax,0x0300
  4961 00002068 EF                  <1>         out dx,ax
  4962 00002069 FB                  <1>         sti
  4963                              <1> 
  4964 0000206A BB1300              <1>         mov bx,0x0013
  4965 0000206D B80010              <1>         mov ax,0x1000
  4966 00002070 CD10                <1>         int 0x10
  4967                              <1> 
  4968 00002072 C606[ED2A]5A        <1>         mov byte [ui_screen_width], 90
  4969                              <1> .skip_res_set:
  4970                              <1> 
  4971                              <1> ;Program the Attribute Controller for 8- or 9-bit character codes
  4972 00002077 B80010              <1>         mov ax,0x1000
  4973 0000207A BB120F              <1>         mov bx,0x0f12
  4974 0000207D 5A                  <1>         pop dx
  4975 0000207E 80FA08              <1>         cmp dl,8
  4976 00002081 7402                <1>         je .svm01
  4977 00002083 B707                <1>         mov bh,7
  4978                              <1> .svm01:
  4979 00002085 CD10                <1>         int 0x10
  4980                              <1> 
  4981                              <1> ;Update video BIOS data area
  4982 00002087 A0[ED2A]            <1>         mov al,[ui_screen_width]
  4983 0000208A 26A24A00            <1>         mov [es:BIOS_CRT_COLS],al
  4984                              <1> 
  4985                              <1> ;Set background highlight attribute
  4986 0000208E 07                  <1>         pop es
  4987 0000208F B80310              <1>         mov ax,0x1003
  4988 00002092 30DB                <1>         xor bl,bl
  4989 00002094 CD10                <1>         int 0x10
  4990 00002096 E80C00              <1>         call hide_cursor
  4991                              <1> 
  4992 00002099 C3                  <1>         ret
  4993                              <1> ;=============================================================================
  4994                              <1> 
  4995                              <1> ;=============================================================================
  4996                              <1> ;set_cursor ---- move the cursor
  4997                              <1> ;input:
  4998                              <1> ;       dh = row
  4999                              <1> ;       dl = column
  5000                              <1> ;=============================================================================
  5001                              <1> set_cursor:
  5002 0000209A 60                  <1> 	pusha
  5003 0000209B 8A3E[F12A]          <1>         mov bh, [ui_screen_page]
  5004 0000209F B402                <1>         mov ah, 0x02
  5005 000020A1 CD10                <1>         int 0x10
  5006 000020A3 61                  <1> 	popa
  5007 000020A4 C3                  <1>         ret
  5008                              <1> 
  5009                              <1> ;=============================================================================
  5010                              <1> ;hide_cursor ---- Hide the cursor
  5011                              <1> ;input:
  5012                              <1> ;      none
  5013                              <1> ;output:
  5014                              <1> ;      none
  5015                              <1> ;=============================================================================
  5016                              <1> hide_cursor:
  5017 000020A5 60                  <1>         pusha
  5018 000020A6 B401                <1>         mov ah,1
  5019 000020A8 B9006F              <1>         mov cx,0x6f00
  5020 000020AB CD10                <1>         int 0x10
  5021 000020AD 61                  <1>         popa
  5022 000020AE C3                  <1>         ret
  5023                              <1> ;=============================================================================
  5024                              <1> 
  5025                              <1> ;=============================================================================
  5026                              <1> ;show_cursor ---- Show the cursor
  5027                              <1> ;input:
  5028                              <1> ;      none
  5029                              <1> ;output:
  5030                              <1> ;      none
  5031                              <1> ;=============================================================================
  5032                              <1> show_cursor:
  5033 000020AF 60                  <1>         pusha
  5034 000020B0 B401                <1>         mov ah,1
  5035 000020B2 B90F0E              <1>         mov cx,0x0e0f
  5036 000020B5 CD10                <1>         int 0x10
  5037 000020B7 61                  <1>         popa
  5038 000020B8 C3                  <1>         ret
  5039                              <1> ;=============================================================================
  5040                              <1> 
  5041                              <1> ;=============================================================================
  5042                              <1> ;reset_video_mode ---- Reset the VideoMode
  5043                              <1> ;input:
  5044                              <1> ;      none
  5045                              <1> ;output:
  5046                              <1> ;      none
  5047                              <1> ;=============================================================================
  5048                              <1> reset_video_mode
  5049 000020B9 60                  <1>         pusha
  5050 000020BA B80300              <1>         mov ax,3
  5051 000020BD CD10                <1>         int 0x10
  5052 000020BF E8EDFF              <1>         call show_cursor
  5053 000020C2 61                  <1>         popa
  5054 000020C3 C3                  <1>         ret
  5055                              <1> ;=============================================================================
  5056                              <1> 
  5057                              <1> 
  5058                              <1> ;=============================================================================
  5059                              <1> ;draw_icon ---- Draw a icon at special position
  5060                              <1> ;input:
  5061                              <1> ;      dh = start row
  5062                              <1> ;      dl = start column
  5063                              <1> ;      ch = number of row
  5064                              <1> ;      cl = number of column
  5065                              <1> ;      ds:si -> icon data , which is a two dim word array, each elements
  5066                              <1> ;               indicates a char. high byte is the attribute, low byte is
  5067                              <1> ;               is the char code.
  5068                              <1> ;output:
  5069                              <1> ;      none
  5070                              <1> ;=============================================================================
  5071                              <1> draw_icon:
  5072 000020C4 09F6                <1>         or si, si
  5073 000020C6 7422                <1>         jz .end
  5074 000020C8 09C9                <1>         or cx, cx
  5075 000020CA 741E                <1>         jz .end
  5076                              <1>         
  5077 000020CC 60                  <1>         pusha
  5078 000020CD FC                  <1>         cld
  5079                              <1> .loop_row:
  5080 000020CE 52                  <1>         push dx
  5081 000020CF 51                  <1>         push cx
  5082                              <1> .loop_col:
  5083 000020D0 51                  <1>         push cx
  5084 000020D1 B90100              <1>         mov cx,1
  5085 000020D4 AD                  <1>         lodsw
  5086 000020D5 86E3                <1>         xchg ah,bl
  5087 000020D7 E8ACFD              <1>         call draw_char
  5088                              <1>         
  5089 000020DA 59                  <1>         pop cx
  5090 000020DB FEC2                <1>         inc dl
  5091 000020DD FEC9                <1>         dec cl
  5092 000020DF 75EF                <1>         jnz .loop_col
  5093                              <1>         
  5094 000020E1 59                  <1>         pop cx
  5095 000020E2 5A                  <1>         pop dx
  5096 000020E3 FEC6                <1>         inc dh
  5097 000020E5 FECD                <1>         dec ch
  5098 000020E7 75E5                <1>         jnz .loop_row
  5099                              <1> 
  5100 000020E9 61                  <1>         popa
  5101                              <1> .end:
  5102 000020EA C3                  <1>         ret
  5103                              <1> ;=============================================================================
  5104                              <1> 
  5105                              <1> ;=============================================================================
  5106                              <1> ;draw_background ---- Draw the background using specified icon
  5107                              <1> ;input:
  5108                              <1> ;      bh = background color when no icon
  5109                              <1> ;      cx = icon size (ch = row, cl = col)
  5110                              <1> ;      ds:si -> icon data , which is a two dim word array, each elements
  5111                              <1> ;               indicates a char. high byte is the attribute, low byte is
  5112                              <1> ;               is the char code.
  5113                              <1> ;output:
  5114                              <1> ;      none
  5115                              <1> ;=============================================================================
  5116                              <1> draw_background:
  5117 000020EB 60                  <1>         pusha
  5118 000020EC 09F6                <1>         or si,si
  5119 000020EE 7513                <1>         jnz .normal_bg
  5120                              <1> 
  5121                              <1> ;no icon. clear background.
  5122 000020F0 31C9                <1>         xor cx,cx
  5123 000020F2 8A36[EE2A]          <1>         mov dh,[ui_screen_height]
  5124 000020F6 8A16[ED2A]          <1>         mov dl,[ui_screen_width]
  5125 000020FA FECE                <1>         dec dh
  5126 000020FC FECA                <1>         dec dl
  5127 000020FE E8A3FD              <1>         call clear_screen
  5128 00002101 61                  <1>         popa
  5129 00002102 C3                  <1>         ret
  5130                              <1> 
  5131                              <1> .normal_bg:
  5132 00002103 31D2                <1>         xor dx,dx
  5133                              <1> 
  5134                              <1> .loop_row:
  5135 00002105 52                  <1>         push dx
  5136                              <1> .loop_col:
  5137 00002106 E8BBFF              <1>         call draw_icon
  5138 00002109 00CA                <1>         add dl, cl
  5139 0000210B 3A16[ED2A]          <1>         cmp dl, [ui_screen_width]
  5140 0000210F 72F5                <1>         jb .loop_col
  5141 00002111 5A                  <1>         pop dx
  5142 00002112 00EE                <1>         add dh, ch
  5143 00002114 3A36[EE2A]          <1>         cmp dh, [ui_screen_height]
  5144 00002118 72EB                <1>         jb .loop_row
  5145 0000211A 61                  <1>         popa
  5146 0000211B C3                  <1>         ret
  5147                              <1> ;=============================================================================
  5148                              <1> 
  5149                              <1> ;=============================================================================
  5150                              <1> ;turnon_scrolllock ---- turn on the scroll lock key
  5151                              <1> ;input: none
  5152                              <1> ;output: none
  5153                              <1> ;=============================================================================
  5154                              <1> turnon_scrolllock:
  5155 0000211C 60                  <1>         pusha
  5156 0000211D 06                  <1>         push es
  5157 0000211E 684000              <1>         push word BIOS_DATA_SEG
  5158 00002121 07                  <1> 	pop es
  5159 00002122 26800E170010        <1>         or byte [es: BIOS_KEYSTAT_OFF], kbScrollMask
  5160 00002128 07                  <1>         pop es
  5161 00002129 61                  <1>         popa
  5162 0000212A C3                  <1>         ret
  5163                              <1> 
  5164                              <1> ;=============================================================================
  5165                              <1> ;turnoff_scrolllock ---- turn off the scroll lock key
  5166                              <1> ;input: none
  5167                              <1> ;output: none
  5168                              <1> ;=============================================================================
  5169                              <1> turnoff_scrolllock:
  5170 0000212B 60                  <1>         pusha
  5171 0000212C 06                  <1>         push es
  5172 0000212D 684000              <1>         push word BIOS_DATA_SEG
  5173 00002130 07                  <1> 	pop es
  5174 00002131 2680261700EF        <1>         and byte [es: BIOS_KEYSTAT_OFF], ~ kbScrollMask
  5175 00002137 07                  <1>         pop es
  5176 00002138 61                  <1>         popa
  5177 00002139 C3                  <1>         ret
  5178                              <1> 
  5179                              <1> ;=============================================================================
  5180                              <1> ;lock_screen ---- lock the screen, any output will be stored in SCR_BAK_SEG
  5181                              <1> ;=============================================================================
  5182                              <1> lock_screen:
  5183 0000213A 60                  <1> 	pusha 
  5184 0000213B 803E[F22A]00        <1> 	cmp byte [ui_screen_lock], 0
  5185 00002140 7518                <1> 	jnz .no_swap_page
  5186                              <1> 
  5187 00002142 A0[F12A]            <1>         mov al, [ui_screen_page]
  5188 00002145 3402                <1>         xor al, 0x02
  5189 00002147 C706[EF2A]00B8      <1>         mov word [ui_screen_bufseg], SCR_BUF_SEG0
  5190 0000214D 08C0                <1>         or al, al
  5191 0000214F 7406                <1>         jz .set_seg0
  5192 00002151 C706[EF2A]00BA      <1>         mov word [ui_screen_bufseg], SCR_BUF_SEG2
  5193                              <1> .set_seg0:
  5194 00002157 A2[F12A]            <1>         mov [ui_screen_page], al
  5195                              <1> 
  5196                              <1> .no_swap_page:
  5197 0000215A FE06[F22A]          <1> 	inc byte [ui_screen_lock]
  5198 0000215E 61                  <1> 	popa
  5199 0000215F C3                  <1>         ret
  5200                              <1> 
  5201                              <1> ;=============================================================================
  5202                              <1> ;unlock_screen ---- unlock the screen, copy SCR_BAK_SEG to SCR_BUF_SEG
  5203                              <1> ;=============================================================================
  5204                              <1> unlock_screen:
  5205 00002160 60                  <1> 	pusha
  5206 00002161 FE0E[F22A]          <1> 	dec byte [ui_screen_lock]
  5207 00002165 7507                <1> 	jnz .no_swap_page
  5208                              <1> 
  5209 00002167 B405                <1>         mov ah, 0x05
  5210 00002169 A0[F12A]            <1>         mov al, [ui_screen_page]
  5211 0000216C CD10                <1>         int 0x10
  5212                              <1> .no_swap_page:
  5213 0000216E 61                  <1> 	popa
  5214 0000216F C3                  <1>         ret
  5215                              <1> 
  5216                              <1> 
  5217                              <1> ;=============================================================================
  5218                              <1> ;<<<<<<<<<<<<<<<<<<<<<<<<< Standard Dialog functions >>>>>>>>>>>>>>>>>>>>>>>>>
  5219                              <1> ;=============================================================================
  5220                              <1> 
  5221                              <1> ;=============================================================================
  5222                              <1> ; msgbox_draw_body_proc ---- draw body proc of message box
  5223                              <1> ; input:
  5224                              <1> ;	ds:si -> the window
  5225                              <1> ; output:
  5226                              <1> ;	none
  5227                              <1> ;=============================================================================
  5228                              <1> msgbox_draw_body_proc:
  5229 00002170 60                  <1> 	pusha
  5230 00002171 89F7                <1> 	mov di, si
  5231 00002173 8B5C1C              <1> 	mov bx, [si + struc_message_box.message_attr]
  5232 00002176 BA0302              <1> 	mov dx, 0x0203
  5233 00002179 8B741A              <1> 	mov si, [si + struc_message_box.message]
  5234 0000217C E8C505              <1> 	call window_draw_string
  5235 0000217F 61                  <1> 	popa
  5236 00002180 C3                  <1> 	ret
  5237                              <1> 
  5238                              <1> ;=============================================================================
  5239                              <1> ; msgbox_default_event_handle ---- default event handle for message box
  5240                              <1> ; input:
  5241                              <1> ;	ax    -> event
  5242                              <1> ;	ds:si -> the window
  5243                              <1> ; output:
  5244                              <1> ;	none
  5245                              <1> ;=============================================================================
  5246                              <1> msgbox_default_event_handle:
  5247 00002181 E8C007              <1> 	call window_default_event_handle
  5248 00002184 730D                <1> 	jnc .end
  5249                              <1> 
  5250 00002186 80FCF0              <1> 	cmp ah, EVTCODE_COMMAND
  5251 00002189 7202                <1> 	jb .exit
  5252                              <1> 
  5253 0000218B F9                  <1> 	stc
  5254 0000218C C3                  <1> 	ret
  5255                              <1> 
  5256                              <1> .exit:
  5257 0000218D 89441E              <1> 	mov [si + struc_message_box.pressed_key], ax
  5258 00002190 E82B07              <1> 	call window_close
  5259                              <1> .end:
  5260 00002193 F8                  <1> 	clc
  5261 00002194 C3                  <1> 	ret
  5262                              <1> 
  5263                              <1> ;=============================================================================
  5264                              <1> ; msgbox_prepare ---- prepare a message box
  5265                              <1> ; input:
  5266                              <1> ;	al    =  message attribute
  5267                              <1> ;	bx    =  window attribute
  5268                              <1> ;	ds:dx -> 2nd level pointer to title
  5269                              <1> ;	ds:si -> message
  5270                              <1> ;	ds:di -> pointer to the struc_message_box
  5271                              <1> ; output:
  5272                              <1> ;	none
  5273                              <1> ;=============================================================================
  5274                              <1> msgbox_prepare:
  5275 00002195 60                  <1> 	pusha
  5276 00002196 B92000              <1> 	mov cx, SIZE_OF_STRUC_MESSAGE_BOX
  5277 00002199 E8950E              <1> 	call clear_memory
  5278                              <1> 
  5279 0000219C 89751A              <1> 	mov [di + struc_message_box.message], si
  5280 0000219F 89451C              <1> 	mov [di + struc_message_box.message_attr], ax
  5281 000021A2 895D04              <1> 	mov [di + struc_window.win_attr], bx
  5282 000021A5 895502              <1> 	mov [di + struc_window.title], dx
  5283                              <1> 
  5284 000021A8 E8300B              <1> 	call count_lines
  5285                              <1> 
  5286 000021AB 020E[B04B]          <1> 	add cl, [size.box_width]
  5287 000021AF 022E[B14B]          <1> 	add ch, [size.box_height]
  5288 000021B3 894D08              <1> 	mov [di + struc_window.win_size], cx
  5289 000021B6 87F7                <1> 	xchg si, di
  5290 000021B8 E87407              <1> 	call window_center_window
  5291                              <1> 
  5292 000021BB C60406              <1> 	mov byte [si], WINFLAG_FRAMED | WINFLAG_MODAL
  5293                              <1> 
  5294 000021BE C74414[8121]        <1> 	mov word [si + struc_window.default_event_handle], msgbox_default_event_handle
  5295 000021C3 C7841600[5029]      <1> 	mov word [si + struc_window.event_handle], window_event_handle
  5296 000021C9 C74418[7021]        <1> 	mov word [si + struc_window.draw_body_proc], msgbox_draw_body_proc
  5297 000021CE 61                  <1> 	popa
  5298 000021CF C3                  <1> 	ret
  5299                              <1> 
  5300                              <1> 
  5301                              <1> ;=============================================================================
  5302                              <1> ;message_box ---- Show a message box
  5303                              <1> ;input:
  5304                              <1> ;	al = message attribute
  5305                              <1> ;	bx = window attribute
  5306                              <1> ;	ds:dx -> 2nd level pointer to title
  5307                              <1> ;	ds:si -> message
  5308                              <1> ;output:
  5309                              <1> ;	ax = user pressed key
  5310                              <1> ;=============================================================================
  5311                              <1> message_box:
  5312 000021D0 56                  <1> 	push si
  5313 000021D1 57                  <1> 	push di
  5314 000021D2 BF[982A]            <1> 	mov di, ui_tmp.tmp_msgbox
  5315 000021D5 87F7                <1> 	xchg si, di
  5316 000021D7 E85208              <1> 	call winlist_remove
  5317 000021DA 87F7                <1> 	xchg si, di
  5318 000021DC E8B6FF              <1> 	call msgbox_prepare
  5319 000021DF 87F7                <1> 	xchg si, di
  5320 000021E1 E88206              <1> 	call window_run
  5321 000021E4 8B441E              <1> 	mov ax, [si + struc_message_box.pressed_key]
  5322 000021E7 5F                  <1> 	pop di
  5323 000021E8 5E                  <1> 	pop si
  5324 000021E9 C3                  <1>         ret
  5325                              <1> ;=============================================================================
  5326                              <1> 
  5327                              <1> ;=============================================================================
  5328                              <1> ;error_box ---- draw error message box.
  5329                              <1> ;input:
  5330                              <1> ;      ds:si -> error message
  5331                              <1> ;output:
  5332                              <1> ;      ax = return keycode
  5333                              <1> ;=============================================================================
  5334                              <1> error_box:
  5335 000021EA 53                  <1>         push bx
  5336 000021EB 52                  <1>         push dx
  5337 000021EC A0[D24B]            <1>         mov al, [color.error_box_msg]
  5338 000021EF 8B1E[D04B]          <1>         mov bx, [color.error_box_frame]
  5339 000021F3 BA[0B4C]            <1>         mov dx, str_idx.error
  5340 000021F6 E8D7FF              <1>         call message_box
  5341 000021F9 5A                  <1>         pop dx
  5342 000021FA 5B                  <1>         pop bx
  5343 000021FB C3                  <1>         ret
  5344                              <1> 
  5345                              <1> ;=============================================================================
  5346                              <1> ;info_box ---- draw infomation message box.
  5347                              <1> ;input:
  5348                              <1> ;      ds:si -> infomation message
  5349                              <1> ;output:
  5350                              <1> ;      ax = return keycode
  5351                              <1> ;=============================================================================
  5352                              <1> info_box:
  5353 000021FC 53                  <1>         push bx
  5354 000021FD 52                  <1>         push dx
  5355 000021FE A0[D54B]            <1>         mov al, [color.info_box_msg]
  5356 00002201 8B1E[D34B]          <1>         mov bx, [color.info_box_frame]
  5357 00002205 BA[0F4C]            <1>         mov dx, str_idx.info
  5358 00002208 E8C5FF              <1>         call message_box
  5359 0000220B 5A                  <1>         pop dx
  5360 0000220C 5B                  <1>         pop bx
  5361 0000220D C3                  <1>         ret
  5362                              <1> 
  5363                              <1> ;=============================================================================
  5364                              <1> ; inputbox_set_cursor
  5365                              <1> ; input:
  5366                              <1> ;	ds:si -> input box
  5367                              <1> ; output:
  5368                              <1> ;	none
  5369                              <1> ;=============================================================================
  5370                              <1> inputbox_set_cursor:
  5371 0000220E 8B5424              <1> 	mov dx, [si + struc_input_box.input_area_pos]
  5372 00002211 025427              <1> 	add dl, [si + struc_input_box.input_curp]
  5373 00002214 2A5426              <1> 	sub dl, [si + struc_input_box.input_startp]
  5374 00002217 E80E05              <1> 	call window_set_cursor
  5375 0000221A E892FE              <1> 	call show_cursor
  5376 0000221D C3                  <1> 	ret
  5377                              <1> 	
  5378                              <1> ;=============================================================================
  5379                              <1> ; inputbox_draw_body_proc ---- draw_body_proc of input box
  5380                              <1> ; input:
  5381                              <1> ;	ds:si -> pointer to struc_input_box
  5382                              <1> ; output:
  5383                              <1> ;	none
  5384                              <1> ;=============================================================================
  5385                              <1> inputbox_draw_body_proc:
  5386 0000221E 60                  <1> 	pusha
  5387 0000221F 89F7                <1> 	mov di, si
  5388 00002221 8B5C1C              <1> 	mov bx, [si + struc_input_box.message_attr]
  5389 00002224 BA0202              <1> 	mov dx, 0x0202
  5390 00002227 8B741A              <1> 	mov si, [si + struc_input_box.message]
  5391 0000222A E81705              <1> 	call window_draw_string
  5392 0000222D 61                  <1> 	popa
  5393 0000222E E80400              <1> 	call inputbox_draw_input_area
  5394 00002231 E8DAFF              <1> 	call inputbox_set_cursor
  5395 00002234 C3                  <1> 	ret
  5396                              <1> 
  5397                              <1> ;=============================================================================
  5398                              <1> ; inputbox_draw_input_area ---- draw the input area of a input box
  5399                              <1> ; input:
  5400                              <1> ;	ds:si -> pointer to struc_input_box
  5401                              <1> ; output:
  5402                              <1> ;	none
  5403                              <1> ;=============================================================================
  5404                              <1> inputbox_draw_input_area:
  5405 00002235 60                  <1> 	pusha
  5406 00002236 0FB64C23            <1> 	movzx cx, byte [si + struc_input_box.input_area_len]
  5407 0000223A 8B5424              <1> 	mov dx, [si + struc_input_box.input_area_pos]
  5408 0000223D B020                <1> 	mov al, 0x20
  5409 0000223F 8A5C1E              <1> 	mov bl, [si + struc_input_box.input_attr]
  5410 00002242 E8F104              <1> 	call window_draw_char
  5411                              <1> 
  5412 00002245 0FB64426            <1> 	movzx ax, byte [si + struc_input_box.input_startp]
  5413 00002249 8B7C20              <1> 	mov di, [si + struc_input_box.input_buf]
  5414 0000224C 01C7                <1> 	add di, ax
  5415 0000224E 8A7C1F              <1> 	mov bh, [si + struc_input_box.input_type]
  5416                              <1> 
  5417                              <1> .loop_draw:
  5418 00002251 8A05                <1> 	mov al, [di]
  5419 00002253 08C0                <1> 	or al, al
  5420 00002255 7412                <1> 	jz .end_draw
  5421 00002257 08FF                <1> 	or bh, bh
  5422 00002259 7402                <1> 	jz .draw_normal
  5423 0000225B B02A                <1> 	mov al, '*'
  5424                              <1> .draw_normal:
  5425 0000225D 51                  <1> 	push cx
  5426 0000225E B101                <1> 	mov cl, 1
  5427 00002260 E8D304              <1> 	call window_draw_char
  5428 00002263 59                  <1> 	pop cx
  5429 00002264 FEC2                <1> 	inc dl
  5430 00002266 47                  <1> 	inc di
  5431 00002267 E2E8                <1> 	loop .loop_draw
  5432                              <1> 
  5433                              <1> .end_draw:
  5434 00002269 61                  <1> 	popa
  5435 0000226A C3                  <1> 	ret
  5436                              <1> 
  5437                              <1> 
  5438                              <1> ;=============================================================================
  5439                              <1> ; inputbox_get_strlen 
  5440                              <1> ; input:
  5441                              <1> ;	ds:si -> input box
  5442                              <1> ; output:
  5443                              <1> ;	cx = input buf strlen
  5444                              <1> ;=============================================================================
  5445                              <1> inputbox_get_strlen:
  5446 0000226B 56                  <1> 	push si
  5447 0000226C 8B7420              <1> 	mov si, [si + struc_input_box.input_buf]
  5448 0000226F E89C09              <1> 	call strlen
  5449 00002272 5E                  <1> 	pop si
  5450 00002273 C3                  <1> 	ret
  5451                              <1> 
  5452                              <1> ;=============================================================================
  5453                              <1> ; inputbox_delete_char
  5454                              <1> ; input:
  5455                              <1> ;	ds:si -> input box
  5456                              <1> ;	cl = position to be deleted
  5457                              <1> ; output:
  5458                              <1> ;	none
  5459                              <1> ;=============================================================================
  5460                              <1> inputbox_delete_char:
  5461 00002274 60                  <1> 	pusha
  5462 00002275 30ED                <1> 	xor ch, ch
  5463 00002277 8B7C20              <1> 	mov di, [si + struc_input_box.input_buf]
  5464 0000227A 01CF                <1> 	add di, cx
  5465 0000227C 89FE                <1> 	mov si, di
  5466 0000227E 803C00              <1> 	cmp byte [si], 0
  5467 00002281 7406                <1> 	jz .end
  5468 00002283 46                  <1> 	inc si
  5469 00002284 B1FF                <1> 	mov cl, 255
  5470 00002286 E8C409              <1> 	call strncpy
  5471                              <1> .end:
  5472 00002289 61                  <1> 	popa
  5473 0000228A C3                  <1> 	ret
  5474                              <1> 
  5475                              <1> ;=============================================================================
  5476                              <1> ; inputbox_post_input
  5477                              <1> ;=============================================================================
  5478                              <1> inputbox_post_input:
  5479 0000228B 8A4427              <1> 	mov al, [si + struc_input_box.input_curp]
  5480 0000228E 8A4C26              <1> 	mov cl, [si + struc_input_box.input_startp]
  5481 00002291 38C1                <1> 	cmp cl, al
  5482 00002293 7205                <1> 	jb .below_cur
  5483 00002295 884426              <1> 	mov [si + struc_input_box.input_startp], al
  5484 00002298 EB0D                <1> 	jmp short .end
  5485                              <1> 
  5486                              <1> .below_cur:
  5487 0000229A 28C8                <1> 	sub al, cl
  5488 0000229C 3A4423              <1> 	cmp al, [si + struc_input_box.input_area_len]
  5489 0000229F 7606                <1> 	jbe .end
  5490 000022A1 2A4423              <1> 	sub al, [si + struc_input_box.input_area_len]
  5491 000022A4 004426              <1> 	add [si + struc_input_box.input_startp], al
  5492                              <1> .end:
  5493 000022A7 C3                  <1> 	ret
  5494                              <1> 
  5495                              <1> ;=============================================================================
  5496                              <1> ; inputbox_backspace 
  5497                              <1> ;=============================================================================
  5498                              <1> inputbox_backspace:
  5499 000022A8 E8C0FF              <1> 	call inputbox_get_strlen
  5500 000022AB 09C9                <1> 	or cx, cx
  5501 000022AD 7412                <1> 	jz .end
  5502 000022AF 8A4C27              <1> 	mov cl, [si + struc_input_box.input_curp]
  5503 000022B2 08C9                <1> 	or cl, cl
  5504 000022B4 740B                <1> 	jz .end
  5505 000022B6 FEC9                <1> 	dec cl
  5506 000022B8 884C27              <1> 	mov [si + struc_input_box.input_curp], cl
  5507 000022BB E8B6FF              <1> 	call inputbox_delete_char
  5508 000022BE E8CAFF              <1> 	call inputbox_post_input
  5509                              <1> .end:
  5510 000022C1 C3                  <1> 	ret
  5511                              <1> 
  5512                              <1> ;=============================================================================
  5513                              <1> ; inputbox_delete
  5514                              <1> ;=============================================================================
  5515                              <1> inputbox_delete:
  5516 000022C2 E8A6FF              <1> 	call inputbox_get_strlen
  5517 000022C5 09C9                <1> 	or cx, cx
  5518 000022C7 7409                <1> 	jz .end
  5519 000022C9 8A4C27              <1> 	mov cl, [si + struc_input_box.input_curp]
  5520 000022CC E8A5FF              <1> 	call inputbox_delete_char
  5521 000022CF E8B9FF              <1> 	call inputbox_post_input
  5522                              <1> .end:
  5523 000022D2 C3                  <1> 	ret
  5524                              <1> 
  5525                              <1> ;=============================================================================
  5526                              <1> ; inputbox_right_arrow
  5527                              <1> ;=============================================================================
  5528                              <1> inputbox_right_arrow:
  5529 000022D3 E895FF              <1> 	call inputbox_get_strlen
  5530 000022D6 3A4C27              <1> 	cmp cl, [si + struc_input_box.input_curp]
  5531 000022D9 7606                <1> 	jbe .end
  5532                              <1> 
  5533 000022DB FE4427              <1> 	inc byte [si + struc_input_box.input_curp]
  5534 000022DE E8AAFF              <1> 	call inputbox_post_input
  5535                              <1> .end:
  5536 000022E1 C3                  <1> 	ret
  5537                              <1> 
  5538                              <1> ;=============================================================================
  5539                              <1> ; inputbox_left_arrow
  5540                              <1> ;=============================================================================
  5541                              <1> inputbox_left_arrow:
  5542 000022E2 807C2700            <1> 	cmp byte [si + struc_input_box.input_curp], 0
  5543 000022E6 7406                <1> 	jz .end
  5544                              <1> 
  5545 000022E8 FE4C27              <1> 	dec byte [si + struc_input_box.input_curp]
  5546 000022EB E89DFF              <1> 	call inputbox_post_input
  5547                              <1> .end:
  5548 000022EE C3                  <1> 	ret
  5549                              <1> 
  5550                              <1> ;=============================================================================
  5551                              <1> ; inputbox_end_key
  5552                              <1> ;=============================================================================
  5553                              <1> inputbox_end_key:
  5554 000022EF E879FF              <1> 	call inputbox_get_strlen
  5555 000022F2 884C27              <1> 	mov [si + struc_input_box.input_curp], cl
  5556 000022F5 E893FF              <1> 	call inputbox_post_input
  5557 000022F8 C3                  <1> 	ret
  5558                              <1> 
  5559                              <1> ;=============================================================================
  5560                              <1> ; inputbox_home_key
  5561                              <1> ;=============================================================================
  5562                              <1> inputbox_home_key:
  5563 000022F9 C6442700            <1> 	mov byte [si + struc_input_box.input_curp], 0
  5564 000022FD E88BFF              <1> 	call inputbox_post_input
  5565 00002300 C3                  <1> 	ret
  5566                              <1> 
  5567                              <1> 
  5568                              <1> ;=============================================================================
  5569                              <1> ; inputbox_cancel
  5570                              <1> ;=============================================================================
  5571                              <1> inputbox_cancel:
  5572 00002301 C6442801            <1> 	mov byte [si + struc_input_box.return_val], 1
  5573 00002305 E89DFD              <1> 	call hide_cursor
  5574 00002308 C3                  <1> 	ret
  5575                              <1> 
  5576                              <1> ;=============================================================================
  5577                              <1> ; inputbox_enter
  5578                              <1> ;=============================================================================
  5579                              <1> inputbox_enter:
  5580 00002309 C6442800            <1> 	mov byte [si + struc_input_box.return_val], 0
  5581 0000230D E895FD              <1> 	call hide_cursor
  5582 00002310 C3                  <1> 	ret
  5583                              <1> 
  5584                              <1> ;=============================================================================
  5585                              <1> ; inputbox_insert_char
  5586                              <1> ; input:
  5587                              <1> ;	al = char
  5588                              <1> ;	cl = position
  5589                              <1> ;	ds:si -> input box
  5590                              <1> ;=============================================================================
  5591                              <1> inputbox_insert_char:
  5592 00002311 60                  <1> 	pusha
  5593 00002312 30ED                <1> 	xor ch, ch
  5594 00002314 51                  <1> 	push cx
  5595 00002315 E853FF              <1> 	call inputbox_get_strlen
  5596 00002318 8B7420              <1> 	mov si, [si + struc_input_box.input_buf]
  5597 0000231B 01CE                <1> 	add si, cx
  5598 0000231D 5A                  <1> 	pop dx
  5599 0000231E 29D1                <1> 	sub cx, dx
  5600 00002320 09C9                <1> 	or cx, cx
  5601 00002322 7408                <1> 	jz .no_move
  5602                              <1> 
  5603                              <1> .loop_move:
  5604 00002324 8A24                <1> 	mov ah, [si]
  5605 00002326 886401              <1> 	mov [si + 1], ah
  5606 00002329 4E                  <1> 	dec si
  5607 0000232A E2F8                <1> 	loop .loop_move
  5608                              <1> 
  5609                              <1> .no_move:
  5610 0000232C 8A24                <1> 	mov ah, [si]
  5611 0000232E 8904                <1> 	mov [si], ax
  5612 00002330 61                  <1> 	popa
  5613 00002331 C3                  <1> 	ret
  5614                              <1> 	
  5615                              <1> ;=============================================================================
  5616                              <1> ; inputbox_default_event_handle
  5617                              <1> ; input:
  5618                              <1> ;	ax = event code
  5619                              <1> ;	ds:si -> input box
  5620                              <1> ; output:
  5621                              <1> ;	none
  5622                              <1> ;=============================================================================
  5623                              <1> inputbox_default_event_handle:
  5624 00002332 E80F06              <1> 	call window_default_event_handle
  5625 00002335 732C                <1> 	jnc .end
  5626 00002337 08C0                <1> 	or al, al
  5627 00002339 7427                <1> 	jz .no_action
  5628 0000233B 80FCF0              <1> 	cmp ah, EVTCODE_COMMAND
  5629 0000233E 7322                <1> 	jae .no_action
  5630 00002340 3C20                <1> 	cmp al, 0x20
  5631 00002342 721E                <1> 	jb .no_action
  5632 00002344 3CE0                <1> 	cmp al, 0xE0
  5633 00002346 741A                <1> 	je .no_action
  5634                              <1> 
  5635 00002348 E820FF              <1> 	call inputbox_get_strlen
  5636 0000234B 2A4C22              <1> 	sub cl, [si + struc_input_box.input_buf_len]
  5637 0000234E 08C9                <1> 	or cl, cl
  5638 00002350 7411                <1> 	jz .end
  5639                              <1> 
  5640 00002352 8A4C27              <1> 	mov cl, [si + struc_input_box.input_curp]
  5641 00002355 E8B9FF              <1> 	call inputbox_insert_char
  5642 00002358 FE4427              <1> 	inc byte [si + struc_input_box.input_curp]
  5643 0000235B E82DFF              <1> 	call inputbox_post_input
  5644 0000235E E85203              <1> 	call window_draw_body
  5645 00002361 C3                  <1> 	ret
  5646                              <1> 
  5647                              <1> .no_action:
  5648 00002362 F9                  <1> 	stc
  5649                              <1> .end:
  5650 00002363 C3                  <1> 	ret
  5651                              <1> 
  5652                              <1> ;=============================================================================
  5653                              <1> ; inputbox_prepare
  5654                              <1> ; input:
  5655                              <1> ;	ah = input method ( 0 = normal, 1 = security )
  5656                              <1> ;	al = message attribute
  5657                              <1> ;	bh = title attribute
  5658                              <1> ;	bl = frame attribute
  5659                              <1> ;	ch = input area length
  5660                              <1> ;	cl = max input length
  5661                              <1> ;	ds:si -> message ( no more than one line )
  5662                              <1> ;	ds:di -> pointer to struc_input_box
  5663                              <1> ;	ds:dx -> buffer to store input string
  5664                              <1> ;=============================================================================
  5665                              <1> inputbox_prepare:
  5666 00002364 60                  <1> 	pusha
  5667 00002365 08ED                <1> 	or ch, ch
  5668 00002367 7502                <1> 	jnz .go_prepare
  5669 00002369 88CD                <1> 	mov ch, cl
  5670                              <1> .go_prepare:
  5671                              <1> 
  5672 0000236B 51                  <1> 	push cx
  5673 0000236C B92900              <1> 	mov cx, SIZE_OF_STRUC_INPUT_BOX
  5674 0000236F E8BF0C              <1> 	call clear_memory
  5675 00002372 59                  <1> 	pop cx
  5676                              <1> 
  5677 00002373 C60506              <1> 	mov byte [di], WINFLAG_FRAMED | WINFLAG_MODAL		; win flag
  5678 00002376 C7850200[114C]      <1> 	mov word [di + struc_window.title], str_idx.input	; win title
  5679 0000237C 895D04              <1> 	mov [di + struc_window.win_attr], bx			; win attr
  5680 0000237F 89751A              <1> 	mov [di + struc_input_box.message], si
  5681 00002382 88451C              <1> 	mov [di + struc_input_box.message_attr], al
  5682 00002385 B00F                <1> 	mov al, 0x0F
  5683 00002387 89451E              <1> 	mov [di + struc_input_box.input_attr], ax
  5684 0000238A 895520              <1> 	mov [di + struc_input_box.input_buf], dx
  5685 0000238D 894D22              <1> 	mov [di + struc_input_box.input_buf_len], cx		; input buf 
  5686                              <1> 								; and area len
  5687                              <1> 
  5688 00002390 8B1E[B04B]          <1> 	mov bx, [size.box_width]
  5689 00002394 FEC7                <1> 	inc bh
  5690 00002396 00EB                <1> 	add bl, ch
  5691                              <1> 
  5692 00002398 E87308              <1> 	call strlen
  5693 0000239B 00CB                <1> 	add bl, cl
  5694 0000239D 895D08              <1> 	mov [di + struc_window.win_size], bx			; win size
  5695 000023A0 894D24              <1> 	mov [di + struc_input_box.input_area_pos],cx		; input area pos
  5696 000023A3 8145240202          <1> 	add word [di + struc_input_box.input_area_pos], 0x0202
  5697                              <1> 
  5698 000023A8 C78510000E00        <1> 	mov word [di + struc_window.act_num], INPUTBOX_ACTION_NUM
  5699 000023AE C7851200[392B]      <1> 	mov word [di + struc_window.act_table], inputbox_action_table
  5700 000023B4 C74514[3223]        <1> 	mov word [di + struc_window.default_event_handle], inputbox_default_event_handle
  5701 000023B9 C7851600[5029]      <1> 	mov word [di + struc_window.event_handle], window_event_handle
  5702 000023BF C74518[1E22]        <1> 	mov word [di + struc_window.draw_body_proc], inputbox_draw_body_proc
  5703                              <1> 
  5704 000023C4 FE4528              <1> 	inc byte [di + struc_input_box.return_val]
  5705                              <1> 
  5706 000023C7 89FE                <1> 	mov si, di
  5707 000023C9 E86305              <1> 	call window_center_window
  5708 000023CC 61                  <1> 	popa
  5709 000023CD C3                  <1> 	ret
  5710                              <1> 
  5711                              <1> ;=============================================================================
  5712                              <1> ;input_box ---- draw a input box and input a string
  5713                              <1> ;input:
  5714                              <1> ;      ah = input method ( 0 = normal, 1 = security )
  5715                              <1> ;      al = message attribute
  5716                              <1> ;      bh = title attribute
  5717                              <1> ;      bl = frame attribute
  5718                              <1> ;      ch = input area length
  5719                              <1> ;      cl = max input length
  5720                              <1> ;      ds:si -> message ( no more than one line )
  5721                              <1> ;      ds:di -> buffer to store input text
  5722                              <1> ;      ds:dx -> parent window
  5723                              <1> ;output:
  5724                              <1> ;      cf = 0 , ah = 0 ok, ch = number of inputed character
  5725                              <1> ;      cf = 1 , ah != 0 cancel, ch = 0
  5726                              <1> ;=============================================================================
  5727                              <1> input_box:
  5728 000023CE 56                  <1> 	push si
  5729 000023CF 57                  <1> 	push di
  5730 000023D0 57                  <1> 	push di
  5731 000023D1 52                  <1> 	push dx
  5732                              <1> 
  5733 000023D2 BA[0C2B]            <1> 	mov dx, ui_tmp.tmp_buf
  5734 000023D5 BF[B82A]            <1> 	mov di, ui_tmp.tmp_inputbox
  5735 000023D8 87F7                <1> 	xchg si, di
  5736 000023DA E84F06              <1> 	call winlist_remove
  5737 000023DD 87F7                <1> 	xchg si, di
  5738 000023DF E882FF              <1> 	call inputbox_prepare
  5739                              <1> 
  5740 000023E2 8F450A              <1> 	pop word [di + struc_window.parent_win]
  5741 000023E5 87FA                <1> 	xchg di, dx
  5742 000023E7 5E                  <1> 	pop si
  5743                              <1> 
  5744 000023E8 06                  <1> 	push es
  5745 000023E9 1E                  <1> 	push ds
  5746 000023EA 07                  <1> 	pop es
  5747                              <1> 
  5748 000023EB 56                  <1> 	push si
  5749 000023EC 57                  <1> 	push di
  5750                              <1> 
  5751 000023ED E87708              <1> 	call strcpy
  5752                              <1> 	
  5753 000023F0 89D6                <1> 	mov si, dx
  5754 000023F2 E87104              <1> 	call window_run
  5755 000023F5 8A6428              <1> 	mov ah, [si + struc_input_box.return_val]
  5756 000023F8 E870FE              <1> 	call inputbox_get_strlen
  5757 000023FB 88CD                <1> 	mov ch, cl
  5758 000023FD 8A4C22              <1> 	mov cl, [si + struc_input_box.input_buf_len]
  5759 00002400 08E4                <1> 	or ah, ah
  5760                              <1> 
  5761 00002402 5E                  <1> 	pop si
  5762 00002403 5F                  <1> 	pop di
  5763 00002404 7403                <1> 	jz .ok
  5764 00002406 F9                  <1> 	stc
  5765 00002407 EB04                <1> 	jmp short .end
  5766                              <1> .ok:
  5767 00002409 E85B08              <1> 	call strcpy
  5768 0000240C F8                  <1> 	clc
  5769                              <1> .end:
  5770 0000240D 07                  <1> 	pop es
  5771 0000240E 5F                  <1> 	pop di
  5772 0000240F 5E                  <1> 	pop si
  5773 00002410 C3                  <1> 	ret
  5774                              <1> 
  5775                              <1> ;=============================================================================
  5776                              <1> ;input_password ---- input a password
  5777                              <1> ;input:
  5778                              <1> ;      cl = max password length
  5779                              <1> ;      ds:si -> message string
  5780                              <1> ;output:
  5781                              <1> ;      cf = 0 success, ax:dx = password
  5782                              <1> ;      cf = 1 cancel
  5783                              <1> ;=============================================================================
  5784                              <1> input_password:
  5785 00002411 53                  <1>         push bx
  5786 00002412 51                  <1>         push cx
  5787                              <1>         
  5788 00002413 B401                <1>         mov ah, 1
  5789 00002415 A0[CF4B]            <1>         mov al, [color.input_box_msg]
  5790 00002418 8B1E[CD4B]          <1>         mov bx, [color.input_box_frame]
  5791 0000241C 88CD                <1>         mov ch, cl
  5792 0000241E 31D2                <1>         xor dx, dx
  5793 00002420 BF[0C2C]            <1>         mov di, ui_tmp.tmp_buf1
  5794                              <1> 
  5795 00002423 C60500              <1>         mov byte [di], 0
  5796                              <1> 
  5797 00002426 E8A5FF              <1>         call input_box
  5798 00002429 7209                <1>         jc .cancel_input
  5799                              <1> 
  5800 0000242B 89FE                <1>         mov si, di
  5801 0000242D 0FB6CD              <1>         movzx cx, ch
  5802 00002430 E84108              <1>         call calc_password
  5803 00002433 F8                  <1>         clc
  5804                              <1> 
  5805                              <1> .cancel_input:
  5806 00002434 59                  <1>         pop cx
  5807 00002435 5B                  <1>         pop bx
  5808 00002436 C3                  <1>         ret
  5809                              <1> ;=============================================================================
  5810                              <1> 
  5811                              <1> ;=============================================================================
  5812                              <1> ; menubox_adjust_geometry ---- adjust the size and position of the menu box
  5813                              <1> ; input:
  5814                              <1> ;	ds:si -> pointer to struc_menu_box
  5815                              <1> ; output:
  5816                              <1> ;	none
  5817                              <1> ;=============================================================================
  5818                              <1> menubox_adjust_geometry:
  5819 00002437 E80400              <1> 	call menubox_adjust_menu_area
  5820 0000243A E86F00              <1> 	call menubox_adjust_win_width
  5821 0000243D C3                  <1> 	ret
  5822                              <1> 
  5823                              <1> ;=============================================================================
  5824                              <1> ; menubox_adjust_menu_area ---- adjust the size and position of the menu area
  5825                              <1> ; input:
  5826                              <1> ;	ds:si -> pointer to struc_menu_box
  5827                              <1> ; output:
  5828                              <1> ;	none
  5829                              <1> ;=============================================================================
  5830                              <1> menubox_adjust_menu_area:
  5831 0000243E 60                  <1> 	pusha
  5832                              <1> 
  5833                              <1> ;adjust menu area position
  5834 0000243F B90101              <1> 	mov cx, 0x0101
  5835 00002442 8A04                <1> 	mov al, [si]
  5836 00002444 A840                <1> 	test al, MENUFLAG_SINK_UPPER
  5837 00002446 7402                <1> 	jz .no_sink_upper
  5838 00002448 FEC5                <1> 	inc ch
  5839                              <1> .no_sink_upper:
  5840 0000244A 817C1A0000          <1> 	cmp word [si + struc_menu_box.menu_header], 0
  5841 0000244F 7402                <1> 	jz .no_header
  5842 00002451 FEC5                <1> 	inc ch
  5843                              <1> .no_header:
  5844 00002453 A820                <1> 	test al, MENUFLAG_SINK_WIDTH
  5845 00002455 7402                <1> 	jz .no_sink_width
  5846 00002457 FEC1                <1> 	inc cl
  5847                              <1> .no_sink_width:
  5848 00002459 894C21              <1> 	mov [si + struc_menu_box.menu_area_pos], cx
  5849                              <1> 
  5850                              <1> ;adjust menu area size
  5851 0000245C 8B5408              <1> 	mov dx, [si + struc_window.win_size]
  5852 0000245F 28EE                <1> 	sub dh, ch
  5853 00002461 FECE                <1> 	dec dh
  5854 00002463 A880                <1> 	test al, MENUFLAG_SINK_BOTTOM
  5855 00002465 7402                <1> 	jz .no_sink_bottom
  5856 00002467 FECE                <1> 	dec dh
  5857                              <1> .no_sink_bottom:
  5858                              <1> 
  5859 00002469 30D2                <1> 	xor dl, dl
  5860 0000246B 0FB64C26            <1> 	movzx cx, byte [si + struc_menu_box.items_num]
  5861 0000246F 09C9                <1> 	or cx, cx
  5862 00002471 741D                <1> 	jz .end_calc
  5863 00002473 8B5C29              <1> 	mov bx, [si + struc_menu_box.item_str_proc]
  5864 00002476 09DB                <1> 	or bx, bx
  5865 00002478 7416                <1> 	jz .end_calc
  5866                              <1> 
  5867                              <1> .loop_calc_item_width:
  5868 0000247A 56                  <1> 	push si
  5869 0000247B 53                  <1> 	push bx
  5870 0000247C 51                  <1> 	push cx
  5871 0000247D 49                  <1> 	dec cx
  5872                              <1> 
  5873 0000247E 52                  <1> 	push dx
  5874 0000247F FFD3                <1> 	call bx
  5875 00002481 5A                  <1> 	pop dx
  5876                              <1> 
  5877 00002482 E89C07              <1> 	call strlen_hl
  5878 00002485 38CA                <1> 	cmp dl, cl
  5879 00002487 7302                <1> 	jae .cont_calc
  5880 00002489 88CA                <1> 	mov dl, cl
  5881                              <1> .cont_calc:
  5882 0000248B 59                  <1> 	pop cx
  5883 0000248C 5B                  <1> 	pop bx
  5884 0000248D 5E                  <1> 	pop si
  5885 0000248E E2EA                <1> 	loop .loop_calc_item_width
  5886                              <1> 
  5887                              <1> .end_calc:
  5888                              <1> 
  5889 00002490 56                  <1> 	push si
  5890 00002491 8B741A              <1> 	mov si, [si + struc_menu_box.menu_header]
  5891 00002494 09F6                <1> 	or si, si
  5892 00002496 740B                <1> 	jz .no_header_len
  5893 00002498 8B34                <1> 	mov si, [si]
  5894 0000249A E88407              <1> 	call strlen_hl
  5895 0000249D 38CA                <1> 	cmp dl, cl
  5896 0000249F 7302                <1> 	jae .header_short
  5897 000024A1 88CA                <1> 	mov dl, cl
  5898                              <1> .header_short:
  5899                              <1> .no_header_len:
  5900 000024A3 80C202              <1> 	add dl, 2
  5901 000024A6 5E                  <1> 	pop si
  5902 000024A7 895423              <1> 	mov [si + struc_menu_box.menu_area_size], dx
  5903                              <1> 
  5904 000024AA 61                  <1> 	popa
  5905 000024AB C3                  <1> 	ret
  5906                              <1> 
  5907                              <1> 
  5908                              <1> ;=============================================================================
  5909                              <1> ; menubox_adjust_win_width ---- adjust the width the menu window. 
  5910                              <1> ; input:
  5911                              <1> ;	ds:si -> pointer to struc_menu_box
  5912                              <1> ; output:
  5913                              <1> ;	none
  5914                              <1> ;=============================================================================
  5915                              <1> menubox_adjust_win_width:
  5916 000024AC 60                  <1> 	pusha
  5917 000024AD 8A04                <1> 	mov al, [si]
  5918 000024AF 8B5C23              <1> 	mov bx, [si + struc_menu_box.menu_area_size]
  5919                              <1> 
  5920                              <1> ; calculate window width
  5921 000024B2 80C302              <1> 	add bl, 2
  5922                              <1> 
  5923 000024B5 A820                <1> 	test al, MENUFLAG_SINK_WIDTH
  5924 000024B7 7403                <1> 	jz .no_sink_width
  5925 000024B9 80C302              <1> 	add bl, 2
  5926                              <1> .no_sink_width:
  5927 000024BC A810                <1> 	test al, MENUFLAG_SCROLLBAR
  5928 000024BE 7402                <1> 	jz .no_scrollbar
  5929 000024C0 FEC3                <1> 	inc bl
  5930                              <1> .no_scrollbar:
  5931 000024C2 885C08              <1> 	mov [si + struc_window.win_size], bl
  5932 000024C5 8A0E[ED2A]          <1> 	mov cl, [ui_screen_width]
  5933 000024C9 28D9                <1> 	sub cl, bl
  5934 000024CB 80E902              <1> 	sub cl, 2
  5935                              <1> 
  5936 000024CE 384C06              <1> 	cmp [si + struc_window.win_pos], cl
  5937 000024D1 7603                <1> 	jbe .no_adjust_pos
  5938 000024D3 884C06              <1> 	mov [si + struc_window.win_pos], cl
  5939                              <1> .no_adjust_pos:
  5940 000024D6 61                  <1> 	popa
  5941 000024D7 C3                  <1> 	ret
  5942                              <1> 
  5943                              <1> ;=============================================================================
  5944                              <1> ; menubox_draw_body_proc ---- draw the window body of a menu box
  5945                              <1> ; input:
  5946                              <1> ;	ds:si -> pointer to struc_menu_box
  5947                              <1> ; output:
  5948                              <1> ;	none
  5949                              <1> ;=============================================================================
  5950                              <1> menubox_draw_body_proc:
  5951 000024D8 60                  <1> 	pusha
  5952 000024D9 E82800              <1> 	call menubox_draw_menu
  5953 000024DC 817C1A0000          <1> 	cmp word [si + struc_menu_box.menu_header], 0
  5954 000024E1 7403                <1> 	jz .no_header
  5955 000024E3 E87D00              <1> 	call menubox_draw_header
  5956                              <1> .no_header:
  5957 000024E6 F60410              <1> 	test byte [si], MENUFLAG_SCROLLBAR
  5958 000024E9 7403                <1> 	jz .no_scrollbar
  5959 000024EB E80200              <1> 	call menubox_draw_scrollbar
  5960                              <1> .no_scrollbar:
  5961 000024EE 61                  <1> 	popa
  5962 000024EF C3                  <1> 	ret
  5963                              <1> 
  5964                              <1> 
  5965                              <1> ;=============================================================================
  5966                              <1> ; menubox_draw_scrollbar ---- draw the scrollbar
  5967                              <1> ; input:
  5968                              <1> ;	ds:si -> pointer to struc_menu_box
  5969                              <1> ; output:
  5970                              <1> ;	none
  5971                              <1> ;=============================================================================
  5972                              <1> menubox_draw_scrollbar:
  5973 000024F0 8B4426              <1> 	mov ax, [si + struc_menu_box.items_num]
  5974 000024F3 8A5C25              <1> 	mov bl, [si + struc_menu_box.scrollbar_attr]
  5975 000024F6 8B4C21              <1> 	mov cx, [si + struc_menu_box.menu_area_pos]
  5976 000024F9 8B5423              <1> 	mov dx, [si + struc_menu_box.menu_area_size]
  5977 000024FC 00D1                <1> 	add cl, dl
  5978 000024FE 30D2                <1> 	xor dl, dl
  5979 00002500 E84F02              <1> 	call window_draw_scrollbar
  5980 00002503 C3                  <1> 	ret
  5981                              <1> 
  5982                              <1> ;=============================================================================
  5983                              <1> ; menubox_draw_menu ---- draw the menu area
  5984                              <1> ; input:
  5985                              <1> ;	ds:si -> pointer to struc_menu_box
  5986                              <1> ; output:
  5987                              <1> ;	none
  5988                              <1> ;=============================================================================
  5989                              <1> menubox_draw_menu:
  5990 00002504 60                  <1> 	pusha
  5991 00002505 8B4C21              <1> 	mov cx, [si + struc_menu_box.menu_area_pos]
  5992 00002508 8B5423              <1> 	mov dx, [si + struc_menu_box.menu_area_size]
  5993 0000250B 52                  <1> 	push dx
  5994 0000250C 51                  <1> 	push cx
  5995 0000250D 034C06              <1> 	add cx, [si + struc_window.win_pos]
  5996 00002510 01CA                <1> 	add dx, cx
  5997                              <1> 
  5998 00002512 81EA0101            <1> 	sub dx, 0x0101
  5999 00002516 8A7C1D              <1> 	mov bh, [si + struc_menu_box.menu_norm_attr]
  6000 00002519 E888F9              <1> 	call clear_screen
  6001                              <1> 
  6002 0000251C 5A                  <1> 	pop dx
  6003 0000251D 58                  <1> 	pop ax
  6004                              <1> 
  6005 0000251E 0FB64C28            <1> 	movzx cx, [si + struc_menu_box.first_visible_item]
  6006 00002522 807C2600            <1> 	cmp byte [si + struc_menu_box.items_num], 0
  6007 00002526 7439                <1> 	je .end
  6008                              <1> 
  6009 00002528 89F7                <1> 	mov di, si
  6010                              <1> 
  6011                              <1> .loop_draw_item:
  6012 0000252A 3A4C27              <1> 	cmp cl, [si + struc_menu_box.focus_item]
  6013 0000252D 7405                <1> 	je .focused
  6014 0000252F 8B5C1D              <1> 	mov bx, [si + struc_menu_box.menu_norm_attr]
  6015 00002532 EB03                <1> 	jmp short .draw_item
  6016                              <1> .focused:
  6017 00002534 8B5C1F              <1> 	mov bx, [si + struc_menu_box.menu_focus_attr]
  6018                              <1> .draw_item:
  6019 00002537 60                  <1> 	pusha
  6020 00002538 51                  <1> 	push cx
  6021 00002539 88C1                <1> 	mov cl, al
  6022 0000253B B020                <1> 	mov al, ' '
  6023 0000253D E8F601              <1> 	call window_draw_char
  6024 00002540 59                  <1> 	pop cx
  6025 00002541 FEC2                <1> 	inc dl
  6026 00002543 53                  <1> 	push bx
  6027 00002544 52                  <1> 	push dx
  6028 00002545 57                  <1> 	push di
  6029 00002546 FF5429              <1> 	call word [si + struc_menu_box.item_str_proc]
  6030 00002549 5F                  <1> 	pop di
  6031 0000254A 5A                  <1> 	pop dx
  6032 0000254B 5B                  <1> 	pop bx
  6033 0000254C E8F501              <1> 	call window_draw_string
  6034 0000254F 61                  <1> 	popa
  6035 00002550 FEC6                <1> 	inc dh
  6036 00002552 FEC1                <1> 	inc cl
  6037 00002554 FECC                <1> 	dec ah
  6038 00002556 3A4C26              <1> 	cmp cl, [si + struc_menu_box.items_num]
  6039 00002559 7306                <1> 	jae .end
  6040 0000255B 08E4                <1> 	or ah, ah
  6041 0000255D 7402                <1> 	jz .end
  6042 0000255F EBC9                <1> 	jmp short .loop_draw_item
  6043                              <1> .end:
  6044 00002561 61                  <1> 	popa
  6045 00002562 C3                  <1> 	ret
  6046                              <1> 
  6047                              <1> ;=============================================================================
  6048                              <1> ; menubox_draw_header ---- draw the menu header
  6049                              <1> ; input:
  6050                              <1> ;	ds:si -> pointer to struc_menu_box
  6051                              <1> ; output:
  6052                              <1> ;	none
  6053                              <1> ;=============================================================================
  6054                              <1> menubox_draw_header:
  6055 00002563 60                  <1> 	pusha
  6056 00002564 8B5C1C              <1> 	mov bx, [si + struc_menu_box.menu_header_attr]
  6057 00002567 8B5421              <1> 	mov dx, [si + struc_menu_box.menu_area_pos]
  6058 0000256A FECE                <1> 	dec dh
  6059 0000256C 0FB64C23            <1> 	movzx cx, byte [si + struc_menu_box.menu_area_size]
  6060 00002570 B020                <1> 	mov al, ' '
  6061 00002572 F60410              <1> 	test byte [si], MENUFLAG_SCROLLBAR
  6062 00002575 7402                <1> 	jz .no_scrollbar
  6063 00002577 FEC1                <1> 	inc cl
  6064                              <1> .no_scrollbar:
  6065 00002579 E8BA01              <1> 	call window_draw_char
  6066 0000257C 89F7                <1> 	mov di, si
  6067 0000257E 8B741A              <1> 	mov si, [si + struc_menu_box.menu_header]
  6068 00002581 8B34                <1> 	mov si, [si]
  6069 00002583 FEC2                <1> 	inc dl
  6070 00002585 E8BC01              <1> 	call window_draw_string
  6071 00002588 61                  <1> 	popa
  6072 00002589 C3                  <1> 	ret
  6073                              <1> 
  6074                              <1> ;=============================================================================
  6075                              <1> ; menubox_do_focus ---- do the focused menu item, get the pointer of item action
  6076                              <1> ;                    from action_table, then call window_do_action to do it.
  6077                              <1> ; input:
  6078                              <1> ;	ds:si -> pointer to struc_menu_box
  6079                              <1> ; output:
  6080                              <1> ;	none
  6081                              <1> ;=============================================================================
  6082                              <1> menubox_do_focus:
  6083 0000258A 8B5C12              <1> 	mov bx, [si + struc_window.act_table]
  6084 0000258D B005                <1> 	mov al, SIZE_OF_STRUC_ACTION
  6085 0000258F 8A4C27              <1> 	mov cl, [si + struc_menu_box.focus_item]
  6086 00002592 F6E1                <1> 	mul cl
  6087 00002594 01C3                <1> 	add bx, ax
  6088 00002596 8B4701              <1> 	mov ax, [bx + struc_action.keycode]
  6089 00002599 E80504              <1> 	call window_do_action
  6090 0000259C C3                  <1> 	ret
  6091                              <1> 	
  6092                              <1> 
  6093                              <1> ;=============================================================================
  6094                              <1> ; menubox_adjust_visible_boundary
  6095                              <1> ;input:
  6096                              <1> ;	ds:si -> pointer to struc_menu_box
  6097                              <1> ;=============================================================================
  6098                              <1> menubox_adjust_visible_boundary:
  6099 0000259D 8B4427              <1> 	mov ax, [si + struc_menu_box.focus_item] ; al = focus_item, ah = first_visible_item
  6100                              <1> 
  6101                              <1> .check_upper:
  6102 000025A0 38E0                <1> 	cmp al, ah
  6103 000025A2 7303                <1> 	jae .check_bottom
  6104 000025A4 884428              <1> 	mov [si + struc_menu_box.first_visible_item], al
  6105                              <1> .check_bottom:
  6106 000025A7 026424              <1> 	add ah, [si + struc_menu_box.menu_area_size + 1]
  6107 000025AA 38E0                <1> 	cmp al, ah
  6108 000025AC 7207                <1> 	jb .end
  6109 000025AE 28E0                <1> 	sub al, ah
  6110 000025B0 FEC0                <1> 	inc al
  6111 000025B2 004428              <1> 	add [si + struc_menu_box.first_visible_item], al
  6112                              <1> .end:	
  6113 000025B5 C3                  <1> 	ret
  6114                              <1> 
  6115                              <1> ;=============================================================================
  6116                              <1> ; menubox_focus_up ---- move the focus bar up one line
  6117                              <1> ; input:
  6118                              <1> ;	ds:si -> pointer to struc_menu_box
  6119                              <1> ; output:
  6120                              <1> ;	none
  6121                              <1> ;=============================================================================
  6122                              <1> menubox_focus_up:
  6123 000025B6 8B4426              <1> 	mov ax, [si + struc_menu_box.items_num]	;al = items_num, ah = focus_item
  6124 000025B9 08E4                <1> 	or ah, ah
  6125 000025BB 7502                <1> 	jnz .up
  6126 000025BD 88C4                <1> 	mov ah, al
  6127                              <1> .up:
  6128 000025BF FECC                <1> 	dec ah
  6129 000025C1 886427              <1> 	mov [si + struc_menu_box.focus_item], ah
  6130 000025C4 E8D6FF              <1> 	call menubox_adjust_visible_boundary
  6131 000025C7 C3                  <1> 	ret
  6132                              <1> 
  6133                              <1> ;=============================================================================
  6134                              <1> ; menu_focus_pageup ---- move the focus bar up one page
  6135                              <1> ; input:
  6136                              <1> ;	ds:si -> pointer to struc_menu_box
  6137                              <1> ; output:
  6138                              <1> ;	none
  6139                              <1> ;=============================================================================
  6140                              <1> menubox_focus_pageup:
  6141 000025C8 8A4427              <1> 	mov al, [si + struc_menu_box.focus_item]
  6142 000025CB 8A4C24              <1> 	mov cl, byte [si + struc_menu_box.menu_area_size+1]
  6143 000025CE FEC9                <1> 	dec cl
  6144 000025D0 38C1                <1> 	cmp cl, al
  6145 000025D2 7206                <1> 	jb .loop_up
  6146                              <1> 
  6147 000025D4 88C1                <1> 	mov cl, al
  6148 000025D6 08C9                <1> 	or cl, cl
  6149 000025D8 7407                <1> 	jz .end
  6150                              <1> 
  6151                              <1> .loop_up:
  6152 000025DA 30ED                <1> 	xor ch, ch
  6153 000025DC E8D7FF              <1> 	call menubox_focus_up
  6154 000025DF E2F9                <1> 	loop .loop_up
  6155                              <1> .end:
  6156 000025E1 C3                  <1> 	ret
  6157                              <1> 
  6158                              <1> ;=============================================================================
  6159                              <1> ; menu_focus_down ---- move the focus bar down one line
  6160                              <1> ; input:
  6161                              <1> ;	ds:si -> pointer to struc_menu_box
  6162                              <1> ; output:
  6163                              <1> ;	none
  6164                              <1> ;=============================================================================
  6165                              <1> menubox_focus_down:
  6166 000025E2 8B4426              <1> 	mov ax, [si + struc_menu_box.items_num]	;al = items_num, ah = focus_item
  6167 000025E5 FEC4                <1> 	inc ah
  6168 000025E7 38C4                <1> 	cmp ah, al
  6169 000025E9 7202                <1> 	jb .down
  6170 000025EB 30E4                <1> 	xor ah, ah
  6171                              <1> .down:
  6172 000025ED 886427              <1> 	mov [si + struc_menu_box.focus_item], ah
  6173 000025F0 E8AAFF              <1> 	call menubox_adjust_visible_boundary
  6174 000025F3 C3                  <1> 	ret
  6175                              <1> 
  6176                              <1> ;=============================================================================
  6177                              <1> ; menu_focus_pagedown ---- move the focus bar down one page
  6178                              <1> ; input:
  6179                              <1> ;	ds:si -> pointer to struc_menu_box
  6180                              <1> ; output:
  6181                              <1> ;	none
  6182                              <1> ;=============================================================================
  6183                              <1> menubox_focus_pagedown:
  6184 000025F4 8B4426              <1> 	mov ax, [si + struc_menu_box.items_num]
  6185 000025F7 08C0                <1> 	or al, al
  6186 000025F9 741A                <1> 	jz .end
  6187                              <1> 
  6188 000025FB 28E0                <1> 	sub al, ah
  6189 000025FD FEC8                <1> 	dec al
  6190                              <1> 
  6191 000025FF 8A4C24              <1> 	mov cl, byte [si + struc_menu_box.menu_area_size+1]
  6192 00002602 FEC9                <1> 	dec cl
  6193                              <1> 
  6194 00002604 38C1                <1> 	cmp cl, al
  6195 00002606 7206                <1> 	jb .loop_down
  6196 00002608 88C1                <1> 	mov cl, al
  6197 0000260A 08C9                <1> 	or cl, cl
  6198 0000260C 7407                <1> 	jz .end
  6199                              <1> 
  6200                              <1> .loop_down:
  6201 0000260E 30ED                <1> 	xor ch, ch
  6202 00002610 E8CFFF              <1> 	call menubox_focus_down
  6203 00002613 E2F9                <1> 	loop .loop_down
  6204                              <1> .end:
  6205 00002615 C3                  <1> 	ret
  6206                              <1> 
  6207                              <1> ;=============================================================================
  6208                              <1> ;menubox_default_event_handle
  6209                              <1> ;=============================================================================
  6210                              <1> menubox_default_event_handle:
  6211 00002616 60                  <1> 	pusha
  6212 00002617 B90A00              <1> 	mov cx, MENUBOX_DEF_ACTION_NUM
  6213 0000261A BB[8E2B]            <1> 	mov bx, menubox_def_action_table
  6214 0000261D E84A03              <1> 	call window_generic_event_handle
  6215 00002620 7303                <1> 	jnc .end
  6216 00002622 E81F03              <1> 	call window_default_event_handle
  6217                              <1> .end:
  6218 00002625 61                  <1> 	popa
  6219 00002626 C3                  <1> 	ret
  6220                              <1> ;=============================================================================
  6221                              <1> 
  6222                              <1> ;=============================================================================
  6223                              <1> ; listbox_prepare ---- prepare a list box
  6224                              <1> ; input:
  6225                              <1> ;	cl = number of items
  6226                              <1> ;	ch = height of list box
  6227                              <1> ;	ds:bx -> 2nd level pointer to title
  6228                              <1> ;	ds:dx -> 2nd level pointer to header
  6229                              <1> ;	ds:si -> items string proc
  6230                              <1> ;	ds:di -> struc_menu_box
  6231                              <1> ;=============================================================================
  6232                              <1> listbox_prepare:
  6233 00002627 60                  <1> 	pusha
  6234 00002628 51                  <1> 	push cx
  6235 00002629 B92B00              <1> 	mov cx, SIZE_OF_STRUC_MENU_BOX
  6236 0000262C E8020A              <1> 	call clear_memory
  6237 0000262F 59                  <1> 	pop cx
  6238                              <1> 
  6239 00002630 C60516              <1> 	mov byte [di], WINFLAG_FRAMED | WINFLAG_MODAL | MENUFLAG_SCROLLBAR
  6240 00002633 895D02              <1> 	mov [di + struc_window.title], bx
  6241 00002636 89551A              <1> 	mov [di + struc_menu_box.menu_header], dx
  6242 00002639 897529              <1> 	mov [di + struc_menu_box.item_str_proc], si
  6243                              <1> 
  6244 0000263C BE[C54B]            <1> 	mov si, color.list_box
  6245 0000263F FC                  <1> 	cld
  6246 00002640 AD                  <1> 	lodsw
  6247 00002641 894504              <1> 	mov word [di + struc_window.win_attr], ax
  6248 00002644 AC                  <1> 	lodsb
  6249 00002645 88451C              <1> 	mov byte [di + struc_menu_box.menu_header_attr], al
  6250 00002648 AD                  <1> 	lodsw
  6251 00002649 89451D              <1> 	mov word [di + struc_menu_box.menu_norm_attr], ax
  6252 0000264C AD                  <1> 	lodsw
  6253 0000264D 89451F              <1> 	mov word [di + struc_menu_box.menu_focus_attr], ax
  6254 00002650 AC                  <1> 	lodsb
  6255 00002651 884525              <1> 	mov byte [di + struc_menu_box.scrollbar_attr], al
  6256                              <1> 
  6257 00002654 884D26              <1> 	mov [di + struc_menu_box.items_num], cl
  6258 00002657 886D09              <1> 	mov [di + struc_window.win_size + 1], ch
  6259 0000265A C78510000300        <1> 	mov word [di + struc_window.act_num], LISTBOX_ACTION_NUM
  6260 00002660 C7851200[7F2B]      <1> 	mov word [di + struc_window.act_table], listbox_action_table
  6261 00002666 C74514[1626]        <1> 	mov word [di + struc_window.default_event_handle], menubox_default_event_handle
  6262 0000266B C7851600[5029]      <1> 	mov word [di + struc_window.event_handle], window_event_handle
  6263 00002671 C74518[D824]        <1> 	mov word [di + struc_window.draw_body_proc], menubox_draw_body_proc
  6264                              <1> 
  6265 00002676 89FE                <1> 	mov si, di
  6266 00002678 E8BCFD              <1> 	call menubox_adjust_geometry
  6267 0000267B E8B102              <1> 	call window_center_window
  6268 0000267E 61                  <1> 	popa
  6269 0000267F C3                  <1> 	ret
  6270                              <1> 	
  6271                              <1> ;=============================================================================
  6272                              <1> ; list_box ---- run a list box
  6273                              <1> ; input:
  6274                              <1> ;	cl = number of items
  6275                              <1> ;	ch = height of list box
  6276                              <1> ;	ds:bx -> 2nd level pointer to title
  6277                              <1> ;	ds:dx -> 2nd level pointer to header
  6278                              <1> ;	ds:si -> items string proc
  6279                              <1> ; output:
  6280                              <1> ;	cl = selected item, 0xff means canceled
  6281                              <1> ;	cf = 0 success, cf = 1 canceled
  6282                              <1> ;=============================================================================
  6283                              <1> list_box:
  6284 00002680 60                  <1> 	pusha
  6285 00002681 BF[E12A]            <1> 	mov di, ui_tmp.tmp_menubox
  6286 00002684 E8A0FF              <1> 	call listbox_prepare
  6287 00002687 89FE                <1> 	mov si, di
  6288 00002689 E8DA01              <1> 	call window_run
  6289 0000268C 61                  <1> 	popa
  6290 0000268D 8A0E[082B]          <1> 	mov cl, [ui_tmp.tmp_menubox + struc_menu_box.focus_item]
  6291 00002691 80F9FF              <1> 	cmp cl, 0xFF
  6292 00002694 7402                <1> 	je .cancel
  6293 00002696 F8                  <1> 	clc
  6294 00002697 C3                  <1> 	ret
  6295                              <1> .cancel:
  6296 00002698 F9                  <1> 	stc
  6297 00002699 C3                  <1> 	ret
  6298                              <1> 
  6299                              <1> ;=============================================================================
  6300                              <1> ; listbox_cancel
  6301                              <1> ;=============================================================================
  6302                              <1> listbox_cancel:
  6303 0000269A C64427FF            <1> 	mov byte [si + struc_menu_box.focus_item], 0xFF
  6304 0000269E C3                  <1> 	ret
  6305                              <1> ;=============================================================================
  6306                              <1> 
  6307                              <1> 
  6308                              <1> 
  6309                              <1> ;=============================================================================
  6310                              <1> ;<<<<<<<<<<<<<<<<<<<<<<<<<< Window System functions >>>>>>>>>>>>>>>>>>>>>>>>>>
  6311                              <1> ;=============================================================================
  6312                              <1> 
  6313                              <1> ;=============================================================================
  6314                              <1> ; window_draw_all ---- draw all windows
  6315                              <1> ; input:
  6316                              <1> ;	none
  6317                              <1> ; output:
  6318                              <1> ;	none
  6319                              <1> ;=============================================================================
  6320                              <1> window_draw_all:
  6321 0000269F 60                  <1> 	pusha
  6322 000026A0 8B36[7C2A]          <1> 	mov si, [ui_tmp.root_win]
  6323 000026A4 09F6                <1> 	or si, si
  6324 000026A6 7409                <1> 	jz .end
  6325 000026A8 E88FFA              <1> 	call lock_screen
  6326 000026AB E82600              <1> 	call window_draw_window
  6327 000026AE E8AFFA              <1> 	call unlock_screen
  6328                              <1> .end:
  6329 000026B1 61                  <1> 	popa
  6330 000026B2 C3                  <1> 	ret
  6331                              <1> 
  6332                              <1> ;=============================================================================
  6333                              <1> ; window_draw_body ---- draw the window body
  6334                              <1> ; input:
  6335                              <1> ;	ds:si -> pointer to struc_window
  6336                              <1> ; output:
  6337                              <1> ;	none
  6338                              <1> ;=============================================================================
  6339                              <1> window_draw_body:
  6340 000026B3 60                  <1> 	pusha
  6341 000026B4 09F6                <1> 	or si, si
  6342 000026B6 741A                <1> 	jz .no_win
  6343                              <1> 
  6344 000026B8 F60401              <1> 	test byte [si], WINFLAG_OPEN
  6345 000026BB 7415                <1> 	jz .no_win
  6346                              <1> 
  6347 000026BD 8B5C18              <1> 	mov bx, [si + struc_window.draw_body_proc]
  6348 000026C0 09DB                <1> 	or bx, bx
  6349 000026C2 740E                <1> 	jz .no_win
  6350                              <1> 
  6351 000026C4 56                  <1> 	push si
  6352 000026C5 FFD3                <1> 	call bx
  6353 000026C7 5E                  <1> 	pop si
  6354                              <1> 
  6355 000026C8 8B740C              <1> 	mov si, [si + struc_window.next_win]
  6356 000026CB 09F6                <1> 	or si, si
  6357 000026CD 7403                <1> 	jz .no_win
  6358 000026CF E80200              <1> 	call window_draw_window		; draw top windows.
  6359                              <1> 
  6360                              <1> .no_win:
  6361 000026D2 61                  <1> 	popa
  6362 000026D3 C3                  <1> 	ret
  6363                              <1> ;=============================================================================
  6364                              <1> ; window_draw_window ---- draw the window and window body
  6365                              <1> ; input:
  6366                              <1> ;	ds:si -> pointer to struc_window
  6367                              <1> ; output:
  6368                              <1> ;	none
  6369                              <1> ;=============================================================================
  6370                              <1> window_draw_window:
  6371 000026D4 60                  <1> 	pusha
  6372                              <1> 
  6373 000026D5 E8CDF9              <1> 	call hide_cursor
  6374                              <1> 
  6375 000026D8 09F6                <1> 	or si, si
  6376 000026DA 7422                <1> 	jz .no_next_win
  6377                              <1> 
  6378 000026DC F60401              <1> 	test byte [si], WINFLAG_OPEN
  6379 000026DF 7413                <1> 	jz .no_body
  6380 000026E1 F60404              <1> 	test byte [si], WINFLAG_FRAMED
  6381 000026E4 7403                <1> 	jz .no_frame
  6382 000026E6 E81700              <1> 	call window_draw_frame
  6383                              <1> .no_frame:
  6384 000026E9 8B5C18              <1> 	mov bx, [si + struc_window.draw_body_proc]
  6385 000026EC 09DB                <1> 	or bx, bx
  6386 000026EE 7404                <1> 	jz .no_body
  6387 000026F0 56                  <1>         push si
  6388 000026F1 FFD3                <1> 	call bx
  6389 000026F3 5E                  <1>         pop si
  6390                              <1> .no_body:
  6391 000026F4 8B740C              <1> 	mov si, [si + struc_window.next_win]
  6392 000026F7 09F6                <1> 	or si, si
  6393 000026F9 7403                <1> 	jz .no_next_win
  6394 000026FB E8D6FF              <1> 	call window_draw_window		; draw top windows.
  6395                              <1> 
  6396                              <1> .no_next_win:
  6397 000026FE 61                  <1> 	popa
  6398 000026FF C3                  <1> 	ret
  6399                              <1> 
  6400                              <1> ;=============================================================================
  6401                              <1> ; window_draw_frame ---- draw the window frame and clear the window body
  6402                              <1> ; input:
  6403                              <1> ;	ds:si -> pointer to struc_window
  6404                              <1> ; output:
  6405                              <1> ;	none
  6406                              <1> ;=============================================================================
  6407                              <1> window_draw_frame:
  6408 00002700 60                  <1> 	pusha
  6409 00002701 8B4C06              <1> 	mov cx, [si + struc_window.win_pos]	; window position
  6410 00002704 8B5408              <1> 	mov dx, [si + struc_window.win_size]	;
  6411 00002707 01CA                <1> 	add dx, cx				; calculate window bottom
  6412 00002709 81EA0101            <1> 	sub dx, 0x0101				; right corner.
  6413                              <1> 
  6414 0000270D 8B5C04              <1> 	mov bx, [si + struc_window.win_attr]	; window attribute
  6415                              <1> 
  6416 00002710 3B36[7A2A]          <1> 	cmp si, [ui_tmp.focus_win]
  6417 00002714 7404                <1> 	je .focused
  6418                              <1> 
  6419 00002716 8A3E[B44B]          <1> 	mov bh, [color.win_title_inactive]	; use another title attr for 
  6420                              <1> 						; inactive window.
  6421                              <1> .focused:
  6422 0000271A 8B7402              <1> 	mov si, [si + struc_window.title]	; get window title pointer
  6423 0000271D 09F6                <1> 	or si, si
  6424 0000271F 7402                <1> 	jz .no_title
  6425 00002721 8B34                <1> 	mov si, [si]
  6426                              <1> .no_title:
  6427 00002723 E8C6F7              <1> 	call draw_window
  6428 00002726 61                  <1> 	popa
  6429 00002727 C3                  <1> 	ret
  6430                              <1> 
  6431                              <1> ;=============================================================================
  6432                              <1> ; window_set_cursor
  6433                              <1> ; input:
  6434                              <1> ;	dx = cursor position
  6435                              <1> ;	ds:si -> window
  6436                              <1> ; output:
  6437                              <1> ;	none
  6438                              <1> ;=============================================================================
  6439                              <1> window_set_cursor:
  6440 00002728 52                  <1> 	push dx
  6441 00002729 F60401              <1> 	test byte [si], WINFLAG_OPEN
  6442 0000272C 7406                <1> 	jz .no_cursor
  6443                              <1> 
  6444 0000272E 035406              <1> 	add dx, [si + struc_window.win_pos]
  6445 00002731 E866F9              <1> 	call set_cursor
  6446                              <1> 
  6447                              <1> .no_cursor:
  6448 00002734 5A                  <1> 	pop dx
  6449 00002735 C3                  <1> 	ret
  6450                              <1> 
  6451                              <1> ;=============================================================================
  6452                              <1> ; window_draw_char ---- Draw chars at special position in a window
  6453                              <1> ;input:
  6454                              <1> ;      bl = high 4 bit Background color and low 4 bit Foreground color
  6455                              <1> ;      dh = start row
  6456                              <1> ;      dl = start column
  6457                              <1> ;      al = the char to be displayed
  6458                              <1> ;      cx = repeat times
  6459                              <1> ;      ds:si -> the window
  6460                              <1> ;output:
  6461                              <1> ;      none
  6462                              <1> ;=============================================================================
  6463                              <1> window_draw_char:
  6464 00002736 52                  <1> 	push dx
  6465 00002737 F60401              <1> 	test byte [si], WINFLAG_OPEN
  6466 0000273A 7406                <1> 	jz .not_draw
  6467                              <1> 
  6468 0000273C 035406              <1> 	add dx, [si + struc_window.win_pos]
  6469 0000273F E844F7              <1> 	call draw_char
  6470                              <1> 
  6471                              <1> .not_draw:
  6472 00002742 5A                  <1> 	pop dx
  6473 00002743 C3                  <1> 	ret
  6474                              <1> 
  6475                              <1> ;=============================================================================
  6476                              <1> ;window_draw_string ---- Draw a zero ending string in a window 
  6477                              <1> ;                    at special position
  6478                              <1> ;input:
  6479                              <1> ;      bl = attribute for normal characters
  6480                              <1> ;           high 4 bit Background color and low 4 bit Foreground color
  6481                              <1> ;      bh = attribute for hightlight characters
  6482                              <1> ;      dh = start row
  6483                              <1> ;      dl = start column
  6484                              <1> ;      ds:si -> the string to be displayed
  6485                              <1> ;      ds:di -> the window
  6486                              <1> ;output:
  6487                              <1> ;      none
  6488                              <1> ;=============================================================================
  6489                              <1> window_draw_string:
  6490 00002744 60                  <1> 	pusha
  6491 00002745 F60501              <1> 	test byte [di], WINFLAG_OPEN
  6492 00002748 7406                <1> 	jz .not_draw
  6493                              <1> 
  6494 0000274A 035506              <1> 	add dx, [di + struc_window.win_pos]
  6495 0000274D E80FF7              <1> 	call draw_string
  6496                              <1> .not_draw:
  6497 00002750 61                  <1> 	popa
  6498 00002751 C3                  <1> 	ret
  6499                              <1> 
  6500                              <1> ;=============================================================================
  6501                              <1> ; window_draw_scrollbar ---- draw a scroll bar in a window
  6502                              <1> ; input:
  6503                              <1> ;	ds:si -> pointer to struc_window
  6504                              <1> ;	al    -> total amount
  6505                              <1> ;	ah    -> current value
  6506                              <1> ;	bl    -> attribute 
  6507                              <1> ;	ch    -> row of top of the scroll bar (relative to window position)
  6508                              <1> ;	cl    -> col of top of the scroll bar (relative to window position)
  6509                              <1> ;	dh    -> height of the scroll bar ( vertical bar, dl = 0 )
  6510                              <1> ;	dl    -> length of the scroll bar ( horizontal bar, dh = 0 )
  6511                              <1> ; output:
  6512                              <1> ;	none
  6513                              <1> ;=============================================================================
  6514                              <1> window_draw_scrollbar:
  6515 00002752 60                  <1> 	pusha
  6516                              <1> 
  6517                              <1> ; ================== do some initialization. ==================
  6518 00002753 51                  <1> 	push cx
  6519 00002754 31C9                <1> 	xor cx, cx
  6520 00002756 880E[F427]          <1> 	mov [.bar_type], cl
  6521 0000275A FEC1                <1> 	inc cl
  6522                              <1> 
  6523 0000275C 08F6                <1> 	or dh, dh
  6524 0000275E 7406                <1> 	jz .horiz1
  6525 00002760 880E[F427]          <1> 	mov [.bar_type], cl
  6526 00002764 86D6                <1> 	xchg dl, dh
  6527                              <1> .horiz1:
  6528                              <1> 
  6529 00002766 8816[F527]          <1> 	mov [.bar_length], dl
  6530 0000276A 5A                  <1> 	pop dx
  6531                              <1> 
  6532 0000276B 50                  <1> 	push ax
  6533 0000276C 52                  <1> 	push dx
  6534                              <1> 
  6535                              <1> ; ==================== draw blank bar =================
  6536 0000276D 8A26[F527]          <1> 	mov ah, [.bar_length]
  6537 00002771 B020                <1> 	mov al, ' '
  6538                              <1> 
  6539                              <1> .loop_draw_blank:
  6540 00002773 E8C0FF              <1> 	call window_draw_char
  6541 00002776 FECC                <1> 	dec ah
  6542                              <1> 
  6543 00002778 803E[F427]00        <1> 	cmp byte [.bar_type], 0
  6544 0000277D 7405                <1> 	jz .horiz2
  6545 0000277F FEC6                <1> 	inc dh
  6546 00002781 E90200              <1> 	jmp near .cont_draw_blank
  6547                              <1> .horiz2:
  6548 00002784 FEC2                <1> 	inc dl
  6549                              <1> 
  6550                              <1> .cont_draw_blank:
  6551 00002786 08E4                <1> 	or ah, ah
  6552 00002788 75E9                <1> 	jnz .loop_draw_blank
  6553                              <1> 
  6554 0000278A 803E[F427]00        <1> 	cmp byte [.bar_type], 0
  6555 0000278F 7406                <1> 	jz .horiz3
  6556 00002791 B81E1F              <1> 	mov ax, 0x1f1e
  6557 00002794 E90300              <1> 	jmp near .draw_arrow
  6558                              <1> .horiz3:
  6559 00002797 B83C3E              <1> 	mov ax, '<>'
  6560                              <1> 
  6561                              <1> .draw_arrow:
  6562 0000279A 5A                  <1> 	pop dx
  6563 0000279B 52                  <1> 	push dx
  6564                              <1> 
  6565 0000279C E897FF              <1> 	call window_draw_char
  6566 0000279F 86C4                <1> 	xchg al, ah
  6567                              <1> 
  6568 000027A1 803E[F427]00        <1> 	cmp byte [.bar_type], 0
  6569 000027A6 7409                <1> 	jz .horiz4
  6570 000027A8 0236[F527]          <1> 	add dh, [.bar_length]
  6571 000027AC FECE                <1> 	dec dh
  6572 000027AE E90600              <1> 	jmp near .draw_end_arrow
  6573                              <1> .horiz4:
  6574 000027B1 0216[F527]          <1> 	add dl, [.bar_length]
  6575 000027B5 FECA                <1> 	dec dl
  6576                              <1> .draw_end_arrow:
  6577                              <1> 
  6578 000027B7 E87CFF              <1> 	call window_draw_char
  6579 000027BA 5A                  <1> 	pop dx
  6580                              <1> 
  6581                              <1> ; ================= draw scroll block ===============
  6582 000027BB 59                  <1> 	pop cx
  6583 000027BC 380E[F527]          <1> 	cmp [.bar_length], cl
  6584 000027C0 7330                <1> 	jae .no_cursor
  6585 000027C2 803E[F527]03        <1> 	cmp byte [.bar_length], 3
  6586 000027C7 7229                <1> 	jb .no_cursor
  6587                              <1> 
  6588 000027C9 0FB6C5              <1> 	movzx ax, ch			; block position =
  6589 000027CC 8A2E[F527]          <1> 	mov ch, [.bar_length]		; cur value * bar length / value max
  6590 000027D0 80ED02              <1> 	sub ch, 2			; 
  6591 000027D3 F6E5                <1> 	mul ch				;
  6592 000027D5 F6F1                <1> 	div cl				;
  6593                              <1> 
  6594 000027D7 803E[F427]00        <1> 	cmp byte [.bar_type], 0
  6595 000027DC 7407                <1> 	jz .horiz5
  6596 000027DE 00C6                <1> 	add dh, al
  6597 000027E0 FEC6                <1> 	inc dh
  6598 000027E2 E90400              <1> 	jmp near .draw_scroll_block
  6599                              <1> .horiz5:
  6600 000027E5 00C2                <1> 	add dl, al
  6601 000027E7 FEC2                <1> 	inc dl
  6602                              <1> 
  6603                              <1> .draw_scroll_block:
  6604 000027E9 B04F                <1> 	mov al, 'O'
  6605 000027EB 31C9                <1> 	xor cx, cx
  6606 000027ED FEC1                <1> 	inc cl
  6607 000027EF E844FF              <1> 	call window_draw_char
  6608                              <1> 
  6609                              <1> .no_cursor:
  6610 000027F2 61                  <1> 	popa
  6611 000027F3 C3                  <1> 	ret
  6612                              <1> 
  6613 000027F4 00                  <1> .bar_type	db 0		; 1 = vertical, 0 =horizontal
  6614 000027F5 00                  <1> .bar_length	db 0
  6615                              <1> 
  6616                              <1> 
  6617                              <1> ;=============================================================================
  6618                              <1> ; window_initialize ---- initialize the window system.
  6619                              <1> ; input:
  6620                              <1> ;	none
  6621                              <1> ; output:
  6622                              <1> ;	none
  6623                              <1> ;=============================================================================
  6624                              <1> window_initialize:
  6625 000027F6 60                  <1> 	pusha
  6626 000027F7 30C0                <1> 	xor al, al
  6627 000027F9 BF[7E2A]            <1> 	mov di, ui_tmp.def_root_win
  6628 000027FC B91A00              <1> 	mov cx, SIZE_OF_STRUC_WINDOW
  6629 000027FF E82F08              <1> 	call clear_memory
  6630 00002802 C60509              <1> 	mov byte [di], WINFLAG_OPEN | WINFLAG_NO_FOCUS
  6631 00002805 C7851800[1728]      <1> 	mov word [di + struc_window.draw_body_proc], window_clear_win_area
  6632 0000280B A1[ED2A]            <1> 	mov ax, [ui_screen_size]
  6633 0000280E 894508              <1> 	mov [di + struc_window.win_size], ax
  6634                              <1> 
  6635 00002811 893E[7C2A]          <1> 	mov [ui_tmp.root_win], di
  6636 00002815 61                  <1> 	popa
  6637 00002816 C3                  <1> 	ret
  6638                              <1> 
  6639                              <1> 
  6640                              <1> ;=============================================================================
  6641                              <1> ; window_clear_win_area:
  6642                              <1> ; input:
  6643                              <1> ;	ds:si -> root win
  6644                              <1> ; output:
  6645                              <1> ;	none
  6646                              <1> ;=============================================================================
  6647                              <1> window_clear_win_area:
  6648 00002817 60                  <1> 	pusha
  6649 00002818 8B4C06              <1> 	mov cx, [si + struc_window.win_pos]
  6650 0000281B 8B5408              <1> 	mov dx, [si + struc_window.win_size]
  6651 0000281E 01CA                <1> 	add dx, cx
  6652 00002820 81EA0101            <1> 	sub dx, 0x0101
  6653 00002824 8A7C04              <1> 	mov bh, [si + struc_window.win_attr]
  6654 00002827 E87AF6              <1> 	call clear_screen
  6655 0000282A 61                  <1> 	popa
  6656 0000282B C3                  <1> 	ret
  6657                              <1> 
  6658                              <1> ;=============================================================================
  6659                              <1> ; window_execute ---- execute the  window system, no return.
  6660                              <1> ; input:
  6661                              <1> ;	ds:bx -> pointer to root window
  6662                              <1> ;	ds:si -> pointer to current window
  6663                              <1> ; output:
  6664                              <1> ;	none
  6665                              <1> ;=============================================================================
  6666                              <1> window_execute:
  6667 0000282C 09DB                <1> 	or bx, bx
  6668 0000282E 7503                <1> 	jnz .has_root
  6669 00002830 BB[7E2A]            <1> 	mov bx, ui_tmp.def_root_win
  6670                              <1> .has_root:
  6671 00002833 09F6                <1> 	or si, si
  6672 00002835 742E                <1> 	jz .end
  6673                              <1> 
  6674 00002837 87F3                <1> 	xchg si, bx
  6675 00002839 E8B101              <1> 	call winlist_setroot
  6676 0000283C E895FE              <1> 	call window_draw_window
  6677 0000283F 87F3                <1> 	xchg si, bx
  6678                              <1> 
  6679                              <1> .loop_exec:
  6680 00002841 F60408              <1> 	test byte [si], WINFLAG_NO_FOCUS
  6681 00002844 7510                <1> 	jnz .find_focusable
  6682                              <1> 
  6683 00002846 E81D00              <1> 	call window_run
  6684 00002849 8B36[7A2A]          <1> 	mov si, [ui_tmp.focus_win]
  6685 0000284D 09F6                <1> 	or si, si
  6686 0000284F 7414                <1> 	jz .end
  6687                              <1> 
  6688 00002851 E84E02              <1> 	call winlist_findwin
  6689 00002854 7208                <1> 	jc .reset_focus
  6690                              <1> 
  6691                              <1> .find_focusable:
  6692 00002856 E85F02              <1> 	call winlist_find_focusable
  6693 00002859 09F6                <1> 	or si, si
  6694 0000285B 75E4                <1> 	jnz .loop_exec
  6695 0000285D C3                  <1> 	ret
  6696                              <1> 
  6697                              <1> .reset_focus:
  6698 0000285E E8FB01              <1> 	call winlist_findtop
  6699 00002861 89FE                <1> 	mov si, di
  6700 00002863 EBDC                <1> 	jmp short .loop_exec
  6701                              <1> .end:
  6702 00002865 C3                  <1> 	ret
  6703                              <1> 
  6704                              <1> ;=============================================================================
  6705                              <1> ; window_run ---- run a window, open it, and loop get key until the window
  6706                              <1> ;                 is closed (WINFLAG_OPEN is cleared). It passes the key to 
  6707                              <1> ;                 function window_event_handle. If window_event_handle failed
  6708                              <1> ;                 to handle this key, then the key will be passed to its 
  6709                              <1> ;                 parent window.
  6710                              <1> ; input:
  6711                              <1> ;	ds:si -> pointer to struc_window
  6712                              <1> ; output:
  6713                              <1> ;	none
  6714                              <1> ;=============================================================================
  6715                              <1> window_run:
  6716 00002866 E83902              <1> 	call winlist_findwin
  6717 00002869 720E                <1> 	jc .run_this_win
  6718                              <1> 
  6719 0000286B F6440101            <1> 	test byte [si + 1], WINFLAG_HI_RUNNING
  6720 0000286F 7408                <1> 	jz .run_this_win
  6721                              <1> 
  6722 00002871 8936[7A2A]          <1> 	mov [ui_tmp.focus_win], si
  6723 00002875 E8F601              <1> 	call winlist_raise
  6724 00002878 C3                  <1> 	ret
  6725                              <1> 
  6726                              <1> .run_this_win:
  6727 00002879 60                  <1> 	pusha
  6728 0000287A 804C0101            <1> 	or byte [si + 1], WINFLAG_HI_RUNNING
  6729                              <1> 
  6730 0000287E FF36[7A2A]          <1> 	push word [ui_tmp.focus_win]
  6731 00002882 E82D00              <1> 	call window_open
  6732                              <1> 
  6733                              <1> .loop_run:	
  6734 00002885 3936[7A2A]          <1> 	cmp [ui_tmp.focus_win], si		; if current win is switched
  6735 00002889 7520                <1> 	jne .end_run				; just return.
  6736                              <1> 
  6737 0000288B E822F2              <1> 	call get_event
  6738 0000288E 80FCF0              <1> 	cmp ah, EVTCODE_COMMAND
  6739 00002891 720A                <1> 	jb .keycode
  6740 00002893 F6C404              <1> 	test ah, EVTCODE_BROADCAST
  6741 00002896 7405                <1> 	jz .keycode
  6742 00002898 E83102              <1> 	call winlist_broadcast_event
  6743 0000289B EB03                <1> 	jmp short .cont_run
  6744                              <1> .keycode:
  6745 0000289D E8E400              <1> 	call window_event_dispatcher
  6746                              <1> .cont_run:
  6747 000028A0 F60401              <1> 	test byte [si], WINFLAG_OPEN
  6748 000028A3 75E0                <1> 	jnz .loop_run
  6749                              <1> 
  6750 000028A5 8F06[7A2A]          <1> 	pop word [ui_tmp.focus_win]		; if window is closed, restore
  6751 000028A9 EB01                <1> 	jmp short .end				; focus_win and return.
  6752                              <1> 
  6753                              <1> .end_run:
  6754 000028AB 58                  <1> 	pop ax
  6755                              <1> .end:
  6756 000028AC 806401FE            <1> 	and byte [si + 1], ~ WINFLAG_HI_RUNNING
  6757 000028B0 61                  <1> 	popa
  6758 000028B1 C3                  <1> 	ret
  6759                              <1> 
  6760                              <1> 
  6761                              <1> ;=============================================================================
  6762                              <1> ; window_open ---- open a window, draw the window and set flag WINFLAG_OPEN, 
  6763                              <1> ;                  and insert it into the windows list.
  6764                              <1> ; input:
  6765                              <1> ;	ds:si -> pointer to struc_window
  6766                              <1> ; output:
  6767                              <1> ;	none
  6768                              <1> ;=============================================================================
  6769                              <1> window_open:
  6770 000028B2 60                  <1> 	pusha
  6771 000028B3 E8B801              <1> 	call winlist_raise
  6772 000028B6 800C01              <1> 	or byte [si], WINFLAG_OPEN
  6773 000028B9 E8B901              <1> 	call winlist_set_focus_win
  6774 000028BC 61                  <1> 	popa
  6775 000028BD C3                  <1> 	ret
  6776                              <1> 
  6777                              <1> ;=============================================================================
  6778                              <1> ; window_close ---- close a window, clear flag WINFLAG_OPEN, and remove it
  6779                              <1> ;                   from the windows list.
  6780                              <1> ; input:
  6781                              <1> ;	ds:si -> pointer to struc_window
  6782                              <1> ; output:
  6783                              <1> ;	none
  6784                              <1> ;=============================================================================
  6785                              <1> window_close:
  6786 000028BE 60                  <1> 	pusha
  6787 000028BF E86A01              <1> 	call winlist_remove
  6788 000028C2 8024FE              <1> 	and byte [si], ~ WINFLAG_OPEN
  6789 000028C5 E8D7FD              <1> 	call window_draw_all
  6790 000028C8 61                  <1> 	popa
  6791 000028C9 C3                  <1> 	ret
  6792                              <1> 
  6793                              <1> ;=============================================================================
  6794                              <1> ; window_move_up ---- move the window up one row
  6795                              <1> ; input:
  6796                              <1> ;	ds:si -> pointer to struc_window
  6797                              <1> ; output:
  6798                              <1> ;	none
  6799                              <1> ;=============================================================================
  6800                              <1> window_move_up:
  6801 000028CA 50                  <1> 	push ax
  6802 000028CB 8A4407              <1> 	mov al, [si + struc_window.win_pos + 1]
  6803 000028CE 08C0                <1> 	or al, al
  6804 000028D0 7405                <1> 	jz .no_move
  6805 000028D2 FEC8                <1> 	dec al
  6806 000028D4 884407              <1> 	mov [si + struc_window.win_pos + 1], al
  6807                              <1> .no_move:
  6808 000028D7 58                  <1> 	pop ax
  6809 000028D8 C3                  <1> 	ret
  6810                              <1> 
  6811                              <1> ;=============================================================================
  6812                              <1> ; window_move_down ---- move the window down one row
  6813                              <1> ; input:
  6814                              <1> ;	ds:si -> pointer to struc_window
  6815                              <1> ; output:
  6816                              <1> ;	none
  6817                              <1> ;=============================================================================
  6818                              <1> window_move_down:
  6819 000028D9 50                  <1> 	push ax
  6820 000028DA 8A4407              <1> 	mov al, [si + struc_window.win_pos + 1]
  6821 000028DD 8A26[EE2A]          <1> 	mov ah, [ui_screen_height]
  6822 000028E1 FECC                <1> 	dec ah
  6823                              <1> 
  6824 000028E3 38E0                <1> 	cmp al, ah
  6825 000028E5 7305                <1> 	jae .no_move
  6826 000028E7 FEC0                <1> 	inc al
  6827 000028E9 884407              <1> 	mov [si + struc_window.win_pos + 1], al
  6828                              <1> .no_move:
  6829 000028EC 58                  <1> 	pop ax
  6830 000028ED C3                  <1> 	ret
  6831                              <1> 
  6832                              <1> 
  6833                              <1> ;=============================================================================
  6834                              <1> ; window_move_left ---- move the window left one column
  6835                              <1> ; input:
  6836                              <1> ;	ds:si -> pointer to struc_window
  6837                              <1> ; output:
  6838                              <1> ;	none
  6839                              <1> ;=============================================================================
  6840                              <1> window_move_left:
  6841 000028EE 50                  <1> 	push ax
  6842 000028EF 8A4406              <1> 	mov al, [si + struc_window.win_pos]
  6843 000028F2 08C0                <1> 	or al, al
  6844 000028F4 7405                <1> 	jz .no_move
  6845 000028F6 FEC8                <1> 	dec al
  6846 000028F8 884406              <1> 	mov [si + struc_window.win_pos], al
  6847                              <1> .no_move:
  6848 000028FB 58                  <1> 	pop ax
  6849 000028FC C3                  <1> 	ret
  6850                              <1> 
  6851                              <1> 
  6852                              <1> ;=============================================================================
  6853                              <1> ; window_move_right ---- move the window right one column
  6854                              <1> ; input:
  6855                              <1> ;	ds:si -> pointer to struc_window
  6856                              <1> ; output:
  6857                              <1> ;	none
  6858                              <1> ;=============================================================================
  6859                              <1> window_move_right:
  6860 000028FD 50                  <1> 	push ax
  6861 000028FE 8A4406              <1> 	mov al, [si + struc_window.win_pos]
  6862 00002901 8A26[ED2A]          <1> 	mov ah, [ui_screen_width]
  6863 00002905 2A6408              <1> 	sub ah, [si + struc_window.win_size]
  6864 00002908 80EC02              <1> 	sub ah, 2
  6865                              <1> 
  6866 0000290B 38E0                <1> 	cmp al, ah
  6867 0000290D 7305                <1> 	jae .no_move
  6868 0000290F FEC0                <1> 	inc al
  6869 00002911 884406              <1> 	mov [si + struc_window.win_pos], al
  6870                              <1> .no_move:
  6871 00002914 58                  <1> 	pop ax
  6872 00002915 C3                  <1> 	ret
  6873                              <1> 
  6874                              <1> 
  6875                              <1> ;=============================================================================
  6876                              <1> ; window_switch_window ---- switch to the next window
  6877                              <1> ; input:
  6878                              <1> ;	ds:si -> pointer to current window
  6879                              <1> ; output:
  6880                              <1> ;	none
  6881                              <1> ;=============================================================================
  6882                              <1> window_switch_window:
  6883 00002916 60                  <1> 	pusha
  6884 00002917 F60402              <1> 	test byte [si], WINFLAG_MODAL
  6885 0000291A 7511                <1> 	jnz .no_switch
  6886 0000291C E88301              <1> 	call winlist_findwin
  6887 0000291F 720C                <1> 	jc .no_switch
  6888 00002921 8B36[7C2A]          <1> 	mov si, [ui_tmp.root_win]
  6889 00002925 09F6                <1> 	or si, si
  6890 00002927 7404                <1> 	jz .no_switch
  6891                              <1> 
  6892 00002929 8936[7A2A]          <1> 	mov [ui_tmp.focus_win], si
  6893                              <1> 
  6894                              <1> .no_switch:
  6895 0000292D 61                  <1> 	popa
  6896 0000292E C3                  <1> 	ret
  6897                              <1> 
  6898                              <1> ;=============================================================================
  6899                              <1> ; move a window to center of the screen.
  6900                              <1> ;input:
  6901                              <1> ;	ds:si -> pointer to window
  6902                              <1> ;output:
  6903                              <1> ;	none
  6904                              <1> ;=============================================================================
  6905                              <1> window_center_window:
  6906 0000292F 60                  <1> 	pusha
  6907 00002930 8B5408              <1> 	mov dx, [si + struc_window.win_size]
  6908 00002933 8B0E[ED2A]          <1> 	mov cx, [ui_screen_size]                   ; calculate the coordinate
  6909                              <1> 
  6910 00002937 28F5                <1> 	sub ch, dh                              ; of input box.
  6911 00002939 D0ED                <1> 	shr ch, 1                               ; cx = top left pos
  6912 0000293B 28D1                <1> 	sub cl, dl                              ; 
  6913 0000293D D0E9                <1> 	shr cl, 1                               ;
  6914                              <1> 
  6915 0000293F 894C06              <1> 	mov [si + struc_window.win_pos], cx
  6916 00002942 61                  <1> 	popa
  6917 00002943 C3                  <1> 	ret
  6918                              <1> 
  6919                              <1> 
  6920                              <1> ;=============================================================================
  6921                              <1> ; window_default_event_handle ---- default event handle for a normal window, it
  6922                              <1> ;                           handles some normal events, such as move window.
  6923                              <1> ; input:
  6924                              <1> ;	ax    -> keycode
  6925                              <1> ;	ds:si -> pointer to struc_window
  6926                              <1> ; output:
  6927                              <1> ;	cf = 0, success
  6928                              <1> ;	cf = 1, fail, no such action
  6929                              <1> ;=============================================================================
  6930                              <1> window_default_event_handle:
  6931 00002944 60                  <1> 	pusha
  6932 00002945 B90E00              <1> 	mov cx, WINDOW_DEF_ACTION_NUM
  6933 00002948 BB[F32A]            <1> 	mov bx, window_def_action_table
  6934 0000294B E81C00              <1> 	call window_generic_event_handle
  6935 0000294E 61                  <1> 	popa
  6936 0000294F C3                  <1> 	ret
  6937                              <1> 
  6938                              <1> ;=============================================================================
  6939                              <1> ; window_event_handle ----  event handle for a normal window, it finds 
  6940                              <1> ;                           the corresponding action for a key event from
  6941                              <1> ;                           action_table then call window_do_action to run it.
  6942                              <1> ;                           If the event is not in action_table, then
  6943                              <1> ;                           .defkey_handle will be called to handle it.
  6944                              <1> ; input:
  6945                              <1> ;	ax    -> keycode
  6946                              <1> ;	ds:si -> pointer to struc_window
  6947                              <1> ; output:
  6948                              <1> ;	cf = 0, success
  6949                              <1> ;	cf = 1, fail, no such action
  6950                              <1> ;=============================================================================
  6951                              <1> window_event_handle:
  6952 00002950 60                  <1> 	pusha
  6953 00002951 8B5C12              <1> 	mov bx, [si + struc_window.act_table]
  6954 00002954 8B4C10              <1> 	mov cx, [si + struc_window.act_num]
  6955 00002957 E81000              <1> 	call window_generic_event_handle
  6956 0000295A 730C                <1> 	jnc .success
  6957 0000295C 8B5C14              <1> 	mov bx, [si + struc_window.default_event_handle]
  6958 0000295F 09DB                <1> 	or bx, bx
  6959 00002961 7404                <1> 	jz .failed
  6960 00002963 FFD3                <1> 	call bx
  6961 00002965 7301                <1> 	jnc .success
  6962                              <1> .failed:
  6963 00002967 F9                  <1> 	stc
  6964                              <1> .success:
  6965 00002968 61                  <1> 	popa
  6966 00002969 C3                  <1> 	ret
  6967                              <1> 
  6968                              <1> ;=============================================================================
  6969                              <1> ; window_generic_event_handle ---- generic event handle, it find a key from 
  6970                              <1> ;                                  an action list, then run it.
  6971                              <1> ; input:
  6972                              <1> ;	ax    -> keycode
  6973                              <1> ;	ds:si -> pointer to struc_window
  6974                              <1> ;	ds:bx -> action list
  6975                              <1> ;	cx    -> action number
  6976                              <1> ; output:
  6977                              <1> ;	cf = 0, success
  6978                              <1> ;	cf = 1, fail, no such action
  6979                              <1> ;=============================================================================
  6980                              <1> window_generic_event_handle:
  6981 0000296A 09C9                <1> 	or cx, cx
  6982 0000296C 7414                <1> 	jz .no_action
  6983 0000296E 09DB                <1> 	or bx, bx
  6984 00002970 7410                <1> 	jz .no_action
  6985                              <1> 
  6986                              <1> .loop_find_act:
  6987 00002972 394701              <1> 	cmp [bx + struc_action.keycode], ax
  6988 00002975 7505                <1> 	jne .cont_find
  6989 00002977 E82700              <1> 	call window_do_action
  6990 0000297A F8                  <1> 	clc
  6991 0000297B C3                  <1> 	ret
  6992                              <1> 
  6993                              <1> .cont_find:
  6994 0000297C 81C30500            <1> 	add bx, SIZE_OF_STRUC_ACTION
  6995 00002980 E2F0                <1> 	loop .loop_find_act
  6996                              <1> 
  6997                              <1> .no_action:
  6998 00002982 F9                  <1> 	stc
  6999 00002983 C3                  <1> 	ret
  7000                              <1> 
  7001                              <1> ;=============================================================================
  7002                              <1> ; window_event_dispatcher ---- dispatch event to event handle 
  7003                              <1> ; input:
  7004                              <1> ;	ax    -> keycode
  7005                              <1> ;	ds:si -> pointer to struc_window
  7006                              <1> ; output:
  7007                              <1> ;	cf = 0, success
  7008                              <1> ;	cf = 1, fail, no such action
  7009                              <1> ;=============================================================================
  7010                              <1> window_event_dispatcher:
  7011 00002984 60                  <1> 	pusha
  7012 00002985 8B5C16              <1> 	mov bx, [si + struc_window.event_handle]
  7013 00002988 09DB                <1> 	or bx, bx
  7014 0000298A 7406                <1> 	jz .no_event_handle
  7015                              <1> 
  7016 0000298C 56                  <1> 	push si
  7017 0000298D FFD3                <1> 	call bx
  7018 0000298F 5E                  <1> 	pop si
  7019                              <1> 
  7020 00002990 730D                <1> 	jnc .action_ok
  7021                              <1> 
  7022                              <1> .no_event_handle:
  7023 00002992 8B740A              <1> 	mov si, [si + struc_window.parent_win]
  7024 00002995 09F6                <1> 	or si, si
  7025 00002997 7405                <1> 	jz .no_parent
  7026 00002999 E8E8FF              <1> 	call window_event_dispatcher
  7027 0000299C 7301                <1> 	jnc .action_ok
  7028                              <1> 
  7029                              <1> .no_parent:
  7030 0000299E F9                  <1> 	stc
  7031                              <1> 
  7032                              <1> .action_ok:
  7033 0000299F 61                  <1> 	popa
  7034 000029A0 C3                  <1> 	ret
  7035                              <1> 
  7036                              <1> ;=============================================================================
  7037                              <1> ; window_do_action ---- do a window action
  7038                              <1> ; input:
  7039                              <1> ;	ax    =  event code
  7040                              <1> ;	ds:si -> pointer to struc_window
  7041                              <1> ;	ds:bx -> pointer to struc_action
  7042                              <1> ; output:
  7043                              <1> ;	none
  7044                              <1> ;=============================================================================
  7045                              <1> window_do_action:
  7046 000029A1 60                  <1> 	pusha
  7047                              <1> 
  7048 000029A2 09F6                <1> 	or si, si
  7049 000029A4 7445                <1> 	jz .end
  7050 000029A6 09DB                <1> 	or bx, bx
  7051 000029A8 7441                <1> 	jz .end
  7052                              <1> 
  7053 000029AA 8A17                <1> 	mov dl, [bx]
  7054                              <1> 
  7055 000029AC F6C2F0              <1> 	test dl, ACTFLAG_AUTHS		; check action flags
  7056 000029AF 7409                <1> 	jz .no_auth
  7057                              <1> 
  7058 000029B1 60                  <1> 	pusha
  7059 000029B2 88D0                <1> 	mov al, dl
  7060 000029B4 E845F1              <1> 	call main_auth_action		; check if the action is ready to do
  7061                              <1> 					; al = auth type
  7062 000029B7 61                  <1> 	popa
  7063 000029B8 720B                <1> 	jc .no_action
  7064                              <1> 
  7065                              <1> .no_auth:
  7066 000029BA 8B5F03              <1> 	mov bx, [bx + struc_action.func]
  7067 000029BD 09DB                <1> 	or bx, bx
  7068 000029BF 7404                <1> 	jz .no_action
  7069                              <1> 
  7070 000029C1 60                  <1> 	pusha
  7071 000029C2 FFD3                <1> 	call bx				; do the action
  7072 000029C4 61                  <1> 	popa
  7073                              <1> 
  7074                              <1> .no_action:
  7075                              <1> 
  7076 000029C5 F6C201              <1> 	test dl, ACTFLAG_CLOSE_WIN
  7077 000029C8 7405                <1> 	jz .no_close
  7078 000029CA E8F1FE              <1> 	call window_close
  7079 000029CD EB1C                <1> 	jmp short .end
  7080                              <1> .no_close:
  7081 000029CF F6C202              <1> 	test dl, ACTFLAG_REDRAW_BODY
  7082 000029D2 7405                <1> 	jz .no_redraw_body
  7083 000029D4 E8DCFC              <1> 	call window_draw_body
  7084 000029D7 EB12                <1> 	jmp short .end
  7085                              <1> .no_redraw_body:
  7086 000029D9 F6C204              <1> 	test dl, ACTFLAG_REDRAW_WIN
  7087 000029DC 7405                <1> 	jz .no_redraw_win
  7088 000029DE E8F3FC              <1> 	call window_draw_window
  7089 000029E1 EB08                <1> 	jmp short .end
  7090                              <1> .no_redraw_win:
  7091 000029E3 F6C208              <1> 	test dl, ACTFLAG_REDRAW_SCR
  7092 000029E6 7403                <1> 	jz .end
  7093 000029E8 E8B4FC              <1> 	call window_draw_all
  7094                              <1> .end:
  7095 000029EB 61                  <1> 	popa
  7096 000029EC C3                  <1> 	ret
  7097                              <1> 
  7098                              <1> ;=============================================================================
  7099                              <1> ; winlist_setroot ---- set root window
  7100                              <1> ; input:
  7101                              <1> ;	ds:si -> pointer to root window
  7102                              <1> ; output:
  7103                              <1> ;	none
  7104                              <1> ;=============================================================================
  7105                              <1> winlist_setroot:
  7106 000029ED 53                  <1> 	push bx
  7107                              <1> 
  7108 000029EE 09F6                <1> 	or si, si
  7109 000029F0 741A                <1> 	jz .invalid_root
  7110                              <1> 
  7111 000029F2 8B1E[7C2A]          <1> 	mov bx, [ui_tmp.root_win]
  7112 000029F6 09DB                <1> 	or bx, bx
  7113 000029F8 7403                <1> 	jz .no_root
  7114 000029FA 8B5F0C              <1> 	mov bx, [bx + struc_window.next_win]
  7115                              <1> 
  7116                              <1> .no_root:
  7117 000029FD 8936[7C2A]          <1> 	mov [ui_tmp.root_win], si
  7118 00002A01 895C0C              <1> 	mov [si + struc_window.next_win], bx
  7119 00002A04 31DB                <1> 	xor bx, bx
  7120 00002A06 895C0E              <1> 	mov [si + struc_window.previous_win], bx
  7121 00002A09 895C0A              <1> 	mov [si + struc_window.parent_win], bx
  7122                              <1> 
  7123                              <1> .invalid_root:
  7124 00002A0C 5B                  <1> 	pop bx
  7125 00002A0D C3                  <1> 	ret
  7126                              <1> 
  7127                              <1> ;=============================================================================
  7128                              <1> ; winlist_insert ---- insert a window
  7129                              <1> ; input:
  7130                              <1> ;	ds:si -> pointer to the window
  7131                              <1> ; output:
  7132                              <1> ;	none
  7133                              <1> ;=============================================================================
  7134                              <1> winlist_insert:
  7135 00002A0E 57                  <1> 	push di
  7136 00002A0F 09F6                <1> 	or si, si
  7137 00002A11 7417                <1> 	jz .invalid_win
  7138 00002A13 E88C00              <1> 	call winlist_findwin
  7139 00002A16 7312                <1> 	jnc .invalid_win
  7140                              <1> 
  7141 00002A18 E84100              <1> 	call winlist_findtop
  7142 00002A1B 09FF                <1> 	or di, di
  7143 00002A1D 740B                <1> 	jz .invalid_win
  7144                              <1> 
  7145 00002A1F 89750C              <1> 	mov [di + struc_window.next_win], si
  7146 00002A22 897C0E              <1> 	mov [si + struc_window.previous_win], di
  7147 00002A25 31FF                <1> 	xor di, di
  7148 00002A27 897C0C              <1> 	mov [si + struc_window.next_win], di
  7149                              <1> 
  7150                              <1> .invalid_win:
  7151 00002A2A 5F                  <1> 	pop di
  7152 00002A2B C3                  <1> 	ret
  7153                              <1> 
  7154                              <1> ;=============================================================================
  7155                              <1> ; winlist_remove ---- remove a window
  7156                              <1> ; input:
  7157                              <1> ;	ds:si -> pointer to the window
  7158                              <1> ; output:
  7159                              <1> ;	none
  7160                              <1> ;=============================================================================
  7161                              <1> winlist_remove:
  7162 00002A2C 09F6                <1> 	or si, si
  7163 00002A2E 742B                <1> 	jz .invalid_win
  7164 00002A30 3936[7C2A]          <1> 	cmp [ui_tmp.root_win], si
  7165 00002A34 7425                <1> 	je .invalid_win
  7166 00002A36 E86900              <1> 	call winlist_findwin
  7167 00002A39 7220                <1> 	jc .invalid_win
  7168                              <1> 
  7169 00002A3B 53                  <1> 	push bx
  7170 00002A3C 56                  <1> 	push si
  7171 00002A3D 8B5C0C              <1> 	mov bx, [si + struc_window.next_win]
  7172 00002A40 8B740E              <1> 	mov si ,[si + struc_window.previous_win]
  7173 00002A43 09DB                <1> 	or bx, bx
  7174 00002A45 7403                <1> 	jz .no_next
  7175 00002A47 89770E              <1> 	mov [bx + struc_window.previous_win], si
  7176                              <1> .no_next:
  7177 00002A4A 09F6                <1> 	or si, si
  7178 00002A4C 7403                <1> 	jz .no_previous
  7179 00002A4E 895C0C              <1> 	mov [si + struc_window.next_win], bx
  7180                              <1> .no_previous:
  7181 00002A51 5E                  <1> 	pop si
  7182 00002A52 31DB                <1> 	xor bx, bx
  7183 00002A54 895C0C              <1> 	mov [si + struc_window.next_win], bx
  7184 00002A57 895C0E              <1> 	mov [si + struc_window.previous_win], bx
  7185 00002A5A 5B                  <1> 	pop bx
  7186                              <1> 
  7187                              <1> .invalid_win:
  7188 00002A5B C3                  <1> 	ret
  7189                              <1> 
  7190                              <1> ;=============================================================================
  7191                              <1> ; winlist_findtop ---- find the top window
  7192                              <1> ; input:
  7193                              <1> ;	none
  7194                              <1> ; output:
  7195                              <1> ;	ds:di -> the top window
  7196                              <1> ;=============================================================================
  7197                              <1> winlist_findtop:
  7198 00002A5C 50                  <1> 	push ax
  7199 00002A5D 8B3E[7C2A]          <1> 	mov di, [ui_tmp.root_win]
  7200                              <1> 
  7201                              <1> .loop_find:
  7202 00002A61 8B450C              <1> 	mov ax, [di + struc_window.next_win]
  7203 00002A64 09C0                <1> 	or ax, ax
  7204 00002A66 7404                <1> 	jz .find_it
  7205 00002A68 89C7                <1> 	mov di, ax
  7206 00002A6A EBF5                <1> 	jmp short .loop_find
  7207                              <1> 
  7208                              <1> .find_it:
  7209 00002A6C 58                  <1> 	pop ax
  7210 00002A6D C3                  <1> 	ret
  7211                              <1> 
  7212                              <1> ;=============================================================================
  7213                              <1> ; winlist_raise ---- raise a window to top
  7214                              <1> ; input:
  7215                              <1> ;	ds:si -> the window
  7216                              <1> ; output:
  7217                              <1> ;	none
  7218                              <1> ;=============================================================================
  7219                              <1> winlist_raise:
  7220 00002A6E E8BBFF              <1> 	call winlist_remove
  7221 00002A71 E89AFF              <1> 	call winlist_insert
  7222 00002A74 C3                  <1> 	ret
  7223                              <1> 
  7224                              <1> ;=============================================================================
  7225                              <1> ; winlist_set_focus_win ---- set the focus window
  7226                              <1> ; input:
  7227                              <1> ;	ds:si -> the window
  7228                              <1> ; output:
  7229                              <1> ;	none
  7230                              <1> ;=============================================================================
  7231                              <1> winlist_set_focus_win:
  7232 00002A75 53                  <1> 	push bx
  7233 00002A76 56                  <1> 	push si
  7234 00002A77 8B36[7A2A]          <1> 	mov si, [ui_tmp.focus_win]
  7235 00002A7B 89F3                <1> 	mov bx, si
  7236 00002A7D E82200              <1> 	call winlist_findwin
  7237 00002A80 5E                  <1> 	pop si
  7238 00002A81 720A                <1> 	jc .ok
  7239                              <1> 
  7240 00002A83 F60402              <1> 	test byte [si], WINFLAG_MODAL
  7241 00002A86 7505                <1> 	jnz .ok
  7242 00002A88 F60702              <1> 	test byte [bx], WINFLAG_MODAL
  7243 00002A8B 7509                <1> 	jnz .end
  7244                              <1> 
  7245                              <1> .ok:
  7246 00002A8D E81200              <1> 	call winlist_findwin
  7247 00002A90 7204                <1> 	jc .end
  7248 00002A92 8936[7A2A]          <1> 	mov [ui_tmp.focus_win], si
  7249                              <1> .end:
  7250 00002A96 8B36[7A2A]          <1> 	mov si, [ui_tmp.focus_win]
  7251 00002A9A E8D1FF              <1> 	call winlist_raise
  7252 00002A9D E8FFFB              <1> 	call window_draw_all
  7253 00002AA0 5B                  <1> 	pop bx
  7254 00002AA1 C3                  <1> 	ret
  7255                              <1> 
  7256                              <1> ;=============================================================================
  7257                              <1> ; winlist_findwin ---- find a window in winlist
  7258                              <1> ; input:
  7259                              <1> ;	ds:si -> the window
  7260                              <1> ; output:
  7261                              <1> ;	cf = 0  found
  7262                              <1> ;	cf = 1  not found
  7263                              <1> ;=============================================================================
  7264                              <1> winlist_findwin:
  7265 00002AA2 53                  <1> 	push bx
  7266 00002AA3 8B1E[7C2A]          <1> 	mov bx, [ui_tmp.root_win]
  7267                              <1> .loop_find:
  7268 00002AA7 39F3                <1> 	cmp bx, si
  7269 00002AA9 740A                <1> 	je .found
  7270 00002AAB 8B5F0C              <1> 	mov bx, [bx + struc_window.next_win]
  7271 00002AAE 09DB                <1> 	or bx, bx
  7272 00002AB0 75F5                <1> 	jnz .loop_find
  7273 00002AB2 F9                  <1> 	stc
  7274 00002AB3 5B                  <1> 	pop bx
  7275 00002AB4 C3                  <1> 	ret
  7276                              <1> .found:
  7277 00002AB5 F8                  <1> 	clc
  7278 00002AB6 5B                  <1> 	pop bx
  7279 00002AB7 C3                  <1> 	ret
  7280                              <1> 
  7281                              <1> ;=============================================================================
  7282                              <1> ; winlist_find_focusable ---- find a focusable window
  7283                              <1> ; input:
  7284                              <1> ;	ds:si -> the first win
  7285                              <1> ; output:
  7286                              <1> ;	ds:si -> the focusable win
  7287                              <1> ;=============================================================================
  7288                              <1> winlist_find_focusable:
  7289 00002AB8 E8E7FF              <1> 	call winlist_findwin
  7290 00002ABB 720C                <1> 	jc .failed
  7291                              <1> 
  7292                              <1> .loop_find:
  7293 00002ABD F60408              <1> 	test byte [si], WINFLAG_NO_FOCUS
  7294 00002AC0 7409                <1> 	jz .found
  7295 00002AC2 8B740C              <1> 	mov si, [si + struc_window.next_win]
  7296 00002AC5 09F6                <1> 	or si, si
  7297 00002AC7 75F4                <1> 	jnz .loop_find
  7298                              <1> .failed:
  7299 00002AC9 31F6                <1> 	xor si, si
  7300                              <1> .found:
  7301 00002ACB C3                  <1> 	ret
  7302                              <1> 
  7303                              <1> 
  7304                              <1> ;=============================================================================
  7305                              <1> ; winlist_broadcast_event ---- broadcast an event to all opened windows
  7306                              <1> ; input:
  7307                              <1> ;	ax = event code
  7308                              <1> ; output:
  7309                              <1> ;	none
  7310                              <1> ;=============================================================================
  7311                              <1> winlist_broadcast_event:
  7312 00002ACC 60                  <1> 	pusha
  7313 00002ACD 8B36[7C2A]          <1> 	mov si, [ui_tmp.root_win]
  7314                              <1> 
  7315                              <1> .loop_broadcast:
  7316 00002AD1 E8B0FE              <1> 	call window_event_dispatcher
  7317 00002AD4 7307                <1> 	jnc .end
  7318 00002AD6 8B740C              <1> 	mov si, [si + struc_window.next_win]
  7319 00002AD9 09F6                <1> 	or si, si
  7320 00002ADB 75F4                <1> 	jnz .loop_broadcast
  7321                              <1> .end:
  7322 00002ADD 61                  <1> 	popa
  7323 00002ADE C3                  <1> 	ret
  7324                              <1> 
  7325                              <1> 
  7326                              <1> %ifndef MAIN
  7327                              <1> get_event:
  7328                              <1> 
  7329                              <1> .loop_get_event:
  7330                              <1> 	call check_keyevent
  7331                              <1> 	or ax, ax
  7332                              <1> 	jz .loop_get_event
  7333                              <1> 	ret
  7334                              <1> 
  7335                              <1> 
  7336                              <1> ;=============================================================================
  7337                              <1> ; main_auth_action  ---- auth an action
  7338                              <1> ; input:
  7339                              <1> ;	al =  auth type
  7340                              <1> ; output:
  7341                              <1> ;	cf =  0 auth ok
  7342                              <1> ;	cf =  1 auth failed.
  7343                              <1> ;=============================================================================
  7344                              <1> main_auth_action:
  7345                              <1> 	clc
  7346                              <1> 	ret
  7347                              <1> %endif
  7348                              <1> 
  7349                              <1> 
  7350                              <1> ;=============================================================================
  7351                              <1> ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Private Data Area >>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  7352                              <1> ;=============================================================================
  7353 00002ADF 006B0159025A038E04- <1> ui_VideoHorizParams dw 0x6B00,0x5901,0x5A02,0x8E03,0x5F04,0x8C05,0x2D13 ;8-wide
  7354 00002AE8 5F058C132D          <1>
  7355                              <1> 
  7356                              <1> ui_screen_size:
  7357 00002AED 5A                  <1> ui_screen_width     db     90
  7358 00002AEE 19                  <1> ui_screen_height    db     25
  7359                              <1> 
  7360 00002AEF 00B8                <1> ui_screen_bufseg     dw     SCR_BUF_SEG0
  7361 00002AF1 00                  <1> ui_screen_page       db     0
  7362 00002AF2 00                  <1> ui_screen_lock       db     0
  7363                              <1> 
  7364                              <1> 
  7365                              <1> window_def_action_table:
  7366 00002AF3 08                  <1> 	db	ACTFLAG_REDRAW_SCR
  7367 00002AF4 008D                <1> 	dw	kbCtrlUp
  7368 00002AF6 [CA28]              <1> 	dw	window_move_up
  7369                              <1> 
  7370 00002AF8 08                  <1> 	db	ACTFLAG_REDRAW_SCR
  7371 00002AF9 E08D                <1> 	dw	kbEnhCtrlUp
  7372 00002AFB [CA28]              <1> 	dw	window_move_up
  7373                              <1> 
  7374 00002AFD 08                  <1> 	db	ACTFLAG_REDRAW_SCR
  7375 00002AFE E047                <1> 	dw	kbEnhHome
  7376 00002B00 [CA28]              <1> 	dw	window_move_up
  7377                              <1> 
  7378 00002B02 08                  <1> 	db	ACTFLAG_REDRAW_SCR
  7379 00002B03 0091                <1> 	dw	kbCtrlDown
  7380 00002B05 [D928]              <1> 	dw	window_move_down
  7381                              <1> 
  7382 00002B07 08                  <1> 	db	ACTFLAG_REDRAW_SCR
  7383 00002B08 E091                <1> 	dw	kbEnhCtrlDown
  7384 00002B0A [D928]              <1> 	dw	window_move_down
  7385                              <1> 
  7386 00002B0C 08                  <1> 	db	ACTFLAG_REDRAW_SCR
  7387 00002B0D E04F                <1> 	dw	kbEnhEnd
  7388 00002B0F [D928]              <1> 	dw	window_move_down
  7389                              <1> 
  7390 00002B11 08                  <1> 	db	ACTFLAG_REDRAW_SCR
  7391 00002B12 0073                <1> 	dw	kbCtrlLeft
  7392 00002B14 [EE28]              <1> 	dw	window_move_left
  7393                              <1> 
  7394 00002B16 08                  <1> 	db	ACTFLAG_REDRAW_SCR
  7395 00002B17 E073                <1> 	dw	kbEnhCtrlLeft
  7396 00002B19 [EE28]              <1> 	dw	window_move_left
  7397                              <1> 
  7398 00002B1B 08                  <1> 	db	ACTFLAG_REDRAW_SCR
  7399 00002B1C E053                <1> 	dw	kbEnhDel
  7400 00002B1E [EE28]              <1> 	dw	window_move_left
  7401                              <1> 
  7402 00002B20 08                  <1> 	db	ACTFLAG_REDRAW_SCR
  7403 00002B21 0074                <1> 	dw	kbCtrlRight
  7404 00002B23 [FD28]              <1> 	dw	window_move_right
  7405                              <1> 
  7406 00002B25 08                  <1> 	db	ACTFLAG_REDRAW_SCR
  7407 00002B26 E074                <1> 	dw	kbEnhCtrlRight
  7408 00002B28 [FD28]              <1> 	dw	window_move_right
  7409                              <1> 
  7410 00002B2A 08                  <1> 	db	ACTFLAG_REDRAW_SCR
  7411 00002B2B E051                <1> 	dw	kbEnhPgDn
  7412 00002B2D [FD28]              <1> 	dw	window_move_right
  7413                              <1> 
  7414 00002B2F 00                  <1> 	db	0
  7415 00002B30 0094                <1> 	dw	kbCtrlTab
  7416 00002B32 [1629]              <1> 	dw	window_switch_window
  7417                              <1> 
  7418 00002B34 00                  <1> 	db	0
  7419 00002B35 00A5                <1> 	dw	kbAltTab
  7420 00002B37 [1629]              <1> 	dw	window_switch_window
  7421                              <1> .end_of_table
  7422                              <1> 
  7423                              <1> inputbox_action_table:
  7424 00002B39 02                  <1> 	db	ACTFLAG_REDRAW_BODY
  7425 00002B3A 080E                <1> 	dw	kbBack
  7426 00002B3C [A822]              <1> 	dw	inputbox_backspace
  7427                              <1> 
  7428 00002B3E 02                  <1> 	db	ACTFLAG_REDRAW_BODY
  7429 00002B3F 0053                <1> 	dw	kbDel
  7430 00002B41 [C222]              <1> 	dw	inputbox_delete
  7431                              <1> 
  7432 00002B43 02                  <1> 	db	ACTFLAG_REDRAW_BODY
  7433 00002B44 E053                <1> 	dw	kbEnhDel
  7434 00002B46 [C222]              <1> 	dw	inputbox_delete
  7435                              <1> 
  7436 00002B48 02                  <1> 	db	ACTFLAG_REDRAW_BODY
  7437 00002B49 0047                <1> 	dw	kbHome
  7438 00002B4B [F922]              <1> 	dw	inputbox_home_key
  7439                              <1> 
  7440 00002B4D 02                  <1> 	db	ACTFLAG_REDRAW_BODY
  7441 00002B4E E047                <1> 	dw	kbEnhHome
  7442 00002B50 [F922]              <1> 	dw	inputbox_home_key
  7443                              <1> 
  7444 00002B52 02                  <1> 	db	ACTFLAG_REDRAW_BODY
  7445 00002B53 004F                <1> 	dw	kbEnd
  7446 00002B55 [EF22]              <1> 	dw	inputbox_end_key
  7447                              <1> 
  7448 00002B57 02                  <1> 	db	ACTFLAG_REDRAW_BODY
  7449 00002B58 E04F                <1> 	dw	kbEnhEnd
  7450 00002B5A [EF22]              <1> 	dw	inputbox_end_key
  7451                              <1> 
  7452 00002B5C 02                  <1> 	db	ACTFLAG_REDRAW_BODY
  7453 00002B5D 004B                <1> 	dw	kbLeft
  7454 00002B5F [E222]              <1> 	dw	inputbox_left_arrow
  7455                              <1> 
  7456 00002B61 02                  <1> 	db	ACTFLAG_REDRAW_BODY
  7457 00002B62 E04B                <1> 	dw	kbEnhLeft
  7458 00002B64 [E222]              <1> 	dw	inputbox_left_arrow
  7459                              <1> 
  7460 00002B66 02                  <1> 	db	ACTFLAG_REDRAW_BODY
  7461 00002B67 004D                <1> 	dw	kbRight
  7462 00002B69 [D322]              <1> 	dw	inputbox_right_arrow
  7463                              <1> 
  7464 00002B6B 02                  <1> 	db	ACTFLAG_REDRAW_BODY
  7465 00002B6C E04D                <1> 	dw	kbEnhRight
  7466 00002B6E [D322]              <1> 	dw	inputbox_right_arrow
  7467                              <1> 
  7468 00002B70 01                  <1> 	db	ACTFLAG_CLOSE_WIN
  7469 00002B71 1B01                <1> 	dw	kbEsc
  7470 00002B73 [0123]              <1> 	dw	inputbox_cancel
  7471                              <1> 
  7472 00002B75 01                  <1> 	db	ACTFLAG_CLOSE_WIN
  7473 00002B76 0D1C                <1> 	dw	kbEnter
  7474 00002B78 [0923]              <1> 	dw	inputbox_enter
  7475                              <1> 
  7476 00002B7A 01                  <1> 	db	ACTFLAG_CLOSE_WIN
  7477 00002B7B 0DE0                <1> 	dw	kbEnhEnter
  7478 00002B7D [0923]              <1> 	dw	inputbox_enter
  7479                              <1> 
  7480                              <1> .end_of_table
  7481                              <1> 
  7482                              <1> listbox_action_table:
  7483 00002B7F 01                  <1> 	db	ACTFLAG_CLOSE_WIN
  7484 00002B80 0D1C                <1> 	dw	kbEnter
  7485 00002B82 0000                <1> 	dw	0
  7486                              <1> 
  7487 00002B84 01                  <1> 	db	ACTFLAG_CLOSE_WIN
  7488 00002B85 0DE0                <1> 	dw	kbEnhEnter
  7489 00002B87 0000                <1> 	dw	0
  7490                              <1> 
  7491 00002B89 01                  <1> 	db	ACTFLAG_CLOSE_WIN
  7492 00002B8A 1B01                <1> 	dw	kbEsc
  7493 00002B8C [9A26]              <1> 	dw	listbox_cancel
  7494                              <1> .end_of_table
  7495                              <1> 
  7496                              <1> menubox_def_action_table:
  7497 00002B8E 02                  <1> 	db	ACTFLAG_REDRAW_BODY
  7498 00002B8F 0048                <1> 	dw	kbUp
  7499 00002B91 [B625]              <1> 	dw	menubox_focus_up
  7500                              <1> 
  7501 00002B93 02                  <1> 	db	ACTFLAG_REDRAW_BODY
  7502 00002B94 E048                <1> 	dw	kbEnhUp
  7503 00002B96 [B625]              <1> 	dw	menubox_focus_up
  7504                              <1> 
  7505 00002B98 02                  <1> 	db	ACTFLAG_REDRAW_BODY
  7506 00002B99 0050                <1> 	dw	kbDown
  7507 00002B9B [E225]              <1> 	dw	menubox_focus_down
  7508                              <1> 
  7509 00002B9D 02                  <1> 	db	ACTFLAG_REDRAW_BODY
  7510 00002B9E E050                <1> 	dw	kbEnhDown
  7511 00002BA0 [E225]              <1> 	dw	menubox_focus_down
  7512                              <1> 
  7513 00002BA2 02                  <1> 	db	ACTFLAG_REDRAW_BODY
  7514 00002BA3 0049                <1> 	dw	kbPgUp
  7515 00002BA5 [C825]              <1> 	dw	menubox_focus_pageup
  7516                              <1> 
  7517 00002BA7 02                  <1> 	db	ACTFLAG_REDRAW_BODY
  7518 00002BA8 0051                <1> 	dw	kbPgDn
  7519 00002BAA [F425]              <1> 	dw	menubox_focus_pagedown
  7520                              <1> 
  7521 00002BAC 02                  <1> 	db	ACTFLAG_REDRAW_BODY
  7522 00002BAD 0D1C                <1> 	dw	kbEnter
  7523 00002BAF [8A25]              <1> 	dw	menubox_do_focus
  7524                              <1> 
  7525 00002BB1 02                  <1> 	db	ACTFLAG_REDRAW_BODY
  7526 00002BB2 0DE0                <1> 	dw	kbEnhEnter
  7527 00002BB4 [8A25]              <1> 	dw	menubox_do_focus
  7528                              <1> 
  7529 00002BB6 01                  <1> 	db	ACTFLAG_CLOSE_WIN
  7530 00002BB7 1B01                <1> 	dw	kbEsc
  7531 00002BB9 0000                <1> 	dw	0
  7532                              <1> 
  7533 00002BBB 01                  <1>         db      ACTFLAG_CLOSE_WIN
  7534 00002BBC 08F2                <1>         dw      EVENT_ALT_RELEASE
  7535 00002BBE 0000                <1>         dw      0
  7536                              <1> .end_of_table
  7537                              <1> 
  7538                              <1> 
  7539                              <1> 
  7540                              <1> ; ===========================================================================
  7541                              <1> %ifndef MAIN
  7542                              <1> 
  7543                              <1> ; how to draw window frame
  7544                              <1> keyboard_type       db  0x10       ; keyboard type, 0x10 = enhanced keyboard
  7545                              <1> draw_frame_method   db  0          ; = 0 means draw all frame using frame attr.
  7546                              <1>                                    ; = 1 means draw top horizontal line using
  7547                              <1>                                    ;     title attr.
  7548                              <1>                                    ; = 2 means draw top corner and horizontal
  7549                              <1>                                    ;     line using title attr.
  7550                              <1> color:
  7551                              <1> .win_title_inactive db  0x70        ; title attribute for inactive window.
  7552                              <1> 
  7553                              <1> .list_box:
  7554                              <1> .list_box_frame      db  0x30
  7555                              <1> .list_box_title      db  0xBF
  7556                              <1> .list_box_header     db  0x30
  7557                              <1> .list_box_normal     dw  0x3C30
  7558                              <1> .list_box_focus      dw  0x0C0F
  7559                              <1> .list_box_scrollbar  db  0x3F
  7560                              <1> 
  7561                              <1> .input_box:
  7562                              <1> .input_box_frame        db  0xB0        ;
  7563                              <1> .input_box_title        db  0xF1        ; input box
  7564                              <1> .input_box_msg          db  0xB0        ;
  7565                              <1> 
  7566                              <1> .error_box:
  7567                              <1> .error_box_frame        db  0xCF        ;
  7568                              <1> .error_box_title        db  0xF1        ; error box
  7569                              <1> .error_box_msg          db  0xCF        ;
  7570                              <1> 
  7571                              <1> .info_box:
  7572                              <1> .info_box_frame         db  0xB0        ;
  7573                              <1> .info_box_title         db  0xF1        ; info box
  7574                              <1> .info_box_msg           db  0xB0        ;
  7575                              <1> 
  7576                              <1> 
  7577                              <1> 
  7578                              <1> frame_char:
  7579                              <1> .top             db     0x020
  7580                              <1> .bottom          db     0x0CD
  7581                              <1> .left            db     0x0BA
  7582                              <1> .right           db     0x0BA
  7583                              <1> .tl_corner       db     0x0C9               ; top left corner
  7584                              <1> .tr_corner       db     0x0BB               ; top right corner
  7585                              <1> .bl_corner       db     0x0C8               ; bottom left corner
  7586                              <1> .br_corner       db     0x0BC               ; bottom right corner
  7587                              <1> 
  7588                              <1> size:
  7589                              <1> .box_width       db  5
  7590                              <1> .box_height      db  4
  7591                              <1> 
  7592                              <1> str_idx:
  7593                              <1> .input          dw  string.input
  7594                              <1> 
  7595                              <1> string:
  7596                              <1> .input          db     'Input',0
  7597                              <1> 
  7598                              <1> 	section .bss
  7599                              <1> %include "tempdata.asm"
  7600                              <1> 
  7601                              <1> %endif
  7602                              <1> 
  7603                              <1> %endif	;End of HAVE_UI
  7604                              <1> 
  7605                              <1> ; vi:nowrap
  7606                                  %include "utils.asm"
  7607                              <1> ; asmsyntax=nasm
  7608                              <1> ;
  7609                              <1> ; utils.asm
  7610                              <1> ;
  7611                              <1> ; Some utility functions
  7612                              <1> ;
  7613                              <1> ; Copyright (C) 2000, Suzhe. See file COPYING for details.
  7614                              <1> ;
  7615                              <1> 
  7616                              <1> %ifndef HAVE_UTILS
  7617                              <1> %define HAVE_UTILS
  7618                              <1> 
  7619                              <1> %ifndef MAIN
  7620                              <1> %include "evtcode.h"
  7621                              <1> %endif
  7622                              <1> 
  7623                              <1> ;=============================================================================
  7624                              <1> ;itoa ---- convert integer to ascii string (the string is zero ending)
  7625                              <1> ;input:
  7626                              <1> ;      ax = the integer to be converted
  7627                              <1> ;      cl = max length of the integer
  7628                              <1> ;      es:di -> buffer
  7629                              <1> ;output:
  7630                              <1> ;      none
  7631                              <1> ;=============================================================================
  7632                              <1> itoa:
  7633 00002BC0 60                  <1>         pusha
  7634 00002BC1 30ED                <1>         xor ch, ch
  7635 00002BC3 01CF                <1>         add di, cx
  7636 00002BC5 C60500              <1>         mov byte [di], 0
  7637 00002BC8 BB0A00              <1>         mov bx, 10
  7638                              <1> .loop_itoa:
  7639 00002BCB 31D2                <1>         xor dx, dx
  7640 00002BCD 4F                  <1>         dec di
  7641 00002BCE F7F3                <1>         div bx
  7642 00002BD0 80C230              <1>         add dl, '0'
  7643 00002BD3 8815                <1>         mov [di], dl
  7644 00002BD5 49                  <1>         dec cx
  7645 00002BD6 09C0                <1>         or ax, ax
  7646 00002BD8 7404                <1>         jz .end_itoa
  7647 00002BDA 09C9                <1>         or cx, cx
  7648 00002BDC 75ED                <1>         jnz .loop_itoa
  7649                              <1> .end_itoa:
  7650 00002BDE 09C9                <1>         or cx, cx
  7651 00002BE0 7406                <1>         jz .end
  7652                              <1> .loop_fillspace:
  7653 00002BE2 4F                  <1>         dec di
  7654 00002BE3 C60520              <1>         mov byte [di], ' '
  7655 00002BE6 E2FA                <1>         loop .loop_fillspace
  7656                              <1> .end:
  7657 00002BE8 61                  <1>         popa
  7658 00002BE9 C3                  <1>         ret
  7659                              <1> 
  7660                              <1> ;=============================================================================
  7661                              <1> ;atoi ---- convert ascii string to integer (the string is zero ending)
  7662                              <1> ;input:
  7663                              <1> ;      ds:si -> buffer
  7664                              <1> ;output:
  7665                              <1> ;      ax = convert result ( <= 65535 )
  7666                              <1> ;=============================================================================
  7667                              <1> atoi:
  7668 00002BEA 53                  <1> 	push bx
  7669 00002BEB 51                  <1> 	push cx
  7670                              <1> 
  7671 00002BEC 31DB                <1> 	xor bx, bx
  7672 00002BEE 31C0                <1> 	xor ax, ax
  7673                              <1> 
  7674                              <1> .loop_conv:
  7675 00002BF0 AC                  <1> 	lodsb
  7676 00002BF1 08C0                <1> 	or al, al
  7677 00002BF3 7413                <1> 	jz .end
  7678 00002BF5 2C30                <1> 	sub al, '0'
  7679 00002BF7 3C0A                <1> 	cmp al, 10
  7680 00002BF9 730D                <1> 	jae .end
  7681                              <1> 
  7682 00002BFB 89D9                <1> 	mov cx, bx
  7683 00002BFD C1E303              <1>         shl bx, 3                   ; bx = bx * 10
  7684 00002C00 D1E1                <1>         shl cx, 1                   ;
  7685 00002C02 01CB                <1>         add bx, cx                  ;
  7686 00002C04 01C3                <1> 	add bx, ax
  7687 00002C06 EBE8                <1> 	jmp short .loop_conv
  7688                              <1> 
  7689                              <1> .end:
  7690 00002C08 89D8                <1> 	mov ax, bx
  7691 00002C0A 4E                  <1> 	dec si
  7692 00002C0B 59                  <1> 	pop cx
  7693 00002C0C 5B                  <1> 	pop bx
  7694 00002C0D C3                  <1> 	ret
  7695                              <1> 
  7696                              <1> ;=============================================================================
  7697                              <1> ;strlen ---- Count Length of a zero ending string
  7698                              <1> ;input:
  7699                              <1> ;      ds:si -> string
  7700                              <1> ;output:
  7701                              <1> ;      cx = length (not include the ending zero)
  7702                              <1> ;=============================================================================
  7703                              <1> strlen:
  7704 00002C0E 50                  <1>         push ax
  7705 00002C0F 31C9                <1>         xor cx,cx
  7706                              <1> 
  7707 00002C11 09F6                <1>         or si,si
  7708 00002C13 740A                <1>         jz .end
  7709                              <1> 
  7710 00002C15 56                  <1>         push si
  7711 00002C16 FC                  <1>         cld
  7712                              <1> .loop_count:
  7713 00002C17 41                  <1>         inc cx
  7714 00002C18 AC                  <1>         lodsb
  7715 00002C19 08C0                <1>         or al, al
  7716 00002C1B 75FA                <1>         jnz .loop_count
  7717                              <1> 
  7718 00002C1D 49                  <1>         dec cx
  7719 00002C1E 5E                  <1>         pop si
  7720                              <1> 
  7721                              <1> .end:
  7722 00002C1F 58                  <1>         pop ax
  7723 00002C20 C3                  <1>         ret
  7724                              <1> 
  7725                              <1> ;=============================================================================
  7726                              <1> ;strlen_hl ---- Count Length of a zero ending string (ignore ~ chars)
  7727                              <1> ;input:
  7728                              <1> ;      ds:si -> string
  7729                              <1> ;output:
  7730                              <1> ;      cx = length (not include the ending zero)
  7731                              <1> ;=============================================================================
  7732                              <1> strlen_hl:
  7733 00002C21 50                  <1>         push ax
  7734 00002C22 31C9                <1>         xor cx,cx
  7735                              <1> 
  7736 00002C24 09F6                <1>         or si,si
  7737 00002C26 740E                <1>         jz .end
  7738                              <1> 
  7739 00002C28 56                  <1>         push si
  7740 00002C29 FC                  <1>         cld
  7741                              <1> .loop_count:
  7742 00002C2A 41                  <1>         inc cx
  7743                              <1> 
  7744                              <1> .loop_nocount:
  7745 00002C2B AC                  <1>         lodsb
  7746 00002C2C 3C7E                <1>         cmp al, '~'
  7747 00002C2E 74FB                <1>         je .loop_nocount
  7748 00002C30 08C0                <1>         or al, al
  7749 00002C32 75F6                <1>         jnz .loop_count
  7750                              <1> 
  7751 00002C34 49                  <1>         dec cx
  7752 00002C35 5E                  <1>         pop si
  7753                              <1> 
  7754                              <1> .end:
  7755 00002C36 58                  <1>         pop ax
  7756 00002C37 C3                  <1>         ret
  7757                              <1> 
  7758                              <1> ;=============================================================================
  7759                              <1> ;strchr ---- search a char in a string
  7760                              <1> ;input:
  7761                              <1> ;      al = the char to be searched
  7762                              <1> ;      cx = length of the string
  7763                              <1> ;      es:di -> string
  7764                              <1> ;output:
  7765                              <1> ;      cf = 0 the char was found
  7766                              <1> ;            cx = offset of the char
  7767                              <1> ;      cf = 1 the char was not found
  7768                              <1> ;            cx = length of the string
  7769                              <1> ;=============================================================================
  7770                              <1> strchr:
  7771 00002C38 53                  <1>         push bx
  7772 00002C39 57                  <1>         push di
  7773 00002C3A 89CB                <1>         mov bx,cx
  7774 00002C3C FC                  <1>         cld
  7775 00002C3D F2AE                <1>         repnz scasb
  7776 00002C3F 5F                  <1>         pop di
  7777 00002C40 87D9                <1>         xchg bx, cx
  7778 00002C42 7506                <1>         jnz .not_found
  7779 00002C44 29D9                <1>         sub cx, bx
  7780 00002C46 49                  <1>         dec cx
  7781 00002C47 5B                  <1>         pop bx
  7782 00002C48 F8                  <1>         clc
  7783 00002C49 C3                  <1>         ret
  7784                              <1> .not_found:
  7785 00002C4A 5B                  <1>         pop bx
  7786 00002C4B F9                  <1>         stc
  7787 00002C4C C3                  <1>         ret
  7788                              <1> 
  7789                              <1> ;=============================================================================
  7790                              <1> ;strncpy ---- copy strings
  7791                              <1> ;input:
  7792                              <1> ;      cx = max number of chars to be copied
  7793                              <1> ;      ds:si -> source string
  7794                              <1> ;      es:di -> dest string
  7795                              <1> ;output:
  7796                              <1> ;      cx = number of chars actually copied (not include the ending zero char)
  7797                              <1> ;      es:di -> point to next char of the end of dest string and set it to
  7798                              <1> ;               zero
  7799                              <1> ;=============================================================================
  7800                              <1> strncpy:
  7801 00002C4D 56                  <1>         push si
  7802 00002C4E 50                  <1>         push ax
  7803 00002C4F 53                  <1>         push bx
  7804 00002C50 89CB                <1>         mov bx, cx
  7805 00002C52 FC                  <1>         cld
  7806                              <1> .loop_copy:
  7807 00002C53 AC                  <1>         lodsb
  7808 00002C54 AA                  <1>         stosb
  7809 00002C55 08C0                <1>         or al, al
  7810 00002C57 7405                <1>         jz .end
  7811 00002C59 E2F8                <1>         loop .loop_copy
  7812 00002C5B 30C0                <1>         xor al, al
  7813 00002C5D AA                  <1>         stosb
  7814                              <1> .end:
  7815 00002C5E 4F                  <1>         dec di
  7816 00002C5F 87D9                <1>         xchg bx, cx
  7817 00002C61 29D9                <1>         sub cx, bx
  7818 00002C63 5B                  <1>         pop bx
  7819 00002C64 58                  <1>         pop ax
  7820 00002C65 5E                  <1>         pop si
  7821 00002C66 C3                  <1>         ret
  7822                              <1> 
  7823                              <1> ;=============================================================================
  7824                              <1> ;strcpy ---- copy strings
  7825                              <1> ;input:
  7826                              <1> ;      ds:si -> source string
  7827                              <1> ;      es:di -> dest string
  7828                              <1> ;output:
  7829                              <1> ;      es:di -> point to next char of the end of dest string and set it to
  7830                              <1> ;               zero
  7831                              <1> ;=============================================================================
  7832                              <1> strcpy:
  7833 00002C67 56                  <1>         push si
  7834 00002C68 50                  <1>         push ax
  7835                              <1> 
  7836 00002C69 FC                  <1>         cld
  7837                              <1> .loop_copy:
  7838 00002C6A AC                  <1>         lodsb
  7839 00002C6B AA                  <1>         stosb
  7840 00002C6C 08C0                <1>         or al, al
  7841 00002C6E 75FA                <1> 	jnz .loop_copy
  7842                              <1> 
  7843 00002C70 4F                  <1>         dec di
  7844 00002C71 58                  <1>         pop ax
  7845 00002C72 5E                  <1>         pop si
  7846 00002C73 C3                  <1>         ret
  7847                              <1> 
  7848                              <1> 
  7849                              <1> ;=============================================================================
  7850                              <1> ;calc_password ---- calculate the password
  7851                              <1> ;input:
  7852                              <1> ;      ds:si -> the pasword string (zero ending)
  7853                              <1> ;      cx = max length of the password
  7854                              <1> ;output:
  7855                              <1> ;      dx:ax = the encrypted password (32 bits)
  7856                              <1> ;=============================================================================
  7857                              <1> calc_password:
  7858 00002C74 56                  <1>         push si
  7859 00002C75 6631D2              <1>         xor edx, edx
  7860 00002C78 6631C0              <1>         xor eax, eax
  7861 00002C7B FC                  <1>         cld
  7862                              <1> .loop_calc:
  7863 00002C7C AC                  <1>         lodsb
  7864 00002C7D 08C0                <1>         or al, al
  7865 00002C7F 740E                <1>         jz .end
  7866 00002C81 F6D0                <1>         not al
  7867 00002C83 C0C004              <1>         rol al, 4
  7868 00002C86 6601C2              <1>         add edx, eax
  7869 00002C89 66C1C202            <1>         rol edx, 2
  7870 00002C8D E2ED                <1>         loop .loop_calc
  7871                              <1> .end:
  7872 00002C8F 89D0                <1>         mov ax, dx
  7873 00002C91 66C1CA10            <1>         ror edx, 16
  7874 00002C95 5E                  <1>         pop si
  7875 00002C96 C3                  <1>         ret
  7876                              <1> 
  7877                              <1> ;=============================================================================
  7878                              <1> ;htoa ---- hex to ascii
  7879                              <1> ;input:
  7880                              <1> ;     ax = hex number
  7881                              <1> ;     cl = length of hex number (1 to 4)
  7882                              <1> ;     es:di -> buffer to store ascii string
  7883                              <1> ;output:
  7884                              <1> ;     es:di -> ascii string
  7885                              <1> ;=============================================================================
  7886                              <1> htoa:
  7887 00002C97 60                  <1>         pusha
  7888 00002C98 30ED                <1>         xor ch, ch
  7889 00002C9A 01CF                <1>         add di, cx
  7890 00002C9C C60500              <1>         mov byte [di], 0
  7891                              <1> 
  7892                              <1> .loop_conv:
  7893 00002C9F 50                  <1> 	push ax                 ;Save AX
  7894 00002CA0 240F                <1> 	and al,0Fh              ;Keep 4 bits
  7895 00002CA2 3C0A                <1> 	cmp al,0Ah              ;Compute the hex digit,
  7896 00002CA4 1C69                <1> 	sbb al,69h              ;using Improved Allison's Algorithm
  7897 00002CA6 2F                  <1> 	das
  7898 00002CA7 4F                  <1> 	dec di
  7899 00002CA8 8805                <1> 	mov [di], al
  7900 00002CAA 58                  <1> 	pop ax                  ;Restore AX
  7901 00002CAB C1E804              <1> 	shr ax,4                ;Shift it over
  7902 00002CAE E2EF                <1>         loop .loop_conv
  7903                              <1> 
  7904 00002CB0 61                  <1>         popa
  7905 00002CB1 C3                  <1>         ret
  7906                              <1> 
  7907                              <1> ;=============================================================================
  7908                              <1> ;atoh ---- ascii to hex
  7909                              <1> ;input:
  7910                              <1> ;     ds:si -> buffer
  7911                              <1> ;output:
  7912                              <1> ;     ax = hex
  7913                              <1> ;     ds:si -> end of the hex number
  7914                              <1> ;=============================================================================
  7915                              <1> atoh:
  7916 00002CB2 53                  <1> 	push bx
  7917                              <1> 
  7918 00002CB3 31DB                <1> 	xor bx, bx
  7919 00002CB5 31C0                <1> 	xor ax, ax
  7920                              <1> .loop_conv:
  7921 00002CB7 AC                  <1> 	lodsb
  7922 00002CB8 08C0                <1> 	or al, al
  7923 00002CBA 741A                <1> 	jz .end
  7924                              <1> 
  7925 00002CBC 2C30                <1> 	sub al, '0'
  7926 00002CBE 3C0A                <1> 	cmp al, 10
  7927 00002CC0 720C                <1> 	jb .ok
  7928 00002CC2 2C07                <1> 	sub al, 'A'-'0'-10
  7929 00002CC4 3C10                <1> 	cmp al, 16
  7930 00002CC6 7206                <1> 	jb .ok
  7931 00002CC8 2C20                <1> 	sub al, 'a'-'A'
  7932 00002CCA 3C10                <1> 	cmp al, 16
  7933 00002CCC 7308                <1> 	jae .end
  7934                              <1> 
  7935                              <1> .ok:
  7936 00002CCE C1E304              <1> 	shl bx, 4
  7937 00002CD1 01C3                <1> 	add bx, ax
  7938 00002CD3 E9E1FF              <1> 	jmp .loop_conv
  7939                              <1> 
  7940                              <1> .end:
  7941 00002CD6 4E                  <1> 	dec si
  7942 00002CD7 89D8                <1> 	mov ax, bx
  7943 00002CD9 5B                  <1>         pop bx
  7944 00002CDA C3                  <1>         ret
  7945                              <1> 
  7946                              <1> ;=============================================================================
  7947                              <1> ;count_lines ---- count how many lines in a string.
  7948                              <1> ;input:
  7949                              <1> ;      ds:si -> string
  7950                              <1> ;output:
  7951                              <1> ;      ch = number of lines
  7952                              <1> ;      cl = max line length
  7953                              <1> ;=============================================================================
  7954                              <1> count_lines:
  7955 00002CDB 56                  <1>         push si
  7956 00002CDC 53                  <1>         push bx
  7957 00002CDD 50                  <1>         push ax
  7958                              <1> 
  7959 00002CDE FC                  <1>         cld
  7960                              <1> 
  7961 00002CDF 31C9                <1>         xor cx, cx
  7962 00002CE1 31DB                <1>         xor bx, bx
  7963                              <1> 
  7964 00002CE3 09F6                <1>         or si, si
  7965 00002CE5 7423                <1>         jz .end
  7966                              <1> 
  7967 00002CE7 FEC5                <1>         inc ch
  7968                              <1> .loop_count:
  7969 00002CE9 AC                  <1>         lodsb
  7970 00002CEA 08C0                <1>         or al, al
  7971 00002CEC 7416                <1>         jz .ending
  7972                              <1> 
  7973 00002CEE 3C0D                <1>         cmp al, 0x0d
  7974 00002CF0 7404                <1>         je .new_line
  7975                              <1> 
  7976 00002CF2 FEC3                <1>         inc bl
  7977 00002CF4 EBF3                <1>         jmp short .loop_count
  7978                              <1> 
  7979                              <1> .new_line:
  7980 00002CF6 FEC5                <1>         inc ch
  7981                              <1> 
  7982 00002CF8 88DF                <1>         mov bh, bl
  7983 00002CFA 30DB                <1>         xor bl, bl
  7984 00002CFC 38CF                <1>         cmp bh, cl
  7985 00002CFE 76E9                <1>         jbe .loop_count
  7986 00002D00 88F9                <1>         mov cl, bh
  7987 00002D02 EBE5                <1>         jmp short .loop_count
  7988                              <1> 
  7989                              <1> .ending:
  7990 00002D04 38CB                <1>         cmp bl, cl
  7991 00002D06 7602                <1>         jbe .end
  7992 00002D08 88D9                <1>         mov cl, bl
  7993                              <1> 
  7994                              <1> .end:
  7995 00002D0A 58                  <1>         pop ax
  7996 00002D0B 5B                  <1>         pop bx
  7997 00002D0C 5E                  <1>         pop si
  7998 00002D0D C3                  <1>         ret
  7999                              <1> 
  8000                              <1> ;=============================================================================
  8001                              <1> ; power_off ---- turn the power off
  8002                              <1> ;input:
  8003                              <1> ;       none
  8004                              <1> ;output:
  8005                              <1> ;       never return if successful.
  8006                              <1> ;       cf = 1 on error.
  8007                              <1> ;=============================================================================
  8008                              <1> power_off:
  8009 00002D0E 60                  <1>         pusha
  8010 00002D0F E82D00              <1> 	call check_apm_bios
  8011 00002D12 7229                <1>         jc .end
  8012                              <1> 
  8013 00002D14 B80153              <1>         mov ax, 0x5301
  8014 00002D17 31DB                <1>         xor bx, bx
  8015 00002D19 CD15                <1>         int 0x15
  8016 00002D1B 7220                <1>         jc .end
  8017                              <1> 
  8018 00002D1D B88053              <1>         mov ax, 0x5380
  8019 00002D20 B78C                <1>         mov bh, 0x8c
  8020 00002D22 CD15                <1>         int 0x15
  8021                              <1> 
  8022 00002D24 B84000              <1>         mov ax, 0x40
  8023 00002D27 BBD800              <1>         mov bx, 0xd8
  8024 00002D2A 1E                  <1>         push ds
  8025 00002D2B 8ED8                <1>         mov ds, ax
  8026 00002D2D 3E800F10            <1>         or byte [ds:bx], 0x10
  8027 00002D31 1F                  <1>         pop ds
  8028                              <1> 
  8029 00002D32 B80753              <1>         mov ax, 0x5307
  8030 00002D35 BB0100              <1>         mov bx, 1
  8031 00002D38 B90300              <1>         mov cx, 3
  8032 00002D3B CD15                <1>         int 0x15
  8033                              <1> 
  8034                              <1> .end:
  8035 00002D3D 61                  <1>         popa
  8036 00002D3E C3                  <1>         ret
  8037                              <1> 
  8038                              <1> 
  8039                              <1> ;=============================================================================
  8040                              <1> ; check_apm_bios ---- check if the apm bios present
  8041                              <1> ; output:
  8042                              <1> ;	cf = 1 error, cf = 0 ok
  8043                              <1> ;=============================================================================
  8044                              <1> check_apm_bios:
  8045 00002D3F 60                  <1>         pusha
  8046 00002D40 B80053              <1>         mov ax, 0x5300
  8047 00002D43 31DB                <1>         xor bx, bx
  8048 00002D45 CD15                <1>         int 0x15                                 ; check if apm present
  8049 00002D47 720D                <1> 	jc .end
  8050 00002D49 81FB4D50            <1> 	cmp bx, 0x504D
  8051 00002D4D 7506                <1> 	jnz .none
  8052 00002D4F F7C10100            <1> 	test cx, 1
  8053 00002D53 7501                <1> 	jnz .end
  8054                              <1> .none:
  8055 00002D55 F9                  <1> 	stc
  8056                              <1> .end:
  8057 00002D56 61                  <1> 	popa
  8058 00002D57 C3                  <1> 	ret
  8059                              <1> 
  8060                              <1> ;=============================================================================
  8061                              <1> ; leap_year ---- check if a year is leap a year
  8062                              <1> ; input:
  8063                              <1> ;      ax = year
  8064                              <1> ; output:
  8065                              <1> ;      cf = 1, it's a leap year
  8066                              <1> ;      cf = 0, not a leap year
  8067                              <1> ;=============================================================================
  8068                              <1> leap_year:
  8069 00002D58 60                  <1>        pusha
  8070 00002D59 B99001              <1>        mov cx, 400
  8071 00002D5C 31D2                <1>        xor dx, dx 
  8072 00002D5E 50                  <1>        push ax
  8073 00002D5F F7F1                <1>        div cx
  8074 00002D61 58                  <1>        pop ax
  8075 00002D62 09D2                <1>        or dx, dx
  8076 00002D64 741B                <1>        jz .isleap
  8077                              <1> 
  8078 00002D66 B96400              <1>        mov cx, 100
  8079 00002D69 31D2                <1>        xor dx, dx
  8080 00002D6B 50                  <1>        push ax
  8081 00002D6C F7F1                <1>        div cx
  8082 00002D6E 58                  <1>        pop ax
  8083 00002D6F 09D2                <1>        or dx, dx
  8084 00002D71 740B                <1>        jz .noleap
  8085                              <1> 
  8086 00002D73 31D2                <1>        xor dx, dx
  8087 00002D75 B90400              <1>        mov cx, 4
  8088 00002D78 F7F1                <1>        div cx
  8089 00002D7A 09D2                <1>        or dx, dx
  8090 00002D7C 7403                <1>        jz .isleap
  8091                              <1> 
  8092                              <1> .noleap:
  8093 00002D7E F8                  <1>        clc
  8094 00002D7F 61                  <1>        popa
  8095 00002D80 C3                  <1>        ret
  8096                              <1> 
  8097                              <1> .isleap:
  8098 00002D81 F9                  <1>        stc
  8099 00002D82 61                  <1>        popa
  8100 00002D83 C3                  <1>        ret
  8101                              <1> 
  8102                              <1> ;=============================================================================
  8103                              <1> ; day_in_week
  8104                              <1> ; input:
  8105                              <1> ;      ax = year
  8106                              <1> ;      dh = month
  8107                              <1> ;      dl = day
  8108                              <1> ; output:
  8109                              <1> ;      cx = day in week
  8110                              <1> ;=============================================================================
  8111                              <1> day_in_week:
  8112 00002D84 50                  <1> 	push ax
  8113 00002D85 53                  <1> 	push bx
  8114 00002D86 52                  <1> 	push dx
  8115                              <1> 
  8116 00002D87 52                  <1> 	push dx
  8117                              <1> 
  8118 00002D88 48                  <1> 	dec ax
  8119 00002D89 89C1                <1> 	mov cx, ax
  8120 00002D8B 31D2                <1> 	xor dx, dx
  8121 00002D8D 50                  <1> 	push ax
  8122 00002D8E BB0400              <1> 	mov bx, 4
  8123 00002D91 F7F3                <1> 	div bx
  8124 00002D93 01C1                <1> 	add cx, ax
  8125 00002D95 58                  <1> 	pop ax
  8126                              <1> 
  8127 00002D96 31D2                <1> 	xor dx, dx
  8128 00002D98 50                  <1> 	push ax
  8129 00002D99 BB6400              <1> 	mov bx, 100
  8130 00002D9C F7F3                <1> 	div bx
  8131 00002D9E 29C1                <1> 	sub cx, ax
  8132 00002DA0 58                  <1> 	pop ax
  8133                              <1> 
  8134 00002DA1 31D2                <1> 	xor dx, dx
  8135 00002DA3 50                  <1> 	push ax
  8136 00002DA4 BB9001              <1> 	mov bx, 400
  8137 00002DA7 F7F3                <1> 	div bx
  8138 00002DA9 01C1                <1> 	add cx, ax
  8139 00002DAB 58                  <1> 	pop ax
  8140                              <1> 
  8141 00002DAC 40                  <1> 	inc ax
  8142 00002DAD 5A                  <1> 	pop dx
  8143                              <1> 
  8144 00002DAE 0FB6DE              <1> 	movzx bx, dh
  8145 00002DB1 8A9F[D42D]          <1> 	mov bl, [days_in_month_norm-1+bx]
  8146 00002DB5 01D9                <1> 	add cx, bx 
  8147                              <1> 
  8148 00002DB7 E89EFF              <1> 	call leap_year
  8149 00002DBA 7306                <1> 	jnc .norm
  8150 00002DBC 80FE03              <1> 	cmp dh, 3
  8151                              <1> 
  8152 00002DBF 7201                <1> 	jb .norm
  8153 00002DC1 41                  <1> 	inc cx
  8154                              <1> 
  8155                              <1> .norm:
  8156 00002DC2 30F6                <1> 	xor dh, dh
  8157 00002DC4 01D1                <1> 	add cx, dx
  8158                              <1> 
  8159 00002DC6 89C8                <1> 	mov ax, cx
  8160 00002DC8 31D2                <1> 	xor dx, dx
  8161 00002DCA B90700              <1> 	mov cx, 7
  8162 00002DCD F7F1                <1> 	div cx
  8163 00002DCF 89D1                <1> 	mov cx, dx
  8164                              <1> 
  8165 00002DD1 5A                  <1> 	pop dx
  8166 00002DD2 5B                  <1> 	pop bx
  8167 00002DD3 58                  <1> 	pop ax
  8168 00002DD4 C3                  <1> 	ret
  8169                              <1> 
  8170 00002DD5 000303060104060205- <1> days_in_month_norm db  0, 3, 3, 6, 1, 4, 6, 2, 5, 0, 3, 5
  8171 00002DDE 000305              <1>
  8172                              <1> 
  8173                              <1> ;=============================================================================
  8174                              <1> ; bcd_to_bin ---- convert bcd to binary
  8175                              <1> ; input: ax = bcd number
  8176                              <1> ; output: ax = binary number
  8177                              <1> ;=============================================================================
  8178                              <1> bcd_to_bin:
  8179 00002DE1 53                  <1>        push bx
  8180 00002DE2 51                  <1>        push cx
  8181 00002DE3 52                  <1>        push dx
  8182 00002DE4 56                  <1>        push si
  8183                              <1> 
  8184 00002DE5 8D36[072E]          <1>        lea si, [.mul_num]
  8185 00002DE9 B90400              <1>        mov cx, 4
  8186 00002DEC 31DB                <1>        xor bx, bx
  8187                              <1> 
  8188                              <1> .loop_conv:
  8189 00002DEE 50                  <1>        push ax
  8190 00002DEF 250F00              <1>        and ax, 0x000f
  8191 00002DF2 8B14                <1>        mov dx, [si]
  8192 00002DF4 F7E2                <1>        mul dx
  8193 00002DF6 01C3                <1>        add bx, ax
  8194 00002DF8 58                  <1>        pop ax
  8195 00002DF9 C1E804              <1>        shr ax, 4
  8196 00002DFC 46                  <1>        inc si
  8197 00002DFD 46                  <1>        inc si
  8198 00002DFE E2EE                <1>        loop .loop_conv
  8199                              <1> 
  8200 00002E00 89D8                <1>        mov ax, bx
  8201                              <1> 
  8202 00002E02 5E                  <1>        pop si
  8203 00002E03 5A                  <1>        pop dx
  8204 00002E04 59                  <1>        pop cx
  8205 00002E05 5B                  <1>        pop bx
  8206 00002E06 C3                  <1>        ret
  8207                              <1> 
  8208 00002E07 01000A006400E803    <1> .mul_num  dw 1, 10, 100, 1000
  8209                              <1> 
  8210                              <1> ;=============================================================================
  8211                              <1> ; bcd_to_str ---- convert bcd to string
  8212                              <1> ; input: ax = bcd number
  8213                              <1> ;        cl = length (0 to 4)
  8214                              <1> ;        es:di -> buffer
  8215                              <1> ; output: none
  8216                              <1> ;=============================================================================
  8217                              <1> bcd_to_str:
  8218 00002E0F 60                  <1>        pusha
  8219 00002E10 51                  <1>        push cx
  8220 00002E11 89C3                <1>        mov bx, ax
  8221 00002E13 B004                <1>        mov al, 4
  8222 00002E15 F6E1                <1>        mul cl
  8223 00002E17 88C1                <1>        mov cl, al
  8224 00002E19 D3CB                <1>        ror bx, cl
  8225 00002E1B 59                  <1>        pop cx
  8226                              <1> 
  8227                              <1> .loop_conv:
  8228 00002E1C 08C9                <1>        or cl, cl
  8229 00002E1E 740F                <1>        jz .end
  8230 00002E20 C1C304              <1>        rol bx, 4
  8231 00002E23 89D8                <1>        mov ax, bx
  8232 00002E25 240F                <1>        and al, 0x0f
  8233 00002E27 0430                <1>        add al, '0'
  8234 00002E29 AA                  <1>        stosb
  8235 00002E2A FEC9                <1>        dec cl
  8236 00002E2C E9EDFF              <1>        jmp .loop_conv
  8237                              <1> 
  8238                              <1> .end:
  8239 00002E2F 30C0                <1>        xor al, al
  8240 00002E31 AA                  <1>        stosb
  8241 00002E32 61                  <1>        popa
  8242 00002E33 C3                  <1>        ret
  8243                              <1> 
  8244                              <1> ;=============================================================================
  8245                              <1> ; reboot ---- reboot the computer
  8246                              <1> ; input:
  8247                              <1> ;	none
  8248                              <1> ;=============================================================================
  8249                              <1> reboot:
  8250 00002E34 BB4000              <1>        mov bx, 0x40
  8251 00002E37 53                  <1>        push bx
  8252 00002E38 1F                  <1>        pop ds
  8253 00002E39 B83412              <1>        mov ax, 0x1234
  8254 00002E3C A37200              <1>        mov [0x0072], ax
  8255 00002E3F EA0000FFFF          <1>        jmp 0xFFFF:0x0000
  8256                              <1> 
  8257                              <1> ;=============================================================================
  8258                              <1> ; bioskey ---- BIOS keyboard func
  8259                              <1> ;=============================================================================
  8260                              <1> bioskey:
  8261 00002E44 C606[0C2D]00        <1>        mov byte [utils_tmp.kbd_work], 0
  8262 00002E49 08E4                <1>        or ah, ah
  8263 00002E4B 740F                <1>        je .post_trans
  8264 00002E4D 80FC01              <1>        cmp ah, 0x01
  8265 00002E50 740A                <1>        je .post_trans
  8266 00002E52 80FC10              <1>        cmp ah, 0x10
  8267 00002E55 7405                <1>        je .post_trans
  8268 00002E57 80FC11              <1>        cmp ah, 0x11
  8269 00002E5A 7504                <1>        jne .call_int16
  8270                              <1> 
  8271                              <1> .post_trans:
  8272 00002E5C FE06[0C2D]          <1>        inc byte [utils_tmp.kbd_work]
  8273                              <1> 
  8274                              <1> .call_int16:
  8275 00002E60 CD16                <1>        int 0x16
  8276 00002E62 9C                  <1>        pushf
  8277                              <1> 
  8278 00002E63 803E[0C2D]00        <1>        cmp byte [utils_tmp.kbd_work], 0
  8279 00002E68 741F                <1>        jz .end
  8280                              <1> 
  8281 00002E6A 51                  <1>        push cx
  8282 00002E6B 56                  <1>        push si
  8283 00002E6C 8B0E[FB4B]          <1>        mov cx, [keymap.number]
  8284 00002E70 8B36[FD4B]          <1>        mov si, [keymap.data]
  8285 00002E74 09C9                <1>        or cx, cx
  8286 00002E76 740F                <1>        jz .end_trans
  8287                              <1> 
  8288                              <1> .loop_trans:
  8289 00002E78 3B04                <1>        cmp ax, [si]
  8290 00002E7A 7505                <1>        jne .loop_next
  8291 00002E7C 8B4402              <1>        mov ax, [si+2]
  8292 00002E7F EB06                <1>        jmp short .end_trans
  8293                              <1> .loop_next:
  8294 00002E81 81C60400            <1>        add si, 4
  8295 00002E85 E2F1                <1>        loop .loop_trans
  8296                              <1> .end_trans:
  8297 00002E87 5E                  <1>        pop si
  8298 00002E88 59                  <1>        pop cx
  8299                              <1> .end:
  8300 00002E89 9D                  <1>        popf       
  8301 00002E8A C3                  <1>        ret
  8302                              <1> 
  8303                              <1> ;=============================================================================
  8304                              <1> ; check_keyevent ---- check if keyboard is pressed
  8305                              <1> ; input:
  8306                              <1> ;	none
  8307                              <1> ; output:
  8308                              <1> ;	ax = keyevent (0 = no key)
  8309                              <1> ;=============================================================================
  8310                              <1> check_keyevent:
  8311 00002E8B 53                  <1> 	push bx
  8312                              <1> 
  8313 00002E8C 8A3E[0D2D]          <1> 	mov bh, [utils_tmp.kbd_last_shift]
  8314 00002E90 E85200              <1> 	call .check_stat_key
  8315 00002E93 88C3                <1> 	mov bl, al
  8316 00002E95 A2[0D2D]            <1> 	mov [utils_tmp.kbd_last_shift], al
  8317                              <1> 
  8318 00002E98 E85600              <1> 	call .check_norm_key
  8319 00002E9B 09C0                <1> 	or ax, ax
  8320 00002E9D 7407                <1> 	jz .no_norm_key
  8321                              <1> 
  8322 00002E9F C606[0E2D]01        <1> 	mov byte [utils_tmp.kbd_bypass_next_shift], 1
  8323                              <1> .end:
  8324 00002EA4 5B                  <1> 	pop bx
  8325 00002EA5 C3                  <1> 	ret
  8326                              <1> 
  8327                              <1> .no_norm_key:
  8328 00002EA6 31C0                <1> 	xor ax, ax
  8329 00002EA8 38FB                <1> 	cmp bl, bh
  8330 00002EAA 74F8                <1> 	je .end
  8331                              <1> 
  8332 00002EAC 51                  <1> 	push cx
  8333 00002EAD B90101              <1> 	mov cx, 0x0101
  8334                              <1> 
  8335                              <1> .loop_check_keys:
  8336 00002EB0 53                  <1> 	push bx
  8337 00002EB1 21CB                <1> 	and bx, cx
  8338 00002EB3 38DF                <1> 	cmp bh, bl
  8339 00002EB5 5B                  <1> 	pop bx
  8340                              <1> 
  8341 00002EB6 740E                <1> 	je .no_this_key
  8342                              <1> 
  8343 00002EB8 84CB                <1> 	test bl, cl
  8344 00002EBA 7404                <1> 	jz .release
  8345 00002EBC B4F1                <1> 	mov ah, (EVTCODE_COMMAND | EVTCODE_KEYPRESS)
  8346 00002EBE EB02                <1> 	jmp short .key_ok
  8347                              <1> 
  8348                              <1> .release:
  8349 00002EC0 B4F2                <1> 	mov ah, (EVTCODE_COMMAND | EVTCODE_KEYRELEASE)
  8350                              <1> 
  8351                              <1> .key_ok:
  8352 00002EC2 88C8                <1> 	mov al, cl
  8353 00002EC4 EB06                <1> 	jmp short .end_check_keys
  8354                              <1> 
  8355                              <1> .no_this_key:
  8356 00002EC6 D1E1                <1> 	shl cx, 1
  8357 00002EC8 08C9                <1> 	or cl, cl
  8358 00002ECA 75E4                <1> 	jnz .loop_check_keys
  8359                              <1> 
  8360                              <1> .end_check_keys:
  8361 00002ECC 09C0                <1> 	or ax, ax
  8362 00002ECE 7412                <1> 	jz .end_stat
  8363                              <1> 
  8364 00002ED0 A8F0                <1> 	test al, kbStateKeysMask
  8365 00002ED2 7509                <1> 	jnz .dont_bypass
  8366                              <1> 
  8367 00002ED4 803E[0E2D]00        <1> 	cmp byte [utils_tmp.kbd_bypass_next_shift], 0
  8368 00002ED9 7407                <1> 	jz .end_stat
  8369                              <1> 
  8370 00002EDB 31C0                <1> 	xor ax, ax
  8371                              <1> 
  8372                              <1> .dont_bypass:
  8373 00002EDD C606[0E2D]00        <1> 	mov byte [utils_tmp.kbd_bypass_next_shift], 0
  8374                              <1> 
  8375                              <1> .end_stat:
  8376 00002EE2 59                  <1> 	pop cx
  8377 00002EE3 5B                  <1> 	pop bx
  8378 00002EE4 C3                  <1> 	ret
  8379                              <1> 
  8380                              <1> .check_stat_key:
  8381 00002EE5 53                  <1> 	push bx
  8382 00002EE6 B402                <1> 	mov ah, 2
  8383 00002EE8 0A26[A34B]          <1> 	or ah, [keyboard_type]
  8384 00002EEC E855FF              <1> 	call bioskey
  8385 00002EEF 5B                  <1> 	pop bx
  8386 00002EF0 C3                  <1> 	ret
  8387                              <1> 
  8388                              <1> .check_norm_key:
  8389 00002EF1 53                  <1> 	push bx
  8390 00002EF2 B401                <1>         mov ah,1                                        ; if no key pressed
  8391 00002EF4 0A26[A34B]          <1>         or ah, [keyboard_type]
  8392 00002EF8 E849FF              <1>         call bioskey                                    ; go back to check
  8393 00002EFB 7409                <1> 	jz .no_key
  8394 00002EFD 8A26[A34B]          <1> 	mov ah, [keyboard_type]
  8395 00002F01 E840FF              <1> 	call bioskey
  8396 00002F04 5B                  <1> 	pop bx
  8397 00002F05 C3                  <1> 	ret
  8398                              <1> 
  8399                              <1> .no_key:
  8400 00002F06 31C0                <1> 	xor ax, ax
  8401 00002F08 5B                  <1> 	pop bx
  8402 00002F09 C3                  <1> 	ret
  8403                              <1> 
  8404                              <1> ;=============================================================================
  8405                              <1> ;get_realtime ---- get the machine real time in minutes
  8406                              <1> ;input:
  8407                              <1> ;      none
  8408                              <1> ;output:
  8409                              <1> ;      cf = 0 success, ax = real time in minutes, dx = day (set a bit)
  8410                              <1> ;      cf = 1 failed
  8411                              <1> ;=============================================================================
  8412                              <1> get_realtime:
  8413 00002F0A 53                  <1>         push bx
  8414 00002F0B 51                  <1>         push cx
  8415                              <1> 
  8416 00002F0C B404                <1>         mov ah, 0x04
  8417 00002F0E CD1A                <1>         int 0x1a
  8418 00002F10 723C                <1>         jc .end
  8419                              <1> 
  8420 00002F12 0FB6C6              <1>         movzx ax, dh
  8421 00002F15 E8C9FE              <1>         call bcd_to_bin
  8422 00002F18 88C6                <1>         mov dh, al
  8423 00002F1A 88D0                <1>         mov al, dl
  8424 00002F1C E8C2FE              <1>         call bcd_to_bin
  8425 00002F1F 88C2                <1>         mov dl, al
  8426                              <1> 
  8427 00002F21 89C8                <1>         mov ax, cx
  8428 00002F23 E8BBFE              <1>         call bcd_to_bin
  8429                              <1> 
  8430 00002F26 E85BFE              <1>         call day_in_week
  8431                              <1> 
  8432 00002F29 BA0100              <1>         mov dx, 1
  8433 00002F2C D3E2                <1>         shl dx, cl
  8434                              <1> 
  8435 00002F2E 52                  <1>         push dx
  8436 00002F2F B402                <1>         mov ah, 0x02
  8437 00002F31 CD1A                <1>         int 0x1a
  8438 00002F33 5A                  <1>         pop dx
  8439 00002F34 7218                <1>         jc .end
  8440                              <1> 
  8441 00002F36 0FB6C5              <1>         movzx ax, ch
  8442 00002F39 E8A5FE              <1>         call bcd_to_bin
  8443 00002F3C 88C5                <1>         mov ch, al
  8444                              <1> 
  8445 00002F3E 88C8                <1>         mov al, cl
  8446 00002F40 E89EFE              <1>         call bcd_to_bin
  8447 00002F43 88C1                <1>         mov cl, al
  8448                              <1> 
  8449                              <1> ;convert hour and minute into minute
  8450 00002F45 B03C                <1>         mov al, 60
  8451 00002F47 F6E5                <1>         mul ch
  8452 00002F49 30ED                <1>         xor ch, ch
  8453 00002F4B 01C8                <1>         add ax, cx
  8454                              <1> 
  8455 00002F4D F8                  <1>         clc
  8456                              <1> .end:
  8457 00002F4E 59                  <1>         pop cx
  8458 00002F4F 5B                  <1>         pop bx
  8459                              <1> 
  8460 00002F50 C3                  <1>         ret
  8461                              <1> 
  8462                              <1> 
  8463                              <1> ;=============================================================================
  8464                              <1> ; get_current_time_string ---- get current time string
  8465                              <1> ; input: al = show method, es:di -> buffer
  8466                              <1> ;=============================================================================
  8467                              <1> get_current_time_string:
  8468 00002F51 60                  <1>        pusha
  8469 00002F52 08C0                <1>        or al, al
  8470 00002F54 741D                <1>        jz .end
  8471                              <1> 
  8472 00002F56 B402                <1>        mov ah, 0x02
  8473 00002F58 CD1A                <1>        int 0x1a
  8474 00002F5A 7217                <1>        jc .end
  8475                              <1> 
  8476 00002F5C 89CB                <1>        mov bx, cx
  8477                              <1> 
  8478 00002F5E B90200              <1>        mov cx, 2
  8479                              <1> 
  8480 00002F61 0FB6C7              <1>        movzx ax, bh
  8481 00002F64 E8A8FE              <1>        call bcd_to_str
  8482 00002F67 01CF                <1>        add di, cx
  8483 00002F69 B03A                <1>        mov al, ':'
  8484 00002F6B AA                  <1>        stosb
  8485                              <1> 
  8486 00002F6C 88D8                <1>        mov al, bl
  8487 00002F6E E89EFE              <1>        call bcd_to_str
  8488 00002F71 01CF                <1>        add di, cx
  8489                              <1>        
  8490                              <1> .end:
  8491 00002F73 30C0                <1>        xor al, al
  8492 00002F75 AA                  <1>        stosb
  8493 00002F76 61                  <1>        popa
  8494 00002F77 C3                  <1>        ret      
  8495                              <1> 
  8496                              <1> 
  8497                              <1> ;=============================================================================
  8498                              <1> ; get_current_date_string ---- get current date string
  8499                              <1> ; input: al = show method, es:di -> buffer
  8500                              <1> ;        the method of show date:
  8501                              <1> ;           0 = don't show date
  8502                              <1> ;           1 = day mm-dd-yyyy
  8503                              <1> ;           2 = day yyyy-mm-dd
  8504                              <1> ;           3 = day dd-mm-yyyy
  8505                              <1> ; output: none
  8506                              <1> ;=============================================================================
  8507                              <1> get_current_date_string:
  8508 00002F78 60                  <1>        pusha
  8509                              <1> 
  8510 00002F79 08C0                <1>        or al, al
  8511 00002F7B 7444                <1>        jz .end
  8512                              <1> 
  8513 00002F7D 50                  <1>        push ax
  8514 00002F7E B404                <1>        mov ah, 0x04
  8515 00002F80 CD1A                <1>        int 0x1a
  8516 00002F82 58                  <1>        pop ax
  8517 00002F83 723C                <1>        jc .end
  8518                              <1> 
  8519 00002F85 50                  <1>        push ax
  8520 00002F86 51                  <1>        push cx
  8521 00002F87 52                  <1>        push dx
  8522                              <1> 
  8523 00002F88 0FB6C6              <1>        movzx ax, dh
  8524 00002F8B E853FE              <1>        call bcd_to_bin
  8525 00002F8E 88C6                <1>        mov dh, al
  8526 00002F90 88D0                <1>        mov al, dl
  8527 00002F92 E84CFE              <1>        call bcd_to_bin
  8528 00002F95 88C2                <1>        mov dl, al
  8529                              <1> 
  8530 00002F97 89C8                <1>        mov ax, cx
  8531 00002F99 E845FE              <1>        call bcd_to_bin
  8532                              <1> 
  8533 00002F9C E8E5FD              <1>        call day_in_week
  8534                              <1> 
  8535 00002F9F 89CB                <1>        mov bx, cx
  8536 00002FA1 D1E3                <1>        shl bx, 1
  8537 00002FA3 8BB7[E14C]          <1>        mov si, [str_idx.sunday+bx]
  8538                              <1> 
  8539 00002FA7 E8BDFC              <1>        call strcpy
  8540 00002FAA B020                <1>        mov al, ' '
  8541 00002FAC AA                  <1>        stosb
  8542                              <1> 
  8543 00002FAD 5A                  <1>        pop dx
  8544 00002FAE 5B                  <1>        pop bx
  8545 00002FAF 58                  <1>        pop ax
  8546                              <1> 
  8547 00002FB0 31C9                <1>        xor cx, cx
  8548                              <1> 
  8549 00002FB2 3C01                <1>        cmp al, 1
  8550 00002FB4 7410                <1>        je .mmddyy
  8551 00002FB6 3C02                <1>        cmp al, 2
  8552 00002FB8 7420                <1>        je .yymmdd
  8553 00002FBA 3C03                <1>        cmp al, 3
  8554 00002FBC 7430                <1>        je .ddmmyy
  8555 00002FBE E90000              <1>        jmp .end
  8556                              <1> 
  8557                              <1> .end:       
  8558 00002FC1 30C0                <1>        xor al, al
  8559 00002FC3 AA                  <1>        stosb
  8560 00002FC4 61                  <1>        popa
  8561 00002FC5 C3                  <1>        ret
  8562                              <1> 
  8563                              <1> .mmddyy:
  8564 00002FC6 B02D                <1>        mov al, '-'
  8565 00002FC8 50                  <1>        push ax
  8566 00002FC9 E83600              <1>        call .write_mm
  8567 00002FCC 58                  <1>        pop ax
  8568 00002FCD AA                  <1>        stosb
  8569 00002FCE 50                  <1>        push ax
  8570 00002FCF E83B00              <1>        call .write_dd
  8571 00002FD2 58                  <1>        pop ax
  8572 00002FD3 AA                  <1>        stosb
  8573 00002FD4 E84100              <1>        call .write_yy
  8574                              <1> 
  8575 00002FD7 E9E7FF              <1>        jmp .end
  8576                              <1> 
  8577                              <1> .yymmdd:
  8578 00002FDA B02D                <1>        mov al, '-'
  8579 00002FDC 50                  <1>        push ax
  8580 00002FDD E83800              <1>        call .write_yy
  8581 00002FE0 58                  <1>        pop ax
  8582 00002FE1 AA                  <1>        stosb
  8583 00002FE2 50                  <1>        push ax
  8584 00002FE3 E81C00              <1>        call .write_mm
  8585 00002FE6 58                  <1>        pop ax
  8586 00002FE7 AA                  <1>        stosb
  8587 00002FE8 E82200              <1>        call .write_dd
  8588                              <1> 
  8589 00002FEB E9D3FF              <1>        jmp .end
  8590                              <1> 
  8591                              <1> .ddmmyy:
  8592 00002FEE B02D                <1>        mov al, '-'
  8593 00002FF0 50                  <1>        push ax
  8594 00002FF1 E81900              <1>        call .write_dd
  8595 00002FF4 58                  <1>        pop ax
  8596 00002FF5 AA                  <1>        stosb
  8597 00002FF6 50                  <1>        push ax
  8598 00002FF7 E80800              <1>        call .write_mm
  8599 00002FFA 58                  <1>        pop ax
  8600 00002FFB AA                  <1>        stosb
  8601 00002FFC E81900              <1>        call .write_yy
  8602                              <1> 
  8603 00002FFF E9BFFF              <1>        jmp .end
  8604                              <1> 
  8605                              <1> .write_mm:
  8606 00003002 0FB6C6              <1>        movzx ax, dh
  8607 00003005 B102                <1>        mov cl, 2
  8608 00003007 E805FE              <1>        call bcd_to_str
  8609 0000300A 01CF                <1>        add di, cx
  8610 0000300C C3                  <1>        ret
  8611                              <1> 
  8612                              <1> .write_dd:
  8613 0000300D 0FB6C2              <1>        movzx ax, dl
  8614 00003010 B102                <1>        mov cl, 2
  8615 00003012 E8FAFD              <1>        call bcd_to_str
  8616 00003015 01CF                <1>        add di, cx
  8617 00003017 C3                  <1>        ret
  8618                              <1> 
  8619                              <1> .write_yy:
  8620 00003018 89D8                <1>        mov ax, bx
  8621 0000301A B104                <1>        mov cl, 4
  8622 0000301C E8F0FD              <1>        call bcd_to_str
  8623 0000301F 01CF                <1>        add di, cx
  8624 00003021 C3                  <1>        ret
  8625                              <1> 
  8626                              <1> ;=============================================================================
  8627                              <1> ;calc_checksum ---- calculate the checksum of a data block.
  8628                              <1> ;input:
  8629                              <1> ;      ds:si -> start of the checksum area
  8630                              <1> ;      cx = checksum size
  8631                              <1> ;output:
  8632                              <1> ;      bl = the checksum value.
  8633                              <1> ;=============================================================================
  8634                              <1> calc_checksum:
  8635 00003022 51                  <1>         push cx
  8636 00003023 50                  <1>         push ax
  8637 00003024 56                  <1>         push si
  8638 00003025 30DB                <1>         xor bl, bl
  8639 00003027 FC                  <1>         cld
  8640                              <1> .loop_calc:
  8641 00003028 AC                  <1>         lodsb
  8642 00003029 00C3                <1>         add bl, al
  8643 0000302B E2FB                <1>         loop .loop_calc
  8644 0000302D 5E                  <1>         pop si
  8645 0000302E 58                  <1>         pop ax
  8646 0000302F 59                  <1>         pop cx
  8647 00003030 C3                  <1>         ret
  8648                              <1> 
  8649                              <1> ;=============================================================================
  8650                              <1> ; clear_memory ---- clear a memory block to zero
  8651                              <1> ; input:
  8652                              <1> ;	cx = size
  8653                              <1> ;	ds:di -> memory
  8654                              <1> ;=============================================================================
  8655                              <1> clear_memory:
  8656 00003031 60                  <1> 	pusha
  8657 00003032 06                  <1> 	push es
  8658 00003033 1E                  <1> 	push ds
  8659 00003034 07                  <1> 	pop es
  8660 00003035 30C0                <1> 	xor al, al
  8661 00003037 F3AA                <1> 	rep stosb
  8662 00003039 07                  <1> 	pop es
  8663 0000303A 61                  <1> 	popa
  8664 0000303B C3                  <1> 	ret 
  8665                              <1> 
  8666                              <1> %ifndef MAIN
  8667                              <1> keyboard_type       db 0x10
  8668                              <1> 
  8669                              <1> keymap:
  8670                              <1> .number             dw 0
  8671                              <1> .data               dw 0
  8672                              <1> 
  8673                              <1> str_idx:
  8674                              <1> .sunday             dw string.sunday
  8675                              <1> .monday             dw string.monday
  8676                              <1> .tuesday            dw string.tuesday
  8677                              <1> .wednesday          dw string.wednesday
  8678                              <1> .thursday           dw string.thursday
  8679                              <1> .friday             dw string.friday
  8680                              <1> .saturday           dw string.saturday
  8681                              <1> 
  8682                              <1> string:
  8683                              <1> .sunday              db 'Sun',0
  8684                              <1> .monday              db 'Mon',0
  8685                              <1> .tuesday             db 'Tue',0
  8686                              <1> .wednesday           db 'Wed',0
  8687                              <1> .thursday            db 'Thu',0
  8688                              <1> .friday              db 'Fri',0
  8689                              <1> .saturday            db 'Sat',0
  8690                              <1> 
  8691                              <1> 	section .bss
  8692                              <1> %include "tempdata.asm"
  8693                              <1> %endif
  8694                              <1> 
  8695                              <1> %endif	;End of HAVE_UTILS
  8696                                  %include "knl.asm"
  8697                              <1> ; asmsyntax=nasm
  8698                              <1> ;
  8699                              <1> ; knl.asm
  8700                              <1> ;
  8701                              <1> ; kernel functions for partition list
  8702                              <1> ;
  8703                              <1> ; Copyright (C) 2000, Suzhe. See file COPYING for details.
  8704                              <1> ;
  8705                              <1> 
  8706                              <1> %ifndef HAVE_KNL
  8707                              <1> 
  8708                              <1> %ifndef MAIN
  8709                              <1> %include "knl.h"
  8710                              <1> %include "sbm.h"
  8711                              <1> %include "macros.h"
  8712                              <1> %include "hd_io.asm"
  8713                              <1> %include "myint13h.asm"
  8714                              <1> %include "utils.asm"
  8715                              <1> 	section .text
  8716                              <1> %endif
  8717                              <1> 
  8718                              <1> %define HAVE_KNL
  8719                              <1> %define LIMIT_FLOPPY_NUMBER
  8720                              <1> 
  8721                              <1> %define NUM_OF_ID       (part_type.str_tbl - part_type.id_tbl)
  8722                              <1> %define NUM_OF_LOG_DENY (part_type.auto_act_tbl - part_type.log_deny_tbl)
  8723                              <1> %define NUM_OF_PRI_DENY (part_type.auto_act_tbl - part_type.pri_deny_tbl)
  8724                              <1> %define NUM_OF_AUTO_ACT (part_type.hidden_tbl - part_type.auto_act_tbl)
  8725                              <1> %define NUM_OF_HIDDEN   (part_type.end_of_tbl - part_type.hidden_tbl)
  8726                              <1> %define NUM_OF_ALLOW_HIDE (part_type.hidden_tbl - part_type.allow_hide_tbl)
  8727                              <1> 
  8728                              <1> ;%define NUM_OF_EXT      (part_type.log_deny_tbl - part_type.ext_tbl)
  8729                              <1> 
  8730                              <1> %define MAX_FLOPPY_NUM  2
  8731                              <1> 
  8732                              <1> ;==============================================================================
  8733                              <1> ;fill_bootrecord ---- fill the boot record for a partition
  8734                              <1> ;input:
  8735                              <1> ;      ebx   =  father's abs LBA address
  8736                              <1> ;      dh    =  partition id
  8737                              <1> ;      dl    =  drive id
  8738                              <1> ;      ds:si -> source partition record
  8739                              <1> ;      es:di -> buffer to store the boot record
  8740                              <1> ;output:
  8741                              <1> ;      es:di -> filled with boot record
  8742                              <1> ;==============================================================================
  8743                              <1> fill_bootrecord:
  8744 0000303C 6660                <1>         pushad
  8745 0000303E FC                  <1>         cld
  8746                              <1> 
  8747 0000303F 57                  <1>         push di                                  ; clear the boot record
  8748 00003040 30C0                <1>         xor al, al                               ;
  8749 00003042 B94000              <1>         mov cx, SIZE_OF_BOOTRECORD               ;
  8750 00003045 F3AA                <1>         rep stosb                                ;
  8751 00003047 5F                  <1>         pop di                                   ;
  8752                              <1>         
  8753 00003048 895502              <1>         mov [di + struc_bootrecord.drive_id], dx ; fill the drive_id and
  8754                              <1>                                                  ; part_id
  8755 0000304B 6689D9              <1>         mov ecx, ebx
  8756 0000304E 66894D06            <1>         mov [di + struc_bootrecord.father_abs_addr], ecx
  8757                              <1> 
  8758 00003052 8A7C04              <1>         mov bh, [si + struc_partition.type]
  8759                              <1> 
  8760 00003055 E8530B              <1>         call get_drive_flags
  8761                              <1> 
  8762 00003058 251500              <1>         and ax, DRVFLAG_MASK                     ; set flags
  8763                              <1>         
  8764 0000305B 08F6                <1>         or dh, dh                                ; check if it's a driver record
  8765 0000305D 7507                <1>         jnz .is_partition
  8766 0000305F 0D8000              <1>         or ax, INFOFLAG_ISDRIVER
  8767 00003062 30FF                <1>         xor bh, bh
  8768 00003064 EB0F                <1>         jmp short .set_other_flags
  8769                              <1> 
  8770                              <1> .is_partition:
  8771 00003066 6609C9              <1>         or ecx,ecx                               ;
  8772 00003069 7403                <1>         jz .not_logical                          ;
  8773 0000306B 0D0001              <1>         or ax, INFOFLAG_LOGICAL                  ;
  8774                              <1>         
  8775                              <1> .not_logical:
  8776 0000306E 3A14                <1>         cmp dl, [si + struc_partition.state]     ; test if it's active
  8777                              <1>                                                  ; should changed to
  8778                              <1>                                                  ; cmp 0x80, [xxx] ? 
  8779 00003070 7503                <1>         jne .set_other_flags
  8780 00003072 0D0008              <1>         or ax, INFOFLAG_ACTIVE
  8781                              <1> 
  8782                              <1> .set_other_flags:
  8783                              <1> 
  8784 00003075 51                  <1>         push cx                                  ;
  8785 00003076 57                  <1>         push di                                  ;
  8786                              <1> 
  8787 00003077 A98000              <1>         test ax, INFOFLAG_ISDRIVER
  8788 0000307A 752E                <1>         jnz .not_hidden                          ;
  8789                              <1> 
  8790 0000307C A90001              <1>         test ax, INFOFLAG_LOGICAL                ; ah = record flags
  8791 0000307F 7513                <1>         jnz .not_auto_act                        ;
  8792                              <1> 
  8793 00003081 50                  <1>         push ax                                  ; check if it should
  8794 00003082 8D3E[973A]          <1>         lea di, [part_type.auto_act_tbl]         ; be marked as
  8795 00003086 B90800              <1>         mov cx, NUM_OF_AUTO_ACT                  ; auto active.
  8796 00003089 88F8                <1>         mov al, bh
  8797 0000308B E8AAFB              <1>         call strchr                              ;
  8798 0000308E 58                  <1>         pop ax                                   ;
  8799 0000308F 7203                <1>         jc .not_auto_act                         ;
  8800                              <1> 
  8801 00003091 0D0010              <1>         or ax, INFOFLAG_AUTOACTIVE
  8802                              <1>         
  8803                              <1> .not_auto_act:                                   ;
  8804 00003094 50                  <1>         push ax                                  ; check if it's a
  8805 00003095 8D3E[9F3A]          <1>         lea di, [part_type.hidden_tbl]           ; hidden partition.
  8806 00003099 B90700              <1>         mov cx, NUM_OF_HIDDEN                    ;
  8807 0000309C 88F8                <1>         mov al, bh
  8808 0000309E E897FB              <1>         call strchr                              ;
  8809 000030A1 58                  <1>         pop ax                                   ;
  8810 000030A2 7206                <1>         jc .not_hidden                           ;
  8811                              <1> 
  8812 000030A4 0D0002              <1>         or ax, INFOFLAG_HIDDEN                   ; set the hidden flag
  8813 000030A7 80E70F              <1>         and bh, 0x0F                             ; clear the hidden signature
  8814                              <1>         
  8815                              <1> .not_hidden:
  8816 000030AA 5F                  <1>         pop di
  8817 000030AB 59                  <1>         pop cx
  8818                              <1> 
  8819 000030AC 8905                <1>         mov [di + struc_bootrecord.flags], ax    ; fill the flags and type
  8820 000030AE 887D04              <1>         mov [di + struc_bootrecord.type], bh
  8821                              <1> 
  8822 000030B1 A98000              <1>         test ax, INFOFLAG_ISDRIVER
  8823 000030B4 7507                <1>         jnz .no_abs_addr                         ; if it's floppy, abs_addr = 0
  8824                              <1>         
  8825 000030B6 668B5C08            <1>         mov ebx, [si + struc_partition.relative_addr]    ;
  8826                              <1> 
  8827 000030BA 6601D9              <1>         add ecx, ebx                                     ; ecx = abs_address
  8828                              <1>         
  8829                              <1> .no_abs_addr:
  8830 000030BD 66894D0A            <1>         mov [di + struc_bootrecord.abs_addr], ecx
  8831                              <1> 
  8832 000030C1 A98000              <1>         test ax, INFOFLAG_ISDRIVER
  8833 000030C4 7511                <1>         jnz .isdriver
  8834                              <1> 
  8835 000030C6 A90001              <1>         test ax, INFOFLAG_LOGICAL
  8836 000030C9 7406                <1>         jz .primary
  8837 000030CB 8D36[4139]          <1>         lea si, [knl_strings.logical]               ; it's logical partition
  8838 000030CF EB2B                <1>         jmp short .fill_name                              ;
  8839                              <1> .primary:
  8840 000030D1 8D36[3939]          <1>         lea si, [knl_strings.primary]               ; it's primary partition
  8841 000030D5 EB25                <1>         jmp short .fill_name
  8842                              <1> 
  8843                              <1> .isdriver:
  8844 000030D7 80FA80              <1>         cmp dl, MIN_HD_ID
  8845 000030DA 721C                <1>         jb .floppy
  8846                              <1> 
  8847 000030DC A90400              <1>         test ax, DRVFLAG_REMOVABLE
  8848 000030DF 7411                <1>         jz .harddisk
  8849                              <1> 
  8850 000030E1 A91000              <1> 	test ax, DRVFLAG_ISCDROM
  8851 000030E4 7406                <1> 	jz .removable
  8852                              <1> 
  8853 000030E6 8D36[5C39]          <1> 	lea si, [knl_strings.cdrom]
  8854 000030EA EB10                <1> 	jmp short .fill_name
  8855                              <1> 
  8856                              <1> .removable:
  8857 000030EC 8D36[4939]          <1>         lea si, [knl_strings.removable]
  8858 000030F0 EB0A                <1>         jmp short .fill_name
  8859                              <1> 
  8860                              <1> .harddisk:
  8861 000030F2 8D36[5339]          <1>         lea si, [knl_strings.harddisk]              ; it's hard drive
  8862 000030F6 EB04                <1>         jmp short .fill_name
  8863                              <1> 
  8864                              <1> .floppy:
  8865 000030F8 8D36[3239]          <1>         lea si, [knl_strings.floppy]                ; it's floppy drive
  8866                              <1> 
  8867                              <1> .fill_name:
  8868 000030FC 81C71600            <1>         add di, struc_bootrecord.name
  8869 00003100 B90F00              <1>         mov cx, 15
  8870 00003103 E847FB              <1>         call strncpy
  8871                              <1> 
  8872 00003106 A98000              <1>         test ax, INFOFLAG_ISDRIVER
  8873 00003109 7509                <1>         jnz .end
  8874                              <1> 
  8875 0000310B 88F0                <1>         mov al, dh                                  ; append partition id
  8876 0000310D 30E4                <1>         xor ah, ah                                  ; at the end of the
  8877 0000310F B103                <1>         mov cl, 3                                   ; name
  8878 00003111 E8ACFA              <1>         call itoa                                   ;
  8879                              <1> 
  8880                              <1> .end:
  8881 00003114 6661                <1>         popad
  8882 00003116 C3                  <1>         ret
  8883                              <1> 
  8884                              <1> ;==============================================================================
  8885                              <1> ;fill_special_record ---- fill the boot record for a special command
  8886                              <1> ;input:
  8887                              <1> ;      al = command id
  8888                              <1> ;      es:di -> buffer to store the boot record
  8889                              <1> ;output:
  8890                              <1> ;      es:di -> filled with boot record
  8891                              <1> ;==============================================================================
  8892                              <1> fill_special_record:
  8893 00003117 60                  <1> 	pusha
  8894 00003118 FC                  <1>         cld
  8895                              <1> 
  8896 00003119 50                  <1> 	push ax
  8897 0000311A 57                  <1>         push di                                  ; clear the boot record
  8898 0000311B 30C0                <1>         xor al, al                               ;
  8899 0000311D B94000              <1>         mov cx, SIZE_OF_BOOTRECORD               ;
  8900 00003120 F3AA                <1>         rep stosb                                ;
  8901 00003122 5F                  <1>         pop di                                   ;
  8902 00003123 58                  <1> 	pop ax
  8903                              <1> 
  8904 00003124 810D0800            <1> 	or word [di + struc_bootrecord.flags], INFOFLAG_ISSPECIAL
  8905 00003128 884504              <1> 	mov byte [di + struc_bootrecord.type], al
  8906 0000312B 81C71600            <1> 	add di, struc_bootrecord.name
  8907                              <1> 
  8908 0000312F 31F6                <1> 	xor si, si
  8909                              <1> 
  8910 00003131 3C02                <1> 	cmp al, SPREC_POWEROFF
  8911 00003133 7503                <1> 	jne .not_poweroff
  8912 00003135 BE[6B39]            <1> 	mov si, knl_strings.poweroff
  8913                              <1> 
  8914                              <1> .not_poweroff:
  8915 00003138 3C03                <1> 	cmp al, SPREC_RESTART
  8916 0000313A 7503                <1> 	jne .not_restart
  8917 0000313C BE[7539]            <1> 	mov si, knl_strings.restart
  8918                              <1> 
  8919                              <1> .not_restart:
  8920 0000313F 3C01                <1> 	cmp al, SPREC_QUIT
  8921 00003141 7503                <1> 	jne .not_quit
  8922 00003143 BE[7C39]            <1> 	mov si, knl_strings.quit
  8923                              <1> 
  8924                              <1> .not_quit:
  8925 00003146 3C00                <1> 	cmp al, SPREC_BOOTPREV
  8926 00003148 7503                <1> 	jne .not_bootprev
  8927 0000314A BE[8939]            <1> 	mov si, knl_strings.bootprev
  8928                              <1> 
  8929                              <1> .not_bootprev:
  8930 0000314D B90F00              <1> 	mov cx, 15
  8931 00003150 E8FAFA              <1> 	call strncpy
  8932 00003153 61                  <1> 	popa
  8933 00003154 C3                  <1> 	ret
  8934                              <1> 
  8935                              <1> ;==============================================================================
  8936                              <1> ;get_parttype_str ---- get partition type string
  8937                              <1> ;input:
  8938                              <1> ;      al = partition type
  8939                              <1> ;output:
  8940                              <1> ;      ds:si -> partition type string
  8941                              <1> ;==============================================================================
  8942                              <1> get_parttype_str:
  8943 00003155 57                  <1>         push di
  8944 00003156 51                  <1>         push cx
  8945 00003157 8D3E[9D39]          <1>         lea di, [part_type.id_tbl]
  8946 0000315B B91A00              <1>         mov cx, NUM_OF_ID
  8947 0000315E E8D7FA              <1>         call strchr
  8948 00003161 C1E103              <1>         shl cx, 3                   ; cx = cx * 8
  8949 00003164 8D36[B739]          <1>         lea si, [part_type.str_tbl]
  8950 00003168 01CE                <1>         add si, cx
  8951 0000316A 59                  <1>         pop cx
  8952 0000316B 5F                  <1>         pop di
  8953 0000316C C3                  <1>         ret
  8954                              <1> 
  8955                              <1> ;==============================================================================
  8956                              <1> ;check_bootrecord ---- check if the boot record is ok
  8957                              <1> ;input:
  8958                              <1> ;      ds:si -> boot record
  8959                              <1> ;output:
  8960                              <1> ;      cf = 0 the boot record is ok
  8961                              <1> ;      cf = 1 the boot record cannot boot
  8962                              <1> ;==============================================================================
  8963                              <1> check_bootrecord:
  8964 0000316D 6660                <1>         pushad                           ; save registers
  8965 0000316F 09F6                <1> 	or si, si
  8966 00003171 0F841401            <1> 	jmpz .bad_record
  8967                              <1> 
  8968 00003175 FC                  <1>         cld
  8969                              <1> 
  8970                              <1> ;============= check special record ===========
  8971 00003176 8B04                <1>         mov ax, [si + struc_bootrecord.flags]        ; get record flags
  8972 00003178 A90800              <1> 	test ax, INFOFLAG_ISSPECIAL
  8973 0000317B 0F842400            <1> 	jmpz .normal_record
  8974                              <1> 
  8975 0000317F 8A5C04              <1> 	mov bl, [si + struc_bootrecord.type]
  8976 00003182 80FB04              <1> 	cmp bl, NUM_OF_SPREC
  8977 00003185 0F830001            <1> 	jmpnb .bad_record
  8978                              <1> 
  8979 00003189 80FB02              <1> 	cmp bl, SPREC_POWEROFF
  8980 0000318C 0F850600            <1> 	jmpne .check_prev
  8981                              <1> 
  8982 00003190 E8ACFB              <1> 	call check_apm_bios
  8983 00003193 E9F400              <1> 	jmp .end
  8984                              <1> 
  8985                              <1> .check_prev:
  8986 00003196 80FB00              <1> 	cmp bl, SPREC_BOOTPREV
  8987 00003199 0F85E900            <1> 	jmpne .good_record
  8988                              <1> 
  8989 0000319D E87707              <1> 	call check_prev_mbr
  8990 000031A0 E9E700              <1> 	jmp .end
  8991                              <1> 
  8992                              <1> .normal_record:
  8993                              <1> ;============= check driver ===================
  8994 000031A3 8B5402              <1>         mov dx, [si + struc_bootrecord.drive_id]     ; get drive id and part id
  8995 000031A6 8D3E[4E1A]          <1>         lea di, [hdio_tmp.driveinfo]
  8996 000031AA E81609              <1>         call get_drive_info                          ; check if the drive ok
  8997 000031AD 0F82D800            <1>         jmpc .bad_record
  8998                              <1> 
  8999 000031B1 50                  <1>         push ax
  9000 000031B2 8A6501              <1>         mov ah, [di + struc_driveinfo.flags]         ;
  9001 000031B5 251515              <1>         and ax, ( DRVFLAG_MASK << 8) | DRVFLAG_MASK  ; check if the flags was
  9002 000031B8 38E0                <1>         cmp al, ah                                   ; changed
  9003 000031BA 58                  <1>         pop ax                                       ;
  9004 000031BB 0F85CA00            <1>         jmpne .bad_record
  9005                              <1> 
  9006 000031BF A98000              <1>         test ax, INFOFLAG_ISDRIVER                   ; if it's a driver then ok
  9007 000031C2 0F85C000            <1>         jmpnz .good_record
  9008                              <1> 
  9009                              <1> ;============ check partition =================
  9010                              <1> ; now we know it's a partiton!
  9011 000031C6 8A5C04              <1>         mov bl, [si + struc_bootrecord.type]
  9012 000031C9 08DB                <1>         or bl, bl                                    
  9013 000031CB 0F84BA00            <1>         jmpz .bad_record                               ; it's free, bad!
  9014                              <1> 
  9015                              <1> .not_free:
  9016 000031CF A90001              <1>         test ax, INFOFLAG_LOGICAL                    ; it's logical partition
  9017 000031D2 7509                <1>         jnz .logical_part                            ;
  9018                              <1> 
  9019 000031D4 B90400              <1>         mov cx, NUM_OF_PRI_DENY                      ;
  9020 000031D7 8D3E[933A]          <1>         lea di, [part_type.pri_deny_tbl]             ;
  9021 000031DB EB07                <1>         jmp short .check_type                        ; check if the partition
  9022                              <1> 
  9023                              <1> .logical_part:                                       ; type is in the deny
  9024 000031DD B90800              <1>         mov cx, NUM_OF_LOG_DENY                      ; table
  9025 000031E0 8D3E[8F3A]          <1>         lea di, [part_type.log_deny_tbl]             ;
  9026                              <1> 
  9027                              <1> .check_type:                                         ;
  9028 000031E4 50                  <1>         push ax
  9029 000031E5 88D8                <1>         mov al, bl                                   ; al = partition type
  9030 000031E7 E84EFA              <1>         call strchr                                  ;
  9031 000031EA 58                  <1>         pop ax
  9032 000031EB 0F839A00            <1>         jmpnc .bad_record                              ; this type is denied!
  9033                              <1> 
  9034                              <1> ;================ check in father ===================        
  9035                              <1> ; read father's partition table into buffer and check it
  9036 000031EF 50                  <1>         push ax                                      ; save flags
  9037                              <1> 
  9038 000031F0 668B5C06            <1>         mov ebx, [si + struc_bootrecord.father_abs_addr]
  9039                              <1> 
  9040 000031F4 B80102              <1>         mov ax, (INT13H_READ << 8 ) | 0x01           ; read the first sector
  9041 000031F7 8D3E[741A]          <1>         lea di, [knl_tmp.disk_buf1]                           ; into buffer
  9042 000031FB E86C0A              <1>         call disk_access                             ;
  9043 000031FE 58                  <1>         pop ax                                       ; load flags
  9044 000031FF 0F828600            <1>         jmpc .bad_record
  9045                              <1> 
  9046 00003203 81BDFE0155AA        <1>         cmp word [di + BR_FLAG_OFF], BR_GOOD_FLAG    ; check if the father is
  9047 00003209 757E                <1>         jne .bad_record                              ; good
  9048                              <1> 
  9049 0000320B 668B4C0A            <1>         mov ecx, [si + struc_bootrecord.abs_addr]    ; get partition's abs addr
  9050 0000320F 6629D9              <1>         sub ecx, ebx                                 ; calculate relative address
  9051 00003212 6689CB              <1> 	mov ebx, ecx
  9052                              <1> 
  9053 00003215 81C7BE01            <1>         add di, PART_TBL_OFF                         ; point to father's partition
  9054                              <1>                                                      ; table
  9055 00003219 B90400              <1>         mov cx, 4
  9056                              <1>         
  9057                              <1> .search_in_father:                                   ; find the record in
  9058 0000321C 807D0400            <1> 	cmp byte [di + struc_partition.type], 0      ;
  9059 00003220 7406                <1> 	je .invalid_entry
  9060 00003222 66395D08            <1>         cmp [di + struc_partition.relative_addr], ebx; father's partition
  9061 00003226 7409                <1>         je .found_it     
  9062                              <1> .invalid_entry:                                      ; table
  9063 00003228 81C71000            <1>         add di, SIZE_OF_PARTITION                    ;
  9064 0000322C E2EE                <1>         loop .search_in_father                       ;
  9065 0000322E E95800              <1>         jmp .bad_record                        ; not found! it's bad.
  9066                              <1>         
  9067                              <1> .found_it:
  9068                              <1> 
  9069                              <1> ;adjust some flags of the boot record.
  9070                              <1> ;there is no other place to suit these codes,
  9071                              <1> ;so I place them here :-(
  9072                              <1> 
  9073 00003231 50                  <1>         push ax                                      ;
  9074 00003232 57                  <1>         push di                                      ; hidden partition
  9075 00003233 8A5D04              <1>         mov bl, [di + struc_partition.type]          ; check if it's a
  9076 00003236 88D8                <1>         mov al, bl                                   ;
  9077 00003238 8D3E[9F3A]          <1>         lea di, [part_type.hidden_tbl]               ;
  9078 0000323C B90700              <1>         mov cx, NUM_OF_HIDDEN                        ;
  9079 0000323F E8F6F9              <1>         call strchr                                  ;
  9080 00003242 5F                  <1>         pop di                                       ;
  9081 00003243 58                  <1>         pop ax                                       ;
  9082 00003244 7208                <1>         jc .not_hidden                               ;
  9083 00003246 80E30F              <1>         and bl, 0x0F
  9084 00003249 0D0002              <1>         or ax, INFOFLAG_HIDDEN                       ; set hidden flag.
  9085 0000324C EB03                <1>         jmp short .validate_type
  9086                              <1> 
  9087                              <1> .not_hidden:
  9088 0000324E 25FFFD              <1>         and ax, ~ INFOFLAG_HIDDEN                    ; clear hidden flag.
  9089                              <1> 
  9090                              <1> .validate_type:
  9091                              <1> 
  9092                              <1> %ifdef STRICT_PART_CHECK
  9093 00003251 3A5C04              <1>         cmp bl, [si + struc_bootrecord.type]         ; check the partition type
  9094 00003254 7533                <1>         jne .bad_record                              ; wrong type!
  9095                              <1> %else
  9096                              <1> 	mov [si + struc_bootrecord.type], bl         ; set partition type
  9097                              <1> %endif
  9098                              <1> 
  9099                              <1> .type_ok:
  9100 00003256 52                  <1>         push dx
  9101 00003257 A90020              <1>         test ax, INFOFLAG_SWAPDRVID                  ; check if swap driver id
  9102 0000325A 7403                <1>         jz .no_swapid
  9103 0000325C 80E280              <1>         and dl, 0x80
  9104                              <1> 
  9105                              <1> .no_swapid:
  9106 0000325F 3A15                <1>         cmp dl, [di + struc_partition.state]         ; check if the partition
  9107 00003261 5A                  <1>         pop dx
  9108 00003262 7505                <1>         jne .not_active                              ; is active.
  9109 00003264 0D0008              <1>         or ax, INFOFLAG_ACTIVE                       ; should change to
  9110 00003267 EB03                <1>         jmp short .adjust_flags                      ; cmp 0x80, byte [state] ?
  9111                              <1> 
  9112                              <1> .not_active:
  9113 00003269 25FFF7              <1>         and ax, ~ INFOFLAG_ACTIVE
  9114                              <1> 
  9115                              <1> .adjust_flags:
  9116 0000326C 8904                <1>         mov [si + struc_bootrecord.flags], ax
  9117                              <1> 
  9118                              <1> ;==================  check partition itself ==============
  9119                              <1> .check_inside:                                       ; check partition itself
  9120                              <1> 
  9121                              <1> %ifdef STRICT_PART_CHECK
  9122 0000326E 668B5C0A            <1>         mov ebx, [si + struc_bootrecord.abs_addr]
  9123                              <1> 
  9124 00003272 8D3E[741A]          <1>         lea di, [knl_tmp.disk_buf1]
  9125 00003276 B80102              <1>         mov ax, (INT13H_READ << 8 ) | 0x01           ; read the first sector
  9126 00003279 E8EE09              <1>         call disk_access                             ; into buffer
  9127 0000327C 720B                <1>         jc .bad_record                               ; read error!
  9128                              <1>         
  9129 0000327E 81BDFE0155AA        <1>         cmp word [di + BR_FLAG_OFF], BR_GOOD_FLAG    ; check if the paritition
  9130 00003284 7503                <1>         jne .bad_record                              ; is good
  9131                              <1> %endif
  9132                              <1> 
  9133                              <1> .good_record:
  9134 00003286 F8                  <1>         clc
  9135 00003287 EB01                <1>         jmp short .end
  9136                              <1> 
  9137                              <1> .bad_record:
  9138 00003289 F9                  <1>         stc
  9139                              <1> .end:
  9140 0000328A 6661                <1>         popad
  9141 0000328C C3                  <1>         ret
  9142                              <1> 
  9143                              <1> ;==============================================================================
  9144                              <1> ;search_drv_records ---- search all driver records 
  9145                              <1> ;input:
  9146                              <1> ;      dl = beginning driver id.
  9147                              <1> ;      cl = max number of boot records could be searched
  9148                              <1> ;      es:di -> buffer to store boot records. 
  9149                              <1> ;output:
  9150                              <1> ;      ch = number of the valid boot records have searched
  9151                              <1> ;==============================================================================
  9152                              <1> search_drv_records:
  9153 0000328D 30ED                <1>        xor ch, ch
  9154 0000328F 882E[591A]          <1>        mov [knl_tmp.good_record_num], ch
  9155 00003293 880E[5A1A]          <1>        mov [knl_tmp.max_record_num], cl
  9156 00003297 882E[601A]          <1>        mov [knl_tmp.floppy_num], ch
  9157 0000329B 08C9                <1>        or cl, cl 
  9158 0000329D 7501                <1>        jnz .can_search_more
  9159 0000329F C3                  <1>        ret
  9160                              <1> 
  9161                              <1> .can_search_more:
  9162 000032A0 60                  <1>        pusha
  9163 000032A1 6631DB              <1>        xor ebx, ebx
  9164 000032A4 30F6                <1>        xor dh, dh
  9165                              <1> 
  9166                              <1> .loop_search:
  9167 000032A6 E80209              <1>        call get_drive_flags
  9168 000032A9 722D                <1>        jc .search_next
  9169                              <1> 
  9170 000032AB A801                <1>        test al, DRVFLAG_DRIVEOK
  9171 000032AD 7229                <1>        jc .search_next
  9172                              <1> 
  9173                              <1> %ifdef LIMIT_FLOPPY_NUMBER
  9174 000032AF 80FA80              <1>        cmp dl, MIN_HD_ID
  9175 000032B2 730F                <1>        jae .isharddisk
  9176 000032B4 A804                <1>        test al, DRVFLAG_REMOVABLE
  9177 000032B6 740B                <1>        jz .isharddisk
  9178                              <1> 
  9179 000032B8 FE06[601A]          <1>        inc byte [knl_tmp.floppy_num]
  9180 000032BC 803E[601A]02        <1>        cmp byte [knl_tmp.floppy_num], MAX_FLOPPY_NUM
  9181 000032C1 7715                <1>        ja .search_next
  9182                              <1> 
  9183                              <1> .isharddisk:
  9184                              <1> %endif
  9185                              <1> 
  9186 000032C3 E876FD              <1>        call fill_bootrecord
  9187 000032C6 FE06[591A]          <1>        inc byte [knl_tmp.good_record_num]
  9188 000032CA 8A26[591A]          <1>        mov ah, [knl_tmp.good_record_num]                ; check if there are any
  9189 000032CE 3A26[5A1A]          <1>        cmp ah, [knl_tmp.max_record_num]                 ; more space.
  9190 000032D2 730A                <1>        jae .end
  9191                              <1> 
  9192 000032D4 81C74000            <1>        add di, SIZE_OF_BOOTRECORD
  9193                              <1> 
  9194                              <1> .search_next:
  9195 000032D8 FEC2                <1>        inc dl
  9196 000032DA 08D2                <1>        or dl, dl
  9197 000032DC 75C8                <1>        jnz .loop_search
  9198                              <1> 
  9199                              <1> .end:
  9200 000032DE 61                  <1>        popa
  9201 000032DF 8A2E[591A]          <1>        mov ch, [knl_tmp.good_record_num]
  9202 000032E3 C3                  <1>        ret
  9203                              <1> 
  9204                              <1> 
  9205                              <1> ;==============================================================================
  9206                              <1> ;search_part_records ---- search all boot records in a drive
  9207                              <1> ;input:
  9208                              <1> ;      dl = drive id
  9209                              <1> ;      cl = max number of boot records could be searched
  9210                              <1> ;      es:di -> buffer to store boot records
  9211                              <1> ;output:
  9212                              <1> ;      ch = number of the valid boot records have searched
  9213                              <1> ;==============================================================================
  9214                              <1> search_part_records:
  9215 000032E4 30ED                <1>         xor ch, ch
  9216 000032E6 882E[591A]          <1>         mov [knl_tmp.good_record_num], ch
  9217 000032EA 880E[5A1A]          <1>         mov [knl_tmp.max_record_num], cl
  9218 000032EE 08C9                <1>         or cl, cl
  9219 000032F0 7501                <1>         jnz .can_search_more                         ; check if there are any
  9220 000032F2 C3                  <1>         ret                                          ; space to search more.
  9221                              <1>         
  9222                              <1> .can_search_more:
  9223 000032F3 60                  <1>         pusha
  9224                              <1> 
  9225 000032F4 6631DB              <1>         xor ebx, ebx                                 ; clear some stuff
  9226 000032F7 30F6                <1>         xor dh, dh                                   ;
  9227                              <1> 
  9228 000032F9 E8AF08              <1>         call get_drive_flags                         ; get the drive flags.
  9229 000032FC 0F82A800            <1>         jmpc .end
  9230                              <1>         
  9231 00003300 A804                <1>         test al, DRVFLAG_REMOVABLE                  ; check if it's a floppy
  9232 00003302 0F85A200            <1>         jmpnz .end
  9233 00003306 A810                <1> 	test al, DRVFLAG_ISCDROM
  9234 00003308 0F859C00            <1> 	jmpnz .end
  9235                              <1> 
  9236                              <1> ;search partitions
  9237                              <1> .search_partitions:
  9238 0000330C 57                  <1>         push di
  9239 0000330D 8D3E[7422]          <1>         lea di, [knl_tmp.disk_buf2]
  9240 00003311 89FE                <1>         mov si, di
  9241 00003313 B80102              <1>         mov ax, (INT13H_READ << 8 ) | 0x01           ; read the first sector
  9242 00003316 E85109              <1>         call disk_access                             ; into buffer
  9243 00003319 5F                  <1>         pop di
  9244 0000331A 0F828A00            <1>         jmpc .end
  9245                              <1>         
  9246 0000331E 81BCFE0155AA        <1>         cmp word [si + BR_FLAG_OFF], BR_GOOD_FLAG    ; check if the partition
  9247 00003324 0F858000            <1>         jmpne .end                                   ; table is good
  9248                              <1>         
  9249 00003328 81C6BE01            <1>         add si, PART_TBL_OFF                         ; point to partition table
  9250                              <1>         
  9251 0000332C 30C0                <1>         xor al, al
  9252                              <1> 
  9253                              <1> .loop_search_part:
  9254 0000332E FEC0                <1>         inc al
  9255                              <1> 
  9256 00003330 6609DB              <1>         or ebx, ebx                                  ; check if it's primary
  9257 00003333 7508                <1>         jnz .logical_part
  9258                              <1>         
  9259 00003335 88C6                <1>         mov dh, al                                   ;
  9260 00003337 8836[5B1A]          <1>         mov [knl_tmp.part_id], dh                        ;
  9261 0000333B EB04                <1>         jmp short .cont_fill_it                      ; get the partition id
  9262                              <1>                                                      ;
  9263                              <1> .logical_part:                                       ;
  9264 0000333D 8A36[5B1A]          <1>         mov dh, [knl_tmp.part_id]                        ;
  9265                              <1>         
  9266                              <1> .cont_fill_it:
  9267 00003341 E8F8FC              <1>         call fill_bootrecord                         ; fill the boot record
  9268 00003344 87F7                <1>         xchg si, di
  9269 00003346 E824FE              <1>         call check_bootrecord                        ; check if it's valid
  9270 00003349 87F7                <1>         xchg si, di
  9271 0000334B 7212                <1>         jc .cont_search_part
  9272                              <1> 
  9273                              <1> ; find a valid boot record!
  9274                              <1> 
  9275 0000334D FE06[591A]          <1>         inc byte [knl_tmp.good_record_num]
  9276 00003351 8A26[591A]          <1>         mov ah, [knl_tmp.good_record_num]                ; check if there are any
  9277 00003355 3A26[5A1A]          <1>         cmp ah, [knl_tmp.max_record_num]                 ; more space.
  9278 00003359 734D                <1>         jae .end
  9279                              <1> 
  9280 0000335B 81C74000            <1>         add di, SIZE_OF_BOOTRECORD                   ; move the pointer to
  9281                              <1> 
  9282                              <1> .cont_search_part:
  9283 0000335F 81C61000            <1>         add si, SIZE_OF_PARTITION
  9284 00003363 3C04                <1>         cmp al, 4
  9285 00003365 72C7                <1>         jb .loop_search_part
  9286                              <1>         
  9287 00003367 81EE4000            <1>         sub si, SIZE_OF_PARTITION * 4
  9288                              <1>         
  9289                              <1> ;now go ahead to search logical partitons
  9290 0000336B 30E4                <1>         xor ah, ah
  9291                              <1> 
  9292                              <1> .loop_search_ext:
  9293 0000336D FEC4                <1>         inc ah
  9294 0000336F 8A4404              <1>         mov al, [si + struc_partition.type]
  9295                              <1>         
  9296 00003372 3C05                <1>         cmp al, 0x05                                 ; check if it's
  9297 00003374 7413                <1>         je .found_ext                                ; extended
  9298 00003376 3C0F                <1>         cmp al, 0x0F                                 ; partition
  9299 00003378 740F                <1>         je .found_ext                                ;
  9300 0000337A 3C85                <1>         cmp al, 0x85                                 ;
  9301 0000337C 740B                <1>         je .found_ext                                ;
  9302                              <1> 
  9303 0000337E 81C61000            <1>         add si, SIZE_OF_PARTITION
  9304 00003382 80FC04              <1>         cmp ah, 4
  9305 00003385 72E6                <1>         jb .loop_search_ext
  9306 00003387 EB1F                <1>         jmp short .end
  9307                              <1> 
  9308                              <1> ;there are some extended partitions, find inside it!
  9309                              <1> .found_ext:
  9310 00003389 FE06[5B1A]          <1>         inc byte [knl_tmp.part_id]                       ; increase the partition id.
  9311 0000338D 668B4C08            <1> 	mov ecx, [si + struc_partition.relative_addr]
  9312                              <1> 
  9313 00003391 6609DB              <1>         or ebx, ebx                                  ; all of the later logical
  9314 00003394 7407                <1>         jz .first_ext                                ; extended partitions' relative
  9315 00003396 668B1E[5C1A]        <1>         mov ebx, [knl_tmp.logi_father]                   ; address are based on the
  9316 0000339B EB05                <1>         jmp short .calc_next_father                  ; first primary extended
  9317                              <1>                                                      ; partition
  9318                              <1> .first_ext:
  9319 0000339D 66890E[5C1A]        <1>         mov [knl_tmp.logi_father], ecx
  9320                              <1> 
  9321                              <1> .calc_next_father:
  9322 000033A2 6601CB              <1>         add ebx, ecx                                 ; calculate the next
  9323                              <1>                                                      ; father's abs
  9324                              <1>                                                      ; address
  9325                              <1>         
  9326 000033A5 E964FF              <1>         jmp .search_partitions                       ; continue search
  9327                              <1> 
  9328                              <1> .end:
  9329 000033A8 61                  <1>         popa
  9330 000033A9 8A2E[591A]          <1>         mov ch, [knl_tmp.good_record_num]
  9331 000033AD C3                  <1>         ret
  9332                              <1>         
  9333                              <1> ;==============================================================================
  9334                              <1> ;search_specials ---- search all special boot records
  9335                              <1> ;input:
  9336                              <1> ;      cl = max number of boot records could be searched
  9337                              <1> ;      es:di -> buffer to store boot records
  9338                              <1> ;output:
  9339                              <1> ;      ch = number of the valid boot records have searched
  9340                              <1> ;==============================================================================
  9341                              <1> search_specials:
  9342 000033AE 50                  <1> 	push ax
  9343 000033AF 52                  <1> 	push dx
  9344 000033B0 56                  <1> 	push si
  9345                              <1> 
  9346 000033B1 88CC                <1> 	mov ah, cl
  9347 000033B3 80FC04              <1> 	cmp ah, NUM_OF_SPREC
  9348 000033B6 7202                <1> 	jb .do_search
  9349 000033B8 B404                <1> 	mov ah, NUM_OF_SPREC
  9350                              <1> 
  9351                              <1> .do_search:
  9352 000033BA 30ED                <1> 	xor ch, ch
  9353 000033BC 30C0                <1> 	xor al, al
  9354 000033BE 08E4                <1> 	or ah, ah
  9355 000033C0 7416                <1> 	jz .end
  9356                              <1> 
  9357                              <1> .loop_search:
  9358 000033C2 E852FD              <1> 	call fill_special_record
  9359 000033C5 89FE                <1> 	mov si, di
  9360 000033C7 E8A3FD              <1> 	call check_bootrecord
  9361 000033CA 7206                <1> 	jc .search_next
  9362 000033CC 81C74000            <1> 	add di, SIZE_OF_BOOTRECORD
  9363 000033D0 FEC5                <1> 	inc ch
  9364                              <1> .search_next:
  9365 000033D2 FEC0                <1> 	inc al
  9366 000033D4 38E0                <1> 	cmp al, ah
  9367 000033D6 72EA                <1> 	jb .loop_search
  9368                              <1> .end:
  9369 000033D8 5E                  <1> 	pop si
  9370 000033D9 5A                  <1> 	pop dx
  9371 000033DA 58                  <1> 	pop ax
  9372 000033DB C3                  <1> 	ret
  9373                              <1> 
  9374                              <1> ;==============================================================================
  9375                              <1> ;search_records ---- search all boot records
  9376                              <1> ;input:
  9377                              <1> ;      al = 0 all records, al = 1 only partitions
  9378                              <1> ;      cl = max number of boot records could be searched
  9379                              <1> ;      es:di -> buffer to store boot records
  9380                              <1> ;output:
  9381                              <1> ;      ch = number of the valid boot records have searched
  9382                              <1> ;==============================================================================
  9383                              <1> search_records:
  9384 000033DC 57                  <1> 	push di
  9385 000033DD 52                  <1> 	push dx
  9386 000033DE 53                  <1> 	push bx
  9387 000033DF 50                  <1> 	push ax
  9388                              <1> 
  9389 000033E0 31D2                <1>         xor dx, dx
  9390                              <1> 
  9391 000033E2 08C0                <1> 	or al, al
  9392 000033E4 7516                <1> 	jnz .search_parts
  9393                              <1> 
  9394 000033E6 E8C5FF              <1> 	call search_specials
  9395 000033E9 28E9                <1> 	sub cl, ch
  9396 000033EB 88EE                <1> 	mov dh, ch
  9397                              <1> 
  9398 000033ED B340                <1>         mov bl, SIZE_OF_BOOTRECORD
  9399                              <1> 
  9400 000033EF E89BFE              <1>         call search_drv_records
  9401 000033F2 28E9                <1>         sub cl, ch
  9402 000033F4 88E8                <1>         mov al, ch
  9403 000033F6 00EE                <1> 	add dh, ch
  9404 000033F8 F6E3                <1>         mul bl
  9405 000033FA 01C7                <1>         add di, ax
  9406                              <1> 
  9407                              <1> .search_parts:
  9408 000033FC E80700              <1> 	call search_all_partitions
  9409 000033FF 00F5                <1> 	add ch, dh
  9410 00003401 58                  <1> 	pop ax
  9411 00003402 5B                  <1> 	pop bx
  9412 00003403 5A                  <1> 	pop dx
  9413 00003404 5F                  <1> 	pop di
  9414 00003405 C3                  <1> 	ret
  9415                              <1> 
  9416                              <1> ;==============================================================================
  9417                              <1> ;search_all_partitions ---- search all partitions in all drives
  9418                              <1> ;input:
  9419                              <1> ;      cl = max number of boot records could be searched
  9420                              <1> ;      dl = lowest drive id to be searched
  9421                              <1> ;      es:di -> buffer to store boot records
  9422                              <1> ;output:
  9423                              <1> ;      ch = number of the valid boot records have searched
  9424                              <1> ;==============================================================================
  9425                              <1> search_all_partitions:
  9426 00003406 50                  <1>         push ax
  9427 00003407 52                  <1> 	push dx
  9428 00003408 30F6                <1> 	xor dh, dh
  9429 0000340A B340                <1>         mov bl, SIZE_OF_BOOTRECORD
  9430                              <1> 
  9431                              <1> .loop_search:
  9432 0000340C E8D5FE              <1>         call search_part_records
  9433 0000340F 28E9                <1>         sub cl, ch
  9434 00003411 00EE                <1>         add dh, ch                                   ; count the searched boot
  9435                              <1>                                                      ; records
  9436 00003413 88E8                <1>         mov al, ch                                   ;
  9437 00003415 F6E3                <1>         mul bl                                       ; adjust the pointer (di)
  9438 00003417 01C7                <1>         add di, ax                                   ;
  9439 00003419 FEC2                <1>         inc dl
  9440 0000341B 08D2                <1>         or dl, dl
  9441 0000341D 75ED                <1>         jnz .loop_search
  9442 0000341F 88F5                <1>         mov ch, dh
  9443 00003421 5A                  <1> 	pop dx
  9444 00003422 58                  <1>         pop ax
  9445 00003423 C3                  <1>         ret
  9446                              <1> 
  9447                              <1> 
  9448                              <1> ;==============================================================================
  9449                              <1> ;get_record_typestr ---- get a record's type string
  9450                              <1> ;input:
  9451                              <1> ;      ds:si -> the record
  9452                              <1> ;      es:di -> the buffer to store the type string
  9453                              <1> ;output:
  9454                              <1> ;      none
  9455                              <1> ;==============================================================================
  9456                              <1> get_record_typestr:
  9457 00003424 60                  <1>         pusha
  9458 00003425 8B04                <1>         mov ax, [si + struc_bootrecord.flags]
  9459 00003427 8A5C04              <1>         mov bl, [si + struc_bootrecord.type]
  9460 0000342A 8B5402              <1>         mov dx, [si + struc_bootrecord.drive_id]
  9461                              <1> 
  9462 0000342D A90800              <1> 	test ax, INFOFLAG_ISSPECIAL
  9463 00003430 751A                <1> 	jnz .special
  9464                              <1> 
  9465 00003432 A98000              <1>         test ax, INFOFLAG_ISDRIVER
  9466 00003435 7430                <1>         jz .partition
  9467                              <1> 
  9468 00003437 A90400              <1>         test ax, DRVFLAG_REMOVABLE
  9469 0000343A 741C                <1>         jz .harddisk
  9470                              <1> 
  9471 0000343C F6C280              <1>         test dl, 0x80
  9472 0000343F 741D                <1>         jz .floppy
  9473                              <1> 
  9474 00003441 A91000              <1> 	test ax, DRVFLAG_ISCDROM
  9475 00003444 740C                <1> 	jz .removable
  9476                              <1> 
  9477 00003446 8D36[5C39]          <1> 	lea si, [knl_strings.cdrom]
  9478 0000344A EB16                <1> 	jmp short .filldrv
  9479                              <1> 
  9480                              <1> .special:
  9481 0000344C 8D36[6339]          <1> 	lea si, [knl_strings.special]
  9482 00003450 EB10                <1> 	jmp short .filldrv
  9483                              <1> 
  9484                              <1> .removable:
  9485 00003452 8D36[4939]          <1>         lea si, [knl_strings.removable]
  9486 00003456 EB0A                <1>         jmp short .filldrv
  9487                              <1> 
  9488                              <1> .harddisk:
  9489 00003458 8D36[5339]          <1>         lea si, [knl_strings.harddisk]
  9490 0000345C EB04                <1>         jmp short .filldrv
  9491                              <1> 
  9492                              <1> .floppy:
  9493 0000345E 8D36[3239]          <1>         lea si, [knl_strings.floppy]
  9494                              <1> 
  9495                              <1> .filldrv:
  9496 00003462 E802F8              <1>         call strcpy
  9497 00003465 EB27                <1>         jmp short .end
  9498                              <1> 
  9499                              <1> .partition:
  9500 00003467 A90001              <1>         test ax, INFOFLAG_LOGICAL
  9501 0000346A 7406                <1>         jz short .primary
  9502                              <1> 
  9503 0000346C 8D36[4139]          <1>         lea si, [knl_strings.logical]
  9504 00003470 EB04                <1>         jmp short .fillpart
  9505                              <1> 
  9506                              <1> .primary:
  9507 00003472 8D36[3939]          <1>         lea si, [knl_strings.primary]
  9508                              <1> 
  9509                              <1> .fillpart:
  9510 00003476 E8EEF7              <1>         call strcpy
  9511                              <1> 
  9512 00003479 C7052028            <1>         mov word [di], ' ('
  9513 0000347D 47                  <1>         inc di
  9514 0000347E 47                  <1>         inc di
  9515                              <1> 
  9516 0000347F 88D8                <1>         mov al, bl
  9517 00003481 E8D1FC              <1>         call get_parttype_str
  9518 00003484 E8E0F7              <1>         call strcpy
  9519 00003487 C60529              <1>         mov byte [di], ')'
  9520 0000348A 47                  <1>         inc di
  9521 0000348B 30C0                <1>         xor al, al
  9522 0000348D AA                  <1>         stosb
  9523                              <1> 
  9524                              <1> .end:
  9525 0000348E 61                  <1>         popa
  9526 0000348F C3                  <1>         ret
  9527                              <1> 
  9528                              <1> ;==============================================================================
  9529                              <1> ;get_record_string ---- get a record's string
  9530                              <1> ;input:
  9531                              <1> ;      ds:si -> the record
  9532                              <1> ;      es:di -> buffer to store the string
  9533                              <1> ;      al =1    don't draw flags
  9534                              <1> ;      al =2    don't draw flags and number
  9535                              <1> ;      al =3    don't draw flags and type
  9536                              <1> ;
  9537                              <1> ;output:
  9538                              <1> ;      none
  9539                              <1> ;
  9540                              <1> ;notes:
  9541                              <1> ; the string layout is:
  9542                              <1> ; pSkXaAhHlD  128 01  (Type )  Partition Name.
  9543                              <1> ; where :
  9544                              <1> ; p  is password flag, means have password.
  9545                              <1> ; S  is schedule flag, means have boot schedule set.
  9546                              <1> ; k  is keystrokes flag, means have keystrokes set.
  9547                              <1> ; X  is swap driver id flag, means the driver id will be swap to the bootable
  9548                              <1> ;    id when boot this record.
  9549                              <1> ; aA is active flags, a means auto active, A means active
  9550                              <1> ; hH is hidden flags, h means auto hide, H means hidden
  9551                              <1> ; lD is other flags, L means it's Logical Partition, D means it's Disk Driver 
  9552                              <1> ; 128 is the drive id
  9553                              <1> ; 01 is the partition id
  9554                              <1> ; (Type ) is the type of this partition, 7 bytes
  9555                              <1> ; Partition Name is the name of this partition, 15 bytes
  9556                              <1> ;==============================================================================
  9557                              <1> get_record_string:
  9558 00003490 60                  <1>         pusha
  9559 00003491 FC                  <1>         cld
  9560                              <1> 
  9561 00003492 668B4C0E            <1>         mov ecx, [si + struc_bootrecord.password]
  9562 00003496 8B1C                <1>         mov bx, [si + struc_bootrecord.flags]
  9563                              <1> 
  9564 00003498 88C4                <1> 	mov ah, al
  9565                              <1> 
  9566 0000349A B020                <1> 	mov al, ' '
  9567 0000349C AA                  <1> 	stosb
  9568                              <1> 
  9569 0000349D 08E4                <1>         or ah, ah
  9570 0000349F 752C                <1>         jnz .no_flags
  9571 000034A1 50                  <1> 	push ax
  9572                              <1> 
  9573                              <1> ;show flags
  9574                              <1> 
  9575 000034A2 B02D                <1>         mov al, '-'
  9576                              <1> 
  9577 000034A4 50                  <1>         push ax
  9578 000034A5 6609C9              <1>         or ecx, ecx                                 ; check if has password.
  9579 000034A8 7402                <1>         jz .no_password
  9580 000034AA B070                <1>         mov al, 'p'                                 ; has password, draw a 'p'.
  9581                              <1> .no_password:
  9582 000034AC AA                  <1>         stosb
  9583 000034AD 58                  <1>         pop ax
  9584                              <1> 
  9585 000034AE 56                  <1>         push si
  9586 000034AF BA0080              <1>         mov dx, INFOFLAG_SCHEDULED
  9587 000034B2 B90900              <1>         mov cx, NUM_OF_INFOFLAGS
  9588 000034B5 8D36[2839]          <1>         lea si, [infoflag_chars]
  9589                              <1> 
  9590                              <1> .loop_show_flags:
  9591 000034B9 50                  <1>         push ax
  9592 000034BA 85D3                <1>         test bx, dx
  9593 000034BC 7402                <1>         jz .no_thisflag
  9594 000034BE 8A04                <1>         mov al, [si]
  9595                              <1> .no_thisflag:
  9596 000034C0 AA                  <1>         stosb
  9597 000034C1 58                  <1>         pop ax
  9598 000034C2 46                  <1>         inc si
  9599 000034C3 D1EA                <1>         shr dx, 1
  9600 000034C5 E2F2                <1>         loop .loop_show_flags
  9601 000034C7 5E                  <1>         pop si
  9602                              <1> 
  9603 000034C8 B020                <1>         mov al, ' '
  9604 000034CA AA                  <1>         stosb
  9605 000034CB AA                  <1>         stosb
  9606                              <1> 
  9607 000034CC 58                  <1> 	pop ax
  9608                              <1> 
  9609                              <1> .no_flags:
  9610 000034CD 80FC01              <1> 	cmp ah, 1
  9611 000034D0 7729                <1> 	ja .no_number
  9612                              <1> 
  9613 000034D2 50                  <1> 	push ax
  9614                              <1> 
  9615 000034D3 8B5402              <1>         mov dx, [si + struc_bootrecord.drive_id]
  9616 000034D6 F7C30800            <1> 	test bx, INFOFLAG_ISSPECIAL
  9617 000034DA 740A                <1> 	jz .get_drvid
  9618                              <1> 
  9619 000034DC 56                  <1> 	push si
  9620 000034DD BE[9639]            <1> 	mov si, knl_strings.invalid_id
  9621 000034E0 E884F7              <1> 	call strcpy
  9622 000034E3 5E                  <1> 	pop si
  9623                              <1> 
  9624 000034E4 EB10                <1> 	jmp short .draw_type
  9625                              <1> 
  9626                              <1> .get_drvid:
  9627 000034E6 E8CA07              <1> 	call get_drvid_str
  9628                              <1> 
  9629 000034E9 88F0                <1>         mov al, dh                                  ; fill partition id
  9630 000034EB 30E4                <1> 	xor ah, ah
  9631 000034ED B103                <1>         mov cl, 3                                   ;
  9632 000034EF E8CEF6              <1>         call itoa                                   ;
  9633                              <1> 
  9634 000034F2 81C70300            <1>         add di, 3
  9635                              <1> 
  9636                              <1> .draw_type:
  9637 000034F6 B020                <1>         mov al, ' '
  9638 000034F8 AA                  <1>         stosb
  9639 000034F9 AA                  <1>         stosb
  9640                              <1> 
  9641 000034FA 58                  <1> 	pop ax
  9642                              <1> 
  9643                              <1> .no_number:
  9644 000034FB 80FC02              <1> 	cmp ah, 2
  9645 000034FE 771A                <1> 	ja .no_type
  9646                              <1> 
  9647 00003500 56                  <1>         push si                                     ; save the boot record pointer
  9648                              <1> 
  9649 00003501 30C0                <1> 	xor al, al
  9650 00003503 F7C30800            <1> 	test bx, INFOFLAG_ISSPECIAL
  9651 00003507 7503                <1> 	jnz .is_special
  9652 00003509 8A4404              <1>         mov al, [si + struc_bootrecord.type]
  9653                              <1> .is_special:
  9654                              <1> 
  9655 0000350C E846FC              <1>         call get_parttype_str
  9656 0000350F B90800              <1>         mov  cx, 8
  9657 00003512 E838F7              <1>         call strncpy
  9658 00003515 5E                  <1>         pop si
  9659                              <1>         
  9660 00003516 B020                <1>         mov al, ' '
  9661 00003518 AA                  <1>         stosb
  9662 00003519 AA                  <1>         stosb
  9663                              <1> 
  9664                              <1> .no_type:
  9665 0000351A 81C61600            <1>         add si, struc_bootrecord.name
  9666 0000351E B90F00              <1>         mov cx, 15
  9667 00003521 51                  <1> 	push cx
  9668 00003522 E828F7              <1>         call strncpy                                ; fill record name
  9669 00003525 89C8                <1> 	mov ax, cx
  9670 00003527 59                  <1> 	pop cx
  9671 00003528 29C1                <1> 	sub cx, ax
  9672 0000352A B020                <1> 	mov al, ' '
  9673 0000352C F3AA                <1> 	rep stosb
  9674 0000352E 30C0                <1> 	xor al, al
  9675 00003530 AA                  <1> 	stosb
  9676 00003531 61                  <1>         popa
  9677 00003532 C3                  <1>         ret
  9678                              <1> 
  9679                              <1> ;==============================================================================
  9680                              <1> ;mark_record_active ---- mark the boot record active.
  9681                              <1> ;input:
  9682                              <1> ;      ds:si -> the record
  9683                              <1> ;output:
  9684                              <1> ;      cf = 0 success
  9685                              <1> ;      cf = 1 failed, ax = 0 cannot mark active, otherwise disk error occured.
  9686                              <1> ;==============================================================================
  9687                              <1> mark_record_active:
  9688 00003533 60                  <1>         pusha
  9689 00003534 E8C903              <1>         call check_allow_act
  9690 00003537 725E                <1>         jc .cannot_active
  9691                              <1>         
  9692 00003539 B80102              <1>         mov ax, (INT13H_READ << 8 ) | 0x01                  ; read father's
  9693 0000353C 668B5C06            <1>         mov ebx, [si + struc_bootrecord.father_abs_addr]    ; partition table.
  9694 00003540 8A5402              <1>         mov dl, [si + struc_bootrecord.drive_id]            ;
  9695                              <1>                                                             ;
  9696 00003543 8D3E[741A]          <1>         lea di, [knl_tmp.disk_buf1]                                  ;
  9697 00003547 E82007              <1>         call disk_access                                    ;
  9698 0000354A 7250                <1>         jc .disk_error                                      ;
  9699                              <1> 
  9700 0000354C 52                  <1>         push dx
  9701 0000354D 6653                <1>         push ebx
  9702 0000354F 57                  <1>         push di
  9703                              <1>         
  9704 00003550 81C7BE01            <1>         add di, PART_TBL_OFF
  9705                              <1> 
  9706 00003554 668B4C0A            <1>         mov ecx, [si + struc_bootrecord.abs_addr]    ; abs addr -> ecx
  9707                              <1> 
  9708 00003558 6629D9              <1>         sub ecx, ebx                                 ; relative addr -> ebx
  9709 0000355B 6689CB              <1> 	mov ebx, ecx
  9710 0000355E B90400              <1>         mov cx, 4
  9711                              <1> 
  9712 00003561 F7040020            <1>         test word [si + struc_bootrecord.flags], INFOFLAG_SWAPDRVID  ; check if need swap id
  9713 00003565 7403                <1>         jz .no_swapid
  9714                              <1> 
  9715 00003567 80E2F0              <1>         and dl, 0xF0                                 ; use 0x80 as active flag if swap id is on.
  9716                              <1> .no_swapid:
  9717                              <1> 
  9718 0000356A 30E4                <1>         xor ah, ah
  9719                              <1> .search_in_father:                                   ;
  9720 0000356C 30C0                <1>         xor al, al                                   ;
  9721 0000356E 66395D08            <1>         cmp [di + struc_partition.relative_addr], ebx; find the record in
  9722 00003572 7504                <1>         jne .not_it                                  ; father's partition
  9723 00003574 88D0                <1>         mov al, dl                                   ; table
  9724 00003576 FEC4                <1>         inc ah                                       ;
  9725                              <1> .not_it:                                             ;
  9726 00003578 8805                <1>         mov byte [di  + struc_partition.state], al   ;
  9727 0000357A 81C71000            <1>         add di, SIZE_OF_PARTITION                    ;
  9728 0000357E E2EC                <1>         loop .search_in_father                       ;
  9729                              <1> 
  9730 00003580 5F                  <1>         pop di                                       ;
  9731 00003581 665B                <1>         pop ebx                                       ;
  9732 00003583 5A                  <1>         pop dx
  9733                              <1> 
  9734 00003584 08E4                <1>         or ah, ah
  9735 00003586 740F                <1>         jz .cannot_active                            ; can not found the partition record
  9736                              <1>         
  9737 00003588 B80103              <1>         mov ax , (INT13H_WRITE << 8 ) | 0x01         ; write the partition
  9738 0000358B E8DC06              <1>         call disk_access                             ; table back.
  9739 0000358E 720C                <1>         jc .disk_error
  9740                              <1> 
  9741 00003590 810C0008            <1>         or word [si + struc_bootrecord.flags], INFOFLAG_ACTIVE ; set active flag
  9742 00003594 61                  <1>         popa
  9743 00003595 F8                  <1>         clc
  9744 00003596 C3                  <1>         ret
  9745                              <1>         
  9746                              <1> .cannot_active:
  9747 00003597 61                  <1>         popa
  9748 00003598 31C0                <1>         xor ax, ax
  9749 0000359A F9                  <1>         stc
  9750 0000359B C3                  <1>         ret
  9751                              <1> .disk_error:
  9752 0000359C 61                  <1>         popa
  9753 0000359D C3                  <1>         ret
  9754                              <1> 
  9755                              <1> 
  9756                              <1> 
  9757                              <1> ;==============================================================================
  9758                              <1> ;toggle_record_hidden ---- toggle a boot record's hidden attribute
  9759                              <1> ;input:
  9760                              <1> ;      ds:si -> the record
  9761                              <1> ;output:
  9762                              <1> ;      cf = 0 success
  9763                              <1> ;      cf = 1 failed, ax = 0 cannot hide, otherwise disk error occured.
  9764                              <1> ;==============================================================================
  9765                              <1> toggle_record_hidden:
  9766 0000359E 60                  <1>         pusha
  9767                              <1>         
  9768 0000359F E83B03              <1>         call check_allow_hide
  9769 000035A2 7260                <1>         jc .cannot_hide
  9770                              <1>         
  9771 000035A4 B80102              <1>         mov ax, (INT13H_READ << 8 ) | 0x01                  ; read father's
  9772 000035A7 668B5C06            <1>         mov ebx, [si + struc_bootrecord.father_abs_addr]    ; partition table.
  9773 000035AB 8A5402              <1>         mov dl, [si + struc_bootrecord.drive_id]            ;
  9774                              <1>                                                             ;
  9775 000035AE 8D3E[741A]          <1>         lea di, [knl_tmp.disk_buf1]                                  ;
  9776 000035B2 E8B506              <1>         call disk_access                                    ;
  9777 000035B5 7252                <1>         jc .disk_error                                      ;
  9778                              <1> 
  9779 000035B7 6653                <1>         push ebx
  9780 000035B9 57                  <1>         push di
  9781                              <1>         
  9782 000035BA 81C7BE01            <1>         add di, PART_TBL_OFF
  9783                              <1> 
  9784 000035BE 668B4C0A            <1>         mov ecx, [si + struc_bootrecord.abs_addr]    ; abs addr -> ebx
  9785                              <1> 
  9786 000035C2 6629D9              <1>         sub ecx, ebx                                 ; relative addr -> ebx
  9787 000035C5 6689CB              <1> 	mov ebx, ecx
  9788                              <1> 
  9789 000035C8 B90400              <1>         mov cx, 4
  9790                              <1> 
  9791 000035CB 8B04                <1>         mov ax, [si + struc_bootrecord.flags]        ; get flags and type
  9792 000035CD 8A7404              <1>         mov dh, [si + struc_bootrecord.type]
  9793 000035D0 80E60F              <1>         and dh, 0x0F
  9794 000035D3 A90002              <1>         test ax, INFOFLAG_HIDDEN
  9795 000035D6 7503                <1>         jnz .unhide_it
  9796 000035D8 80CE10              <1>         or dh, 0x10                                  ; hide the partition
  9797                              <1> 
  9798                              <1> .unhide_it:
  9799 000035DB 30C0                <1>         xor al, al
  9800                              <1>         
  9801                              <1> .search_in_father:                                   ;
  9802 000035DD 66395D08            <1>         cmp [di + struc_partition.relative_addr], ebx; find the record in
  9803 000035E1 7505                <1>         jne .not_it                                  ; father's partition
  9804 000035E3 FEC0                <1>         inc al
  9805 000035E5 887504              <1>         mov byte [di  + struc_partition.type], dh    ; set partition type.
  9806                              <1> .not_it:                                             ;
  9807 000035E8 81C71000            <1>         add di, SIZE_OF_PARTITION                    ;
  9808 000035EC E2EF                <1>         loop .search_in_father                       ;
  9809                              <1> 
  9810 000035EE 5F                  <1>         pop di                                       ;
  9811 000035EF 665B                <1>         pop ebx                                      ;
  9812                              <1> 
  9813 000035F1 08C0                <1>         or al, al
  9814 000035F3 740F                <1>         jz .cannot_hide                              ; can not found the partition record
  9815                              <1>         
  9816 000035F5 B80103              <1>         mov ax , (INT13H_WRITE << 8 ) | 0x01         ; write the partition
  9817 000035F8 E86F06              <1>         call disk_access                             ; table back.
  9818 000035FB 720C                <1>         jc .disk_error
  9819                              <1> 
  9820 000035FD 81340002            <1>         xor word [si + struc_bootrecord.flags], INFOFLAG_HIDDEN ; toggle hidden flag.
  9821 00003601 61                  <1>         popa
  9822 00003602 F8                  <1>         clc
  9823 00003603 C3                  <1>         ret
  9824                              <1>         
  9825                              <1> .cannot_hide:
  9826 00003604 61                  <1>         popa
  9827 00003605 31C0                <1>         xor ax, ax
  9828 00003607 F9                  <1>         stc
  9829 00003608 C3                  <1>         ret
  9830                              <1> .disk_error:
  9831 00003609 61                  <1>         popa
  9832 0000360A C3                  <1>         ret
  9833                              <1> 
  9834                              <1> ;==============================================================================
  9835                              <1> ;set_record_schedule ---- set the record's schedule time
  9836                              <1> ;input:
  9837                              <1> ;      ds:si -> the record
  9838                              <1> ;      ax = begin time (in minutes)
  9839                              <1> ;      bx = end time (in minutes)
  9840                              <1> ;      dx = week info (bit 0 to bit 6 indicate Mon to Sun, zero means all days)
  9841                              <1> ;output:
  9842                              <1> ;      none
  9843                              <1> ;==============================================================================
  9844                              <1> set_record_schedule:
  9845 0000360B 60                  <1>        pusha
  9846 0000360C 09C0                <1>        or ax, ax
  9847 0000360E 750E                <1>        jnz .timeok
  9848 00003610 09DB                <1>        or bx, bx
  9849 00003612 750A                <1>        jnz .timeok
  9850 00003614 09D2                <1>        or dx, dx
  9851 00003616 7506                <1>        jnz .timeok
  9852                              <1> 
  9853 00003618 8124FF7F            <1>        and word [si + struc_bootrecord.flags], ~ INFOFLAG_SCHEDULED
  9854 0000361C 61                  <1>        popa
  9855 0000361D C3                  <1>        ret
  9856                              <1> 
  9857                              <1> .timeok:
  9858 0000361E 6681E3FF0F0000      <1>        and ebx, 0x00000fff
  9859 00003625 6625FF0F0000        <1>        and eax, 0x00000fff
  9860 0000362B 66C1E30C            <1>        shl ebx, 12
  9861 0000362F 6609D8              <1>        or  eax, ebx
  9862 00003632 6681E2FF000000      <1>        and edx, 0x000000ff
  9863 00003639 66C1E218            <1>        shl edx, 24
  9864 0000363D 6609D0              <1>        or  eax, edx
  9865                              <1> 
  9866 00003640 66894412            <1>        mov [si + struc_bootrecord.schedule_time], eax
  9867 00003644 810C0080            <1>        or word [si + struc_bootrecord.flags], INFOFLAG_SCHEDULED
  9868                              <1> 
  9869 00003648 61                  <1>        popa
  9870 00003649 C3                  <1>        ret
  9871                              <1> 
  9872                              <1> ;==============================================================================
  9873                              <1> ;get_record_schedule ---- set the record's schedule time
  9874                              <1> ;input:
  9875                              <1> ;      ds:si -> the record
  9876                              <1> ;output:
  9877                              <1> ;      ax = begin time (in minutes)
  9878                              <1> ;      bx = end time (in minutes)
  9879                              <1> ;      dx = week info (bit 0 to bit 6 indicate Mon to Sun, zero means all days)
  9880                              <1> ;==============================================================================
  9881                              <1> get_record_schedule:
  9882 0000364A 31C0                <1>        xor ax, ax
  9883 0000364C 31DB                <1>        xor bx, bx
  9884 0000364E 31D2                <1>        xor dx, dx
  9885                              <1> 
  9886 00003650 F7040080            <1>        test word [si + struc_bootrecord.flags], INFOFLAG_SCHEDULED
  9887 00003654 741D                <1>        jz .end
  9888                              <1> 
  9889 00003656 668B4412            <1>        mov eax, [si + struc_bootrecord.schedule_time]
  9890 0000365A 6689C3              <1>        mov ebx, eax
  9891 0000365D 6689C2              <1>        mov edx, eax
  9892                              <1> 
  9893 00003660 25FF0F              <1>        and ax, 0x0fff
  9894 00003663 66C1EB0C            <1>        shr ebx, 12
  9895 00003667 81E3FF0F            <1>        and bx, 0x0fff
  9896 0000366B 66C1EA18            <1>        shr edx, 24
  9897 0000366F 81E2FF00            <1>        and dx, 0x00ff
  9898                              <1> 
  9899                              <1> .end:
  9900 00003673 C3                  <1>        ret
  9901                              <1> 
  9902                              <1> ;=============================================================================
  9903                              <1> ;schedule_to_str ---- convert schedule time to string
  9904                              <1> ;input:
  9905                              <1> ;       ax = start time
  9906                              <1> ;       bx = stop time
  9907                              <1> ;       dx = days info
  9908                              <1> ;       es:di -> buffer
  9909                              <1> ;output:
  9910                              <1> ;       none
  9911                              <1> ;=============================================================================
  9912                              <1> schedule_to_str:
  9913 00003674 60                  <1>         pusha
  9914 00003675 FC                  <1>         cld
  9915 00003676 E83700              <1>         call sch_time_to_str
  9916 00003679 89FE                <1>         mov si, di
  9917 0000367B E890F5              <1>         call strlen
  9918 0000367E 01CF                <1>         add di, cx
  9919 00003680 B02D                <1>         mov al, '-'
  9920 00003682 AA                  <1>         stosb
  9921 00003683 89D8                <1>         mov ax, bx
  9922 00003685 E82800              <1>         call sch_time_to_str
  9923 00003688 89FE                <1>         mov si, di
  9924 0000368A E881F5              <1>         call strlen
  9925 0000368D 01CF                <1>         add di, cx
  9926 0000368F B03B                <1>         mov al, ';'
  9927 00003691 AA                  <1>         stosb
  9928 00003692 E80200              <1>         call sch_days_to_str
  9929 00003695 61                  <1>         popa
  9930 00003696 C3                  <1>         ret
  9931                              <1> 
  9932                              <1> ;=============================================================================
  9933                              <1> ;sch_days_to_str ---- convert days info string 0123456
  9934                              <1> ;input:
  9935                              <1> ;       dx = day bits
  9936                              <1> ;       es:di -> buffer
  9937                              <1> ;output:
  9938                              <1> ;       none
  9939                              <1> ;=============================================================================
  9940                              <1> sch_days_to_str:
  9941 00003697 60                  <1>         pusha
  9942 00003698 B90700              <1>         mov cx, 7
  9943 0000369B B030                <1>         mov al, '0'
  9944 0000369D BB0100              <1>         mov bx, 1
  9945                              <1> 
  9946                              <1> .loop_chk:
  9947 000036A0 85DA                <1>         test dx, bx
  9948 000036A2 7401                <1>         jz .nothisday
  9949 000036A4 AA                  <1>         stosb
  9950                              <1> .nothisday:
  9951 000036A5 D1E3                <1>         shl bx, 1
  9952 000036A7 FEC0                <1>         inc al
  9953 000036A9 E2F5                <1>         loop .loop_chk
  9954                              <1> 
  9955 000036AB 30C0                <1>         xor al, al
  9956 000036AD AA                  <1>         stosb
  9957                              <1> 
  9958 000036AE 61                  <1>         popa
  9959 000036AF C3                  <1>         ret
  9960                              <1> 
  9961                              <1> ;=============================================================================
  9962                              <1> ;sch_time_to_str ---- convert time in minute info string hh:mm
  9963                              <1> ;input:
  9964                              <1> ;       ax = time
  9965                              <1> ;       es:di -> buffer
  9966                              <1> ;output:
  9967                              <1> ;       none
  9968                              <1> ;=============================================================================
  9969                              <1> sch_time_to_str:
  9970 000036B0 60                  <1>         pusha
  9971                              <1> 
  9972 000036B1 B23C                <1>         mov dl, 60
  9973 000036B3 F6F2                <1>         div dl
  9974 000036B5 50                  <1>         push ax
  9975                              <1> 
  9976 000036B6 30E4                <1>         xor ah, ah
  9977 000036B8 3C0A                <1>         cmp al, 10
  9978 000036BA 7205                <1>         jb .hlten
  9979 000036BC B90200              <1>         mov cx, 2
  9980 000036BF EB03                <1>         jmp short .showh
  9981                              <1> .hlten:
  9982 000036C1 B90100              <1>         mov cx,1
  9983                              <1> .showh:
  9984 000036C4 E8F9F4              <1>         call itoa
  9985                              <1> 
  9986 000036C7 B03A                <1>         mov al,':'
  9987 000036C9 01CF                <1>         add di, cx
  9988 000036CB AA                  <1>         stosb
  9989                              <1> 
  9990 000036CC 58                  <1>         pop ax
  9991 000036CD 0FB6C4              <1>         movzx ax, ah
  9992 000036D0 3C0A                <1>         cmp al, 10
  9993 000036D2 7205                <1>         jb .mlten
  9994 000036D4 B90200              <1>         mov cx, 2
  9995 000036D7 EB03                <1>         jmp short .showm
  9996                              <1> .mlten:
  9997 000036D9 B90100              <1>         mov cx,1
  9998                              <1> .showm:
  9999 000036DC E8E1F4              <1>         call itoa
 10000                              <1> 
 10001 000036DF 61                  <1>         popa
 10002 000036E0 C3                  <1>         ret
 10003                              <1> 
 10004                              <1> ;==============================================================================
 10005                              <1> ;boot_normal_record ---- boot a normal record
 10006                              <1> ;input:
 10007                              <1> ;      ds:si -> the record
 10008                              <1> ;output:
 10009                              <1> ;      will not return when successfully boot.
 10010                              <1> ;      if return then al != 0 disk error; al = 0 no operation system.
 10011                              <1> ;==============================================================================
 10012                              <1> boot_normal_record:
 10013 000036E1 06                  <1>         push es
 10014                              <1> 
 10015 000036E2 8B1C                <1>         mov bx, [si + struc_bootrecord.flags]
 10016 000036E4 F7C30010            <1>         test bx, INFOFLAG_AUTOACTIVE
 10017 000036E8 7403                <1>         jz .no_need_act
 10018 000036EA E846FE              <1>         call mark_record_active             ; active the partition
 10019                              <1> 
 10020                              <1> .no_need_act:
 10021 000036ED F7C30002            <1>         test bx, INFOFLAG_HIDDEN
 10022 000036F1 7403                <1>         jz .not_hidden
 10023 000036F3 E8A8FE              <1>         call toggle_record_hidden           ; unhide the partition
 10024                              <1> 
 10025                              <1> .not_hidden:
 10026                              <1> 
 10027 000036F6 53                  <1>         push bx                             ; save the flags
 10028 000036F7 8D3E[741A]          <1>         lea di, [knl_tmp.disk_buf1]         ; load boot sector into knl_tmp.disk_buf1.
 10029 000036FB B80102              <1>         mov ax, (INT13H_READ << 8 ) | 0x01
 10030 000036FE 8A5402              <1>         mov dl, [si + struc_bootrecord.drive_id]
 10031 00003701 668B5C0A            <1>         mov ebx, [si + struc_bootrecord.abs_addr]
 10032                              <1> 
 10033 00003705 E86205              <1>         call disk_access                    ; read the first sector of the
 10034                              <1>                                             ; partition / floppy into
 10035                              <1>                                             ; memory.
 10036 00003708 5B                  <1>         pop bx
 10037 00003709 0F829200            <1>         jmpc .disk_error
 10038                              <1> 
 10039 0000370D 81BDFE0155AA        <1>         cmp word [di + BR_FLAG_OFF], BR_GOOD_FLAG
 10040 00003713 0F858600            <1>         jmpne .no_system
 10041                              <1> 
 10042 00003717 F7C38000            <1>         test bx, INFOFLAG_ISDRIVER          ; if it's driver, skip loading the
 10043                              <1>                                             ; partition table.
 10044 0000371B 7517                <1>         jnz .do_boot
 10045                              <1> 
 10046 0000371D 53                  <1>         push bx                             ; save the flags 
 10047 0000371E 8D3E[7422]          <1>         lea di, [knl_tmp.disk_buf2]    ; load part table into knl_tmp.disk_buf2
 10048                              <1> 
 10049 00003722 668B5C06            <1>         mov ebx, [si + struc_bootrecord.father_abs_addr]
 10050                              <1> 
 10051 00003726 E84105              <1>         call disk_access                    ; load part table into memory.
 10052 00003729 5B                  <1>         pop bx
 10053 0000372A 7273                <1>         jc .disk_error
 10054                              <1> 
 10055 0000372C 81BDFE0155AA        <1>         cmp word [di + BR_FLAG_OFF], BR_GOOD_FLAG
 10056 00003732 7569                <1>         jne .no_system                      ; bad partition table, treated as
 10057                              <1>                                             ; no operating system.
 10058                              <1> 
 10059                              <1> .do_boot:
 10060                              <1> %ifndef EMULATE_PROG
 10061                              <1> 
 10062 00003734 F7C30020            <1>         test bx, INFOFLAG_SWAPDRVID         ; check if need swap id
 10063 00003738 7413                <1>         jz .no_swapid
 10064                              <1> 
 10065                              <1> ;================ swap the driver id ========================================
 10066 0000373A 88D6                <1>         mov dh, dl
 10067 0000373C 80E680              <1>         and dh, 0x80                        ; set driver id to the bootable id
 10068                              <1> 
 10069 0000373F 89D3                <1> 	mov bx, dx
 10070 00003741 86F2                <1> 	xchg dh, dl
 10071 00003743 89D1                <1> 	mov cx, dx
 10072                              <1> 
 10073 00003745 E80606              <1> 	call set_drive_map
 10074                              <1> 
 10075 00003748 885402              <1>         mov [si + struc_bootrecord.drive_id], dl  ; write new driver id back
 10076 0000374B EB03                <1> 	jmp short .swap_ok
 10077                              <1> 
 10078                              <1> .no_swapid:
 10079 0000374D E8E105              <1> 	call uninstall_myint13h
 10080                              <1> 
 10081                              <1> .swap_ok:
 10082 00003750 E80C01              <1>         call prepare_boot                   ; prepare to boot.
 10083 00003753 7248                <1>         jc .no_system                       ; preparation failed.
 10084                              <1>         
 10085                              <1> %endif
 10086 00003755 E8E200              <1>         call preload_keystrokes     ; preload the keystrokes into key buffer.
 10087 00003758 E85EE9              <1>         call reset_video_mode
 10088                              <1> 
 10089                              <1> %ifndef EMULATE_PROG
 10090                              <1> 
 10091 0000375B 56                  <1>         push si
 10092 0000375C FC                  <1>         cld
 10093                              <1> 
 10094 0000375D 31C0                <1>         xor ax, ax
 10095 0000375F 50                  <1>         push ax
 10096 00003760 07                  <1>         pop es
 10097 00003761 B90002              <1>         mov cx, SECTOR_SIZE
 10098                              <1> 
 10099 00003764 F7048000            <1>         test word [si + struc_bootrecord.flags], INFOFLAG_ISDRIVER
 10100                              <1>                                             ; if it's driver, no partition
 10101 00003768 750B                <1>         jnz .boot_driver                    ; table to load.
 10102                              <1>         
 10103 0000376A 8D36[7422]          <1>         lea si, [knl_tmp.disk_buf2]
 10104 0000376E BF0006              <1>         mov di, PART_OFF
 10105                              <1> 
 10106 00003771 51                  <1>         push cx
 10107 00003772 F3A4                <1>         rep movsb                           ; move mbr (partition table) to
 10108                              <1>                                             ; 0000:0600
 10109 00003774 59                  <1>         pop cx
 10110                              <1>         
 10111                              <1> .boot_driver:
 10112 00003775 8D36[741A]          <1>         lea si, [knl_tmp.disk_buf1]
 10113 00003779 BF007C              <1>         mov di, BOOT_OFF
 10114 0000377C F3A4                <1>         rep movsb                           ; move boot sector to 0000:7C00
 10115                              <1> 
 10116 0000377E 5E                  <1>         pop si
 10117                              <1> 
 10118 0000377F 8A5402              <1>         mov dl, [si + struc_bootrecord.drive_id] ; drive id -> dl
 10119 00003782 30F6                <1>         xor dh, dh
 10120                              <1> 
 10121                              <1> ; boot code from lilo :-)
 10122                              <1> 
 10123 00003784 89DE                <1>         mov si, bx                          ; ds:si , es:di point to the
 10124 00003786 81C6BE07            <1>         add si, PART_OFF + PART_TBL_OFF     ; partition record.
 10125 0000378A 56                  <1>         push si                             ;
 10126 0000378B 5F                  <1>         pop di                              ;
 10127                              <1> 
 10128 0000378C 50                  <1>         push ax                             ; ds = 0 ( es already set to 0 ).
 10129 0000378D 1F                  <1>         pop ds                              ;
 10130                              <1>         
 10131                              <1> %if 0
 10132                              <1>         xor bp, bp                          ; might help some boot problems
 10133                              <1>         mov ax, BR_GOOD_FLAG                ; boot signature (just in case ...)
 10134                              <1>         jmp 0:BOOT_OFF                      ; start boot sector
 10135                              <1> %else
 10136                              <1> ;boot code from the OS2 Boot Manager
 10137 0000378E BB007C              <1>         mov bx, BOOT_OFF
 10138                              <1>     
 10139 00003791 8ED0                <1>         mov ss,ax                           ; on all processors since the 186
 10140 00003793 89DC                <1>         mov sp,bx                           ; these instructions are locked
 10141                              <1>     
 10142 00003795 89F5                <1>         mov bp, si
 10143 00003797 50                  <1>         push    ax
 10144 00003798 53                  <1>         push    bx
 10145 00003799 B855AA              <1>         mov ax, BR_GOOD_FLAG
 10146 0000379C CB                  <1>         retf                                ; start boot sector
 10147                              <1> %endif
 10148                              <1>         
 10149                              <1> %else
 10150                              <1> 	call uninstall_myint13h
 10151                              <1>         mov ax, 0x4c00                      ; return to dos.
 10152                              <1>         int 0x21                            ;
 10153                              <1> %endif
 10154                              <1> 
 10155                              <1> .no_system:
 10156 0000379D 30C0                <1>         xor al, al
 10157                              <1> .disk_error:
 10158 0000379F 07                  <1>         pop es
 10159 000037A0 C3                  <1>         ret
 10160                              <1> 
 10161                              <1> %ifndef DISABLE_CDBOOT
 10162                              <1> ;==============================================================================
 10163                              <1> ; boot_cdrom ---- boot cdrom driver
 10164                              <1> ; input: ds:di -> boot catalog
 10165                              <1> ;        dl = cdrom drvid
 10166                              <1> ;==============================================================================
 10167                              <1> boot_cdrom:
 10168 000037A1 8A4501              <1> 	mov al, [di+1]
 10169 000037A4 240F                <1> 	and al, 0x0f
 10170                              <1> 
 10171 000037A6 BE[611A]            <1> 	mov si, knl_tmp.cdemu_spec
 10172 000037A9 C60413              <1> 	mov byte [si], SIZE_OF_CDEMU_SPEC
 10173 000037AC 884401              <1> 	mov [si + struc_cdemu_spec.media_type], al
 10174                              <1> 
 10175 000037AF 30E4                <1> 	xor ah, ah
 10176 000037B1 08C0                <1> 	or al, al
 10177 000037B3 7502                <1> 	jnz .floppy_emu
 10178 000037B5 88D4                <1> 	mov ah, dl
 10179                              <1> .floppy_emu: 
 10180                              <1> 
 10181 000037B7 886402              <1> 	mov byte [si + struc_cdemu_spec.emu_drvid], ah
 10182 000037BA 668B5D08            <1> 	mov ebx, [di+0x08]
 10183 000037BE 66895C04            <1> 	mov [si + struc_cdemu_spec.image_lba], ebx
 10184 000037C2 8B5D02              <1> 	mov bx, [di+0x02]
 10185 000037C5 895C0C              <1> 	mov [si + struc_cdemu_spec.load_seg], bx
 10186 000037C8 8B5D06              <1> 	mov bx, [di+0x06]
 10187 000037CB 895C0E              <1> 	mov [si + struc_cdemu_spec.sect_count], bx
 10188 000037CE C6441050            <1> 	mov byte [si + struc_cdemu_spec.cylinders], 0x50
 10189 000037D2 C6441202            <1> 	mov byte [si + struc_cdemu_spec.heads], 2
 10190                              <1> 
 10191 000037D6 88C3                <1> 	mov bl, al
 10192 000037D8 30FF                <1> 	xor bh, bh
 10193 000037DA 8AA7[FC37]          <1> 	mov ah, [.sect_nums + bx]
 10194                              <1> 
 10195 000037DE 886411              <1> 	mov byte [si + struc_cdemu_spec.sectors], ah
 10196 000037E1 31C0                <1> 	xor ax, ax
 10197 000037E3 89440A              <1> 	mov [si + struc_cdemu_spec.user_bufseg], ax
 10198                              <1> 
 10199                              <1> ;Boot it!
 10200 000037E6 B8004A              <1> 	mov ax, 0x4a00
 10201 000037E9 CD13                <1> 	int 0x13
 10202 000037EB 8826[581A]          <1> 	mov [hdio_tmp.disk_errno],ah
 10203 000037EF 720A                <1> 	jc .end
 10204                              <1> 
 10205                              <1> ;If the cd-rom is accessed via BIOS, then uninstall my int13h.
 10206 000037F1 E83D05              <1> 	call uninstall_myint13h
 10207                              <1> 
 10208 000037F4 B8004C              <1> 	mov ax, 0x4c00
 10209 000037F7 CD13                <1> 	int 0x13
 10210 000037F9 31C0                <1> 	xor ax, ax
 10211                              <1> .end:
 10212 000037FB C3                  <1> 	ret
 10213                              <1> 
 10214 000037FC 000F1224            <1> .sect_nums  db  0, 0x0f, 0x12, 0x24
 10215                              <1> 
 10216                              <1> 
 10217                              <1> ;==============================================================================
 10218                              <1> ;find_cdboot_catalog ---- find boot catalog entry from buffer
 10219                              <1> ;input: ds:si -> buffer  es:di -> entries buffer
 10220                              <1> ;return: cx = number of entries
 10221                              <1> ;==============================================================================
 10222                              <1> find_cdboot_catalog:
 10223 00003800 56                  <1> 	push si
 10224 00003801 57                  <1> 	push di
 10225 00003802 50                  <1> 	push ax
 10226 00003803 FC                  <1> 	cld
 10227                              <1> 
 10228 00003804 31C9                <1> 	xor cx, cx
 10229                              <1> 
 10230 00003806 813C0100            <1> 	cmp word [si], 0x0001
 10231 0000380A 752A                <1> 	jne .end
 10232 0000380C 817C1E55AA          <1> 	cmp word [si+0x1e], 0xaa55
 10233 00003811 7523                <1> 	jne .end
 10234                              <1> 
 10235                              <1> .loop_find:
 10236 00003813 8A04                <1> 	mov al, [si + struc_boot_catalog.indicator]
 10237 00003815 08C0                <1> 	or al, al
 10238 00003817 741D                <1> 	jz .end
 10239                              <1> 
 10240 00003819 3C88                <1> 	cmp al, 0x88
 10241 0000381B 7513                <1> 	jne .loop_next
 10242                              <1> 
 10243 0000381D 8A4401              <1> 	mov al, [si + struc_boot_catalog.media_type]
 10244 00003820 240F                <1> 	and al, 0x0f
 10245 00003822 3C04                <1> 	cmp al , 4
 10246 00003824 730A                <1> 	jae .loop_next
 10247                              <1> 
 10248 00003826 51                  <1> 	push cx
 10249 00003827 56                  <1> 	push si
 10250 00003828 B92000              <1> 	mov cx, SIZE_OF_BOOT_CATALOG
 10251 0000382B F3A4                <1> 	rep movsb
 10252 0000382D 5E                  <1> 	pop si
 10253 0000382E 59                  <1> 	pop cx
 10254 0000382F 41                  <1> 	inc cx
 10255                              <1> 
 10256                              <1> .loop_next:
 10257 00003830 81C62000            <1> 	add si, SIZE_OF_BOOT_CATALOG
 10258 00003834 EBDD                <1> 	jmp short .loop_find
 10259                              <1> 
 10260                              <1> .end:
 10261 00003836 58                  <1> 	pop ax
 10262 00003837 5F                  <1> 	pop di
 10263 00003838 5E                  <1> 	pop si
 10264 00003839 C3                  <1> 	ret
 10265                              <1> 
 10266                              <1> %endif
 10267                              <1> 
 10268                              <1> ;==============================================================================
 10269                              <1> ;preload_keystrokes ---- preload the keystrokes into key buffer.
 10270                              <1> ;input:
 10271                              <1> ;      ds:si -> boot record
 10272                              <1> ;output:
 10273                              <1> ;      none
 10274                              <1> ;==============================================================================
 10275                              <1> preload_keystrokes:
 10276 0000383A 60                  <1>         pusha
 10277 0000383B FC                  <1>         cld
 10278 0000383C F7040040            <1>         test word [si + struc_bootrecord.flags], INFOFLAG_HAVEKEYS
 10279 00003840 741B                <1>         jz .end
 10280                              <1> 
 10281 00003842 B90D00              <1>         mov cx, MAX_KEYSTROKES
 10282 00003845 81C62600            <1>         add si, struc_bootrecord.keystrokes
 10283                              <1> 
 10284                              <1> .loop_load:
 10285 00003849 AD                  <1>         lodsw
 10286 0000384A 09C0                <1>         or ax, ax
 10287 0000384C 740F                <1>         jz .end
 10288                              <1> 
 10289 0000384E 51                  <1>         push cx
 10290 0000384F 89C1                <1>         mov cx, ax
 10291 00003851 B405                <1>         mov ah, 0x05
 10292 00003853 E8EEF5              <1>         call bioskey
 10293 00003856 59                  <1>         pop cx
 10294 00003857 08C0                <1>         or al, al
 10295 00003859 7502                <1>         jnz .end
 10296 0000385B E2EC                <1>         loop .loop_load
 10297                              <1> .end:
 10298 0000385D 61                  <1>         popa
 10299 0000385E C3                  <1>         ret
 10300                              <1> 
 10301                              <1> ;==============================================================================
 10302                              <1> ;prepare_boot ---- do some preparation before booting.
 10303                              <1> ;input:
 10304                              <1> ;      ds:si -> boot record
 10305                              <1> ;      knl_tmp.disk_buf1  -> boot sector
 10306                              <1> ;      knl_tmp.disk_buf2 -> father's first sector ( partition table ).
 10307                              <1> ;output:
 10308                              <1> ;      cf = 0 success
 10309                              <1> ;          bx = the partition record's offset in partition table.
 10310                              <1> ;      cf = 1 failed
 10311                              <1> ;==============================================================================
 10312                              <1> prepare_boot:
 10313 0000385F 31C0                <1>         xor ax, ax
 10314 00003861 F7048000            <1>         test word [si + struc_bootrecord.flags], INFOFLAG_ISDRIVER
 10315 00003865 0F857000            <1>         jmpnz .end
 10316                              <1> 
 10317 00003869 668B5C0A            <1>         mov ebx, [si + struc_bootrecord.abs_addr]         ;
 10318                              <1> 
 10319 0000386D 668B4C06            <1>         mov ecx, [si + struc_bootrecord.father_abs_addr]  ;
 10320                              <1> 
 10321 00003871 6689D8              <1>         mov eax, ebx
 10322 00003874 6629C8              <1>         sub eax, ecx                                      ; relative addr -> eax
 10323                              <1> 
 10324 00003877 8D3E[3224]          <1>         lea di, [knl_tmp.disk_buf2 + PART_TBL_OFF]
 10325 0000387B 30C9                <1>         xor cl, cl
 10326                              <1>         
 10327                              <1> .search_in_father:
 10328 0000387D 66394508            <1>         cmp [di + struc_partition.relative_addr], eax
 10329 00003881 740D                <1>         je .found
 10330 00003883 FEC1                <1>         inc cl
 10331 00003885 81C71000            <1>         add di, SIZE_OF_PARTITION
 10332 00003889 80F904              <1>         cmp cl, 4
 10333 0000388C 72EF                <1>         jb .search_in_father
 10334 0000388E EB49                <1>         jmp short .failed
 10335                              <1> 
 10336                              <1> .found:
 10337 00003890 B010                <1>         mov al, SIZE_OF_PARTITION                   ; ax = offset in partition
 10338 00003892 F6E1                <1>         mul cl                                      ; table.
 10339                              <1> 
 10340 00003894 8A5402              <1>         mov dl, [si + struc_bootrecord.drive_id]
 10341 00003897 8815                <1>         mov [di + struc_partition.state], dl        ; store drive id into
 10342                              <1>                                                     ; partition record
 10343                              <1> 
 10344 00003899 8D3E[741A]          <1>         lea di, [knl_tmp.disk_buf1]                          ; di -> boot record
 10345 0000389D 8A7404              <1>         mov dh, [si + struc_bootrecord.type]
 10346                              <1> 
 10347 000038A0 80FE04              <1>         cmp dh, 0x04
 10348 000038A3 7416                <1>         je .fat16
 10349 000038A5 80FE06              <1>         cmp dh, 0x06
 10350 000038A8 7411                <1>         je .fat16
 10351 000038AA 80FE0E              <1>         cmp dh, 0x0e
 10352 000038AD 740C                <1>         je .fat16
 10353 000038AF 80FE0B              <1>         cmp dh, 0x0b
 10354 000038B2 7416                <1>         je .fat32
 10355 000038B4 80FE0C              <1>         cmp dh, 0x0c
 10356 000038B7 7411                <1>         je .fat32
 10357 000038B9 EB1E                <1>         jmp short .end
 10358                              <1> .fat16:
 10359 000038BB 807D2629            <1>         cmp byte [di + FAT16_EXTBRID_OFF], EXTBRID
 10360 000038BF 7518                <1>         jne .end
 10361                              <1>         
 10362 000038C1 885524              <1>         mov [di + FAT16_DRVID_OFF], dl              ; update the drive id.
 10363 000038C4 66895D1C            <1>         mov [di + FAT16_HIDSEC_OFF], ebx            ; update hidden sector
 10364                              <1>                                                     ; = abs_addr.
 10365 000038C8 EB0F                <1>         jmp short .end
 10366                              <1> .fat32:
 10367 000038CA 807D4229            <1>         cmp byte [di + FAT32_EXTBRID_OFF], EXTBRID
 10368 000038CE 7509                <1>         jne .end
 10369                              <1>         
 10370 000038D0 885540              <1>         mov [di + FAT32_DRVID_OFF], dl              ; update the drive id.
 10371 000038D3 66895D1C            <1>         mov [di + FAT32_HIDSEC_OFF], ebx            ; update hidden sector
 10372                              <1>                                                     ; = abs_addr.
 10373 000038D7 EB00                <1>         jmp short .end
 10374                              <1>         
 10375                              <1> .failed:
 10376                              <1> ;        stc
 10377                              <1> ;        ret
 10378                              <1> .end:
 10379 000038D9 89C3                <1>         mov bx, ax          ; partition record's offset store to bx.
 10380 000038DB F8                  <1>         clc
 10381 000038DC C3                  <1>         ret
 10382                              <1> 
 10383                              <1> ;==============================================================================
 10384                              <1> ;check_allow_hide ---- check if the partition can be hidden.
 10385                              <1> ;input:
 10386                              <1> ;      ds:si -> the boot record
 10387                              <1> ;output:
 10388                              <1> ;      cf = 0 can be hidden
 10389                              <1> ;      cf = 1 cannot be hidden
 10390                              <1> ;==============================================================================
 10391                              <1> check_allow_hide:
 10392 000038DD 60                  <1>         pusha
 10393 000038DE 09F6                <1> 	or si, si
 10394 000038E0 741B                <1> 	jz .cannot_hide
 10395                              <1> 
 10396 000038E2 8B04                <1>         mov ax, [si + struc_bootrecord.flags]
 10397 000038E4 A90100              <1>         test ax, DRVFLAG_DRIVEOK
 10398 000038E7 7414                <1>         jz .cannot_hide
 10399 000038E9 A99800              <1>         test ax, INFOFLAG_ISDRIVER | DRVFLAG_ISCDROM | INFOFLAG_ISSPECIAL
 10400 000038EC 750F                <1>         jnz .cannot_hide
 10401                              <1> 
 10402 000038EE 8A4404              <1>         mov al, [si + struc_bootrecord.type]
 10403 000038F1 B90700              <1>         mov cx, NUM_OF_ALLOW_HIDE
 10404 000038F4 8D3E[983A]          <1>         lea di, [part_type.allow_hide_tbl]
 10405 000038F8 E83DF3              <1>         call strchr
 10406 000038FB 61                  <1>         popa
 10407 000038FC C3                  <1>         ret
 10408                              <1>         
 10409                              <1> .cannot_hide:
 10410 000038FD 61                  <1>         popa
 10411 000038FE F9                  <1>         stc
 10412 000038FF C3                  <1>         ret
 10413                              <1> 
 10414                              <1> ;==============================================================================
 10415                              <1> ;check_allow_act ---- check if the partition can be actived.
 10416                              <1> ;input:
 10417                              <1> ;      ds:si -> the boot record
 10418                              <1> ;output:
 10419                              <1> ;      cf = 0 can be actived
 10420                              <1> ;      cf = 1 cannot be actived
 10421                              <1> ;==============================================================================
 10422                              <1> check_allow_act:
 10423 00003900 60                  <1>         pusha
 10424 00003901 09F6                <1> 	or si, si
 10425 00003903 740F                <1> 	jz .cannot_act
 10426                              <1> 
 10427 00003905 8B04                <1>         mov ax, [si + struc_bootrecord.flags]   ; get flags
 10428 00003907 A90100              <1>         test ax, DRVFLAG_DRIVEOK
 10429 0000390A 7408                <1>         jz .cannot_act
 10430 0000390C A99801              <1>         test ax, INFOFLAG_ISDRIVER | INFOFLAG_LOGICAL | DRVFLAG_ISCDROM | INFOFLAG_ISSPECIAL
 10431 0000390F 7503                <1>         jnz .cannot_act
 10432 00003911 61                  <1>         popa
 10433 00003912 F8                  <1>         clc
 10434 00003913 C3                  <1>         ret
 10435                              <1>         
 10436                              <1> .cannot_act:
 10437 00003914 61                  <1>         popa
 10438 00003915 F9                  <1>         stc
 10439 00003916 C3                  <1>         ret
 10440                              <1> 
 10441                              <1> ;==============================================================================
 10442                              <1> ;check_prev_mbr ---- check if the previous mbr is avaiable.
 10443                              <1> ;input:
 10444                              <1> ;      none
 10445                              <1> ;output:
 10446                              <1> ;      cf = 0 present
 10447                              <1> ;      cf = 1 absent
 10448                              <1> ;==============================================================================
 10449                              <1> check_prev_mbr:
 10450 00003917 60                  <1> 	pusha
 10451 00003918 8A16[1000]          <1> 	mov dl, [ADDR_SBMK_DRVID]
 10452 0000391C E88C02              <1> 	call get_drive_flags
 10453 0000391F 7205                <1> 	jc .end
 10454 00003921 A804                <1> 	test al, DRVFLAG_REMOVABLE
 10455 00003923 7401                <1> 	jz .end
 10456 00003925 F9                  <1> 	stc
 10457                              <1> .end:
 10458 00003926 61                  <1> 	popa
 10459 00003927 C3                  <1> 	ret
 10460                              <1> 
 10461                              <1> ;==============================================================================
 10462                              <1> ;data area
 10463                              <1> ;==============================================================================
 10464                              <1> 
 10465                              <1> ; strings used in knl.asm
 10466 00003928 536B58614168486C44- <1> infoflag_chars  db "SkXaAhHlD",0
 10467 00003931 00                  <1>
 10468                              <1> 
 10469                              <1> knl_strings:
 10470 00003932 466C6F70707900      <1> .floppy     db "Floppy",0
 10471 00003939 5072696D61727900    <1> .primary    db "Primary",0
 10472 00003941 4C6F676963616C00    <1> .logical    db "Logical",0
 10473 00003949 52656D6F7661626C65- <1> .removable  db "Removable",0
 10474 00003952 00                  <1>
 10475 00003953 486172646469736B00  <1> .harddisk   db "Harddisk",0
 10476 0000395C 43442D524F4D00      <1> .cdrom      db "CD-ROM",0
 10477 00003963 5370656369616C00    <1> .special    db "Special",0
 10478 0000396B 506F776572204F6666- <1> .poweroff   db "Power Off",0
 10479 00003974 00                  <1>
 10480 00003975 5265626F6F7400      <1> .restart    db "Reboot",0
 10481 0000397C 5175697420746F2042- <1> .quit       db "Quit to BIOS",0
 10482 00003985 494F5300            <1>
 10483 00003989 50726576696F757320- <1> .bootprev   db "Previous MBR",0
 10484 00003992 4D425200            <1>
 10485 00003996 2D2D2D202D2D00      <1> .invalid_id db "--- --",0
 10486                              <1> 
 10487                              <1> ; partition types and strings
 10488                              <1> part_type:
 10489                              <1> 
 10490                              <1> ; table of partition type ids
 10491                              <1> .id_tbl:
 10492 0000399D 00060708090A0B0C    <1>         db 0x00, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 
 10493 000039A5 0E3C4D4E4F636581    <1> 	db 0x0E, 0x3C, 0x4D, 0x4E, 0x4F, 0x63, 0x65, 0x81, 
 10494 000039AD 82838E93A5A6A9B7    <1> 	db 0x82, 0x83, 0x8E, 0x93, 0xA5, 0xA6, 0xA9, 0xB7, 
 10495 000039B5 BEEB                <1> 	db 0xBE, 0xEB
 10496                              <1> 
 10497                              <1> ; table of partition type strings
 10498                              <1> .str_tbl:
 10499 000039B7 4E4F4E4520202000    <1>         db "NONE   ",0           ; No type
 10500 000039BF 4641543136202000    <1>         db "FAT16  ",0           ; 0x06
 10501 000039C7 48502F4E54465300    <1>         db "HP/NTFS",0           ; 0x07
 10502 000039CF 4149582830382900    <1> 	db "AIX(08)",0           ; 0x08
 10503 000039D7 4149582830392900    <1> 	db "AIX(09)",0           ; 0x09
 10504 000039DF 4F532F3220424D00    <1> 	db "OS/2 BM",0           ; 0x0A
 10505 000039E7 4641543332202000    <1>         db "FAT32  ",0           ; 0x0B
 10506 000039EF 4641543332782000    <1>         db "FAT32x ",0           ; 0x0C
 10507 000039F7 4641543136782000    <1>         db "FAT16x ",0           ; 0x0E
 10508 000039FF 50512D426F6F7400    <1>         db "PQ-Boot",0           ; 0x3C
 10509 00003A07 514E58342E782000    <1>         db "QNX4.x ",0           ; 0x4D
 10510 00003A0F 514E5834782D3200    <1>         db "QNX4x-2",0           ; 0x4E
 10511 00003A17 514E5834782D3300    <1>         db "QNX4x-3",0           ; 0x4F
 10512 00003A1F 4855524420202000    <1>         db "HURD   ",0           ; 0x63
 10513 00003A27 4E6F76656C6C2000    <1>         db "Novell ",0           ; 0x65
 10514 00003A2F 4D696E6978202000    <1>         db "Minix  ",0           ; 0x81
 10515 00003A37 4C6E785377617000    <1>         db "LnxSwap",0           ; 0x82
 10516 00003A3F 4C696E7578202000    <1>         db "Linux  ",0           ; 0x83
 10517 00003A47 4C6E78204C564D00    <1> 	db "Lnx LVM",0           ; 0x8E
 10518 00003A4F 416D6F6562612000    <1> 	db "Amoeba ",0           ; 0x93
 10519 00003A57 4253442F33383600    <1>         db "BSD/386",0           ; 0xA5
 10520 00003A5F 4F70656E42534400    <1>         db "OpenBSD",0           ; 0xA6
 10521 00003A67 4E65744253442000    <1>         db "NetBSD ",0           ; 0xA9
 10522 00003A6F 4253446920667300    <1>         db "BSDi fs",0           ; 0xB7
 10523 00003A77 536F6C6172697300    <1>         db "Solaris",0           ; 0xBE
 10524 00003A7F 42654F5320202000    <1>         db "BeOS   ",0           ; 0xEB
 10525 00003A87 556E6B6E6F776E00    <1>         db "Unknown",0           ; other
 10526                              <1> 
 10527                              <1> ; logical partition types which could not boot
 10528                              <1> ; include the following pri_deny_tbl
 10529                              <1> .log_deny_tbl:
 10530                              <1> %ifdef STRICT_PART_CHECK
 10531 00003A8F 010A0717            <1>         db 0x01, 0x0A, 0x07, 0x17
 10532                              <1> %endif
 10533                              <1> ; primary partition types which could not boot
 10534                              <1> .pri_deny_tbl:
 10535 00003A93 050F85              <1>         db 0x05, 0x0F, 0x85
 10536                              <1> %ifdef STRIC_PART_CHECK
 10537                              <1>         db 0x82, 0xA0, 0xB8, 0xE1, 0xE3, 0xF2
 10538                              <1> %endif
 10539 00003A96 00                  <1> 	db 0x00
 10540                              <1> 
 10541                              <1> ;the partition types which should be marked as auto active.
 10542                              <1> .auto_act_tbl:
 10543                              <1> ;the partition types which can be hidden.
 10544                              <1> ;the hide method is add 0x10 to the partition type.
 10545                              <1> ; ie. the type of hidden FAT16 = 0x16, etc.
 10546 00003A97 BE                  <1>         db 0xBE
 10547                              <1> .allow_hide_tbl:
 10548 00003A98 010406070B0C0E      <1>         db 0x01, 0x04, 0x06, 0x07, 0x0B, 0x0C, 0x0E
 10549                              <1> 
 10550                              <1> ; the types used to hide certain partitions.
 10551                              <1> .hidden_tbl:
 10552 00003A9F 111416171B1C1E      <1>         db 0x11, 0x14, 0x16, 0x17, 0x1B, 0x1C, 0x1E
 10553                              <1>         
 10554                              <1> .end_of_tbl
 10555                              <1> 
 10556                              <1> 
 10557                              <1> %ifndef MAIN
 10558                              <1> reset_video_mode:
 10559                              <1> 	ret
 10560                              <1> 
 10561                              <1> sbmk_header:
 10562                              <1> .drvid	db 0
 10563                              <1> 
 10564                              <1> 	section .bss
 10565                              <1> %include "tempdata.asm"
 10566                              <1> %endif
 10567                              <1> 
 10568                              <1> %endif	;End of HAVE_KNL
 10569                                  %include "hd_io.asm"
 10570                              <1> ; asmsyntax=nasm
 10571                              <1> ; hd_io.asm
 10572                              <1> ;
 10573                              <1> ; Interface to BIOS int 0x13 functions
 10574                              <1> ;
 10575                              <1> ; Copyright (C) 2000, Suzhe. See file COPYING for details.
 10576                              <1> ;
 10577                              <1> 
 10578                              <1> %ifndef HAVE_HD_IO
 10579                              <1> 
 10580                              <1> %ifndef MAIN
 10581                              <1> %include "macros.h"
 10582                              <1> %include "hd_io.h"
 10583                              <1> %include "utils.asm"
 10584                              <1> 	section .text
 10585                              <1> %endif
 10586                              <1> 
 10587                              <1> %define HAVE_HD_IO
 10588                              <1> 
 10589                              <1> %define RETRY_TIMES     3
 10590                              <1> 
 10591                              <1>         bits 16
 10592                              <1> ;==============================================================================
 10593                              <1> ;check_int13ext ---- Check if the extension of int13h is presents for a driver.
 10594                              <1> ;input:
 10595                              <1> ;      dl = driver id
 10596                              <1> ;output:
 10597                              <1> ;      cf = 0, int13ext is presents
 10598                              <1> ;          cl = interface support bitmap.
 10599                              <1> ;      cf = 1, int13ext is not presents
 10600                              <1> ;==============================================================================
 10601                              <1> check_int13ext:
 10602 00003AA6 803E[EA3C]00        <1>         cmp byte [use_int13_ext], 0
 10603 00003AAB 7414                <1>         jz .not_present
 10604                              <1> 
 10605 00003AAD BBAA55              <1>         mov bx, 0x55aa
 10606 00003AB0 B441                <1>         mov ah, INT13H_EXT_INSTCHECK
 10607 00003AB2 CD13                <1>         int 0x13                        ; Check if int13h extension is presents
 10608                              <1> ;        jc .not_present
 10609 00003AB4 81FB55AA            <1>         cmp bx, 0xaa55
 10610 00003AB8 7507                <1>         jne .not_present
 10611 00003ABA F6C105              <1>         test cl, EXT_SUBSET_FIXED | EXT_SUBSET_EDD
 10612                              <1> 					; Check if this drive supports extended
 10613 00003ABD 7402                <1>         jz .not_present                 ; read/write
 10614 00003ABF F8                  <1>         clc
 10615 00003AC0 C3                  <1>         ret
 10616                              <1> .not_present:
 10617 00003AC1 F9                  <1>         stc
 10618 00003AC2 C3                  <1>         ret
 10619                              <1> 
 10620                              <1> ;==============================================================================
 10621                              <1> ;get_drive_info ---- Get drive informations
 10622                              <1> ;input:
 10623                              <1> ;      dl = drive id
 10624                              <1> ;      es:di -> buffer for drive info (struc struc_driveinfo)
 10625                              <1> ;output:
 10626                              <1> ;      cf = 0 ok
 10627                              <1> ;      cf = 1 drive is not presents
 10628                              <1> ;==============================================================================
 10629                              <1> get_drive_info:
 10630 00003AC3 60                  <1>         pusha
 10631                              <1>         
 10632 00003AC4 8815                <1>         mov [di + struc_driveinfo.id], dl
 10633 00003AC6 C6450100            <1>         mov byte [di + struc_driveinfo.flags], 0 ; clear the flags
 10634                              <1> 
 10635 00003ACA 52                  <1>         push dx
 10636 00003ACB E8D8FF              <1>         call check_int13ext
 10637 00003ACE 5A                  <1>         pop dx
 10638 00003ACF 7359                <1>         jnc .ext_present
 10639                              <1> 
 10640 00003AD1 B415                <1>         mov ah, INT13H_GETTYPE
 10641 00003AD3 52                  <1>         push dx
 10642 00003AD4 CD13                <1>         int 0x13
 10643 00003AD6 8826[581A]          <1>         mov [hdio_tmp.disk_errno], ah
 10644 00003ADA 5A                  <1>         pop dx
 10645 00003ADB 724A                <1>         jc .drive_not_present
 10646 00003ADD 08E4                <1>         or ah, ah                           ; ah = drive type, = 0 no such drive
 10647 00003ADF 7446                <1>         jz .drive_not_present
 10648                              <1>         
 10649 00003AE1 06                  <1>         push es
 10650 00003AE2 57                  <1>         push di
 10651 00003AE3 50                  <1>         push ax                             ; save drive type
 10652 00003AE4 B408                <1>         mov ah, INT13H_GETINFO
 10653 00003AE6 CD13                <1>         int 0x13
 10654 00003AE8 8826[581A]          <1>         mov [hdio_tmp.disk_errno], ah
 10655 00003AEC 58                  <1>         pop ax
 10656 00003AED 5F                  <1>         pop di
 10657 00003AEE 07                  <1>         pop es
 10658 00003AEF 7236                <1>         jc .drive_not_present
 10659                              <1> 
 10660 00003AF1 50                  <1>         push ax                             ; drive type.
 10661 00003AF2 53                  <1>         push bx                             ; floppy type.
 10662                              <1>         
 10663 00003AF3 0FB6C1              <1>         movzx ax, cl                             ;
 10664 00003AF6 243F                <1>         and al, 0x3f                             ; get sectors per track
 10665 00003AF8 894506              <1>         mov [di + struc_driveinfo.sectors], ax   ;
 10666                              <1> 
 10667 00003AFB 86E5                <1>         xchg ah, ch                              ;
 10668 00003AFD C1E102              <1>         shl cx, 2                                ;
 10669 00003B00 88E1                <1>         mov cl, ah                               ; get cylinders
 10670 00003B02 41                  <1>         inc cx                                   ;
 10671 00003B03 894D02              <1>         mov [di + struc_driveinfo.cylinders], cx ;
 10672                              <1> 
 10673 00003B06 0FB6C6              <1> 	movzx ax, dh                             ; get heads
 10674 00003B09 40                  <1>         inc ax                                   ;
 10675 00003B0A 894504              <1>         mov [di + struc_driveinfo.heads], ax     ;
 10676                              <1> 
 10677 00003B0D 5B                  <1>         pop bx
 10678 00003B0E 58                  <1>         pop ax
 10679                              <1> 
 10680 00003B0F B601                <1>         mov dh, DRVFLAG_DRIVEOK
 10681 00003B11 80FC03              <1>         cmp ah, DRV_TYPE_FIXED                  ; fixed drive.
 10682 00003B14 7403                <1>         je .fixed_drive
 10683 00003B16 80CE04              <1>         or dh, DRVFLAG_REMOVABLE
 10684                              <1>         
 10685                              <1> .fixed_drive:
 10686 00003B19 80CE02              <1>         or dh, DRVFLAG_CHSVALID
 10687 00003B1C 887501              <1>         mov [di + struc_driveinfo.flags], dh
 10688 00003B1F C745080002          <1> 	mov word [di + struc_driveinfo.sector_size], 0x200
 10689 00003B24 E98100              <1>         jmp .endok
 10690                              <1> 
 10691                              <1> .drive_not_present:
 10692 00003B27 61                  <1>         popa
 10693 00003B28 F9                  <1>         stc
 10694 00003B29 C3                  <1>         ret
 10695                              <1> 
 10696                              <1> .ext_present:
 10697                              <1> ;Int13h ext is presents, use int13h ext to get drive info
 10698 00003B2A B448                <1>         mov ah, INT13H_EXT_GETINFO
 10699 00003B2C 8D36[FC19]          <1>         lea si, [hdio_tmp.extparam]
 10700 00003B30 C7044200            <1>         mov word [si + struc_extparam.pack_size], SIZE_OF_EXTPARAM
 10701 00003B34 52                  <1>         push dx
 10702 00003B35 CD13                <1>         int 0x13
 10703 00003B37 8826[581A]          <1>         mov [hdio_tmp.disk_errno], ah
 10704 00003B3B 5A                  <1>         pop dx
 10705 00003B3C 72E9                <1>         jc .drive_not_present
 10706                              <1>         
 10707 00003B3E 8B4404              <1>         mov ax, [si + struc_extparam.cylinders]
 10708 00003B41 894502              <1>         mov [di + struc_driveinfo.cylinders], ax
 10709 00003B44 8B4408              <1>         mov ax, [si + struc_extparam.heads]
 10710 00003B47 894504              <1>         mov [di + struc_driveinfo.heads], ax
 10711 00003B4A 8B440C              <1>         mov ax, [si + struc_extparam.sectors]
 10712 00003B4D 894506              <1>         mov [di + struc_driveinfo.sectors], ax
 10713 00003B50 8B4418              <1> 	mov ax, [si + struc_extparam.bytes_per_sect]
 10714 00003B53 894508              <1> 	mov [di + struc_driveinfo.sector_size], ax
 10715                              <1> 
 10716 00003B56 8A4402              <1>         mov al, [si + struc_extparam.flags]              ;
 10717 00003B59 2406                <1>         and al, (DRVFLAG_CHSVALID + DRVFLAG_REMOVABLE)   ; fill in the
 10718 00003B5B 0C09                <1>         or al, DRVFLAG_EXTOK + DRVFLAG_DRIVEOK           ; struc_driveinfo.flags
 10719                              <1> 
 10720                              <1> %ifndef DISABLE_CDBOOT
 10721 00003B5D 803C42              <1> 	cmp byte [si + struc_extparam.pack_size], SIZE_OF_EXTPARAM
 10722 00003B60 721F                <1> 	jb .no_edd30
 10723 00003B62 817C1EDDBE          <1> 	cmp word [si + struc_extparam.dpi_key], 0xBEDD
 10724 00003B67 7518                <1> 	jne .no_edd30
 10725 00003B69 807C2024            <1> 	cmp byte [si + struc_extparam.dpi_length], 36
 10726 00003B6D 7512                <1> 	jne .no_edd30
 10727 00003B6F 66817C2841544150    <1> 	cmp dword [si + struc_extparam.interface_type], 'ATAP'
 10728 00003B77 752C                <1> 	jne .not_cdrom
 10729 00003B79 807C2C49            <1> 	cmp byte [si + struc_extparam.interface_type+4], 'I'
 10730 00003B7D 7526                <1> 	jne .not_cdrom
 10731 00003B7F 0C10                <1> 	or al, DRVFLAG_ISCDROM
 10732                              <1> 
 10733                              <1> .no_edd30:
 10734 00003B81 803C1E              <1> 	cmp byte [si + struc_extparam.pack_size], 30
 10735 00003B84 721F                <1> 	jb .not_cdrom
 10736 00003B86 8B5C1C              <1> 	mov bx, [si + struc_extparam.dpte_addr+2]
 10737 00003B89 81FBFFFF            <1> 	cmp bx, 0xffff
 10738 00003B8D 7416                <1> 	je .not_cdrom
 10739 00003B8F 8B741A              <1> 	mov si, [si + struc_extparam.dpte_addr]
 10740 00003B92 81FEFFFF            <1> 	cmp si, 0xffff
 10741 00003B96 740D                <1> 	je .not_cdrom
 10742 00003B98 1E                  <1> 	push ds
 10743 00003B99 8EDB                <1> 	mov ds, bx
 10744 00003B9B 3EF6440A40          <1> 	test byte [ds:si + struc_dpte.bios_spec], 0x40  ; check if is atapi dev
 10745 00003BA0 1F                  <1> 	pop ds
 10746 00003BA1 7402                <1> 	jz .not_cdrom
 10747 00003BA3 0C10                <1> 	or al, DRVFLAG_ISCDROM
 10748                              <1> 
 10749                              <1> .not_cdrom:
 10750                              <1> %endif
 10751 00003BA5 884501              <1>         mov [di + struc_driveinfo.flags], al
 10752                              <1> 
 10753                              <1> .endok:
 10754 00003BA8 61                  <1>         popa
 10755 00003BA9 F8                  <1>         clc
 10756 00003BAA C3                  <1>         ret
 10757                              <1>         
 10758                              <1> ;==============================================================================
 10759                              <1> ;get_drive_flags ---- get drive flags
 10760                              <1> ;input:
 10761                              <1> ;      dl = drive id
 10762                              <1> ;output:
 10763                              <1> ;      cf = 0 ok, al = drive flags
 10764                              <1> ;      cf = 1 error, al = 0
 10765                              <1> ;==============================================================================
 10766                              <1> get_drive_flags:
 10767 00003BAB 57                  <1>         push di
 10768 00003BAC 8D3E[4E1A]          <1>         lea di, [hdio_tmp.driveinfo]
 10769 00003BB0 E810FF              <1>         call get_drive_info
 10770 00003BB3 8A4501              <1>         mov al, [di + struc_driveinfo.flags]
 10771 00003BB6 5F                  <1>         pop di
 10772 00003BB7 C3                  <1>         ret
 10773                              <1> 
 10774                              <1> ;;;;;;;;;;;;;;;;;;; perhaps these will be used in future ;;;;;;;;;;;;;;;;;;;
 10775                              <1> %if 0
 10776                              <1> ;==============================================================================
 10777                              <1> ;init_drives_info ---- get all drives info
 10778                              <1> ;input:
 10779                              <1> ;      es:di -> buffer to store the info of each drives
 10780                              <1> ;               should have enought space to store 255 drives' info
 10781                              <1> ;output:
 10782                              <1> ;      dh = the number of drives (include the floppy)
 10783                              <1> ;==============================================================================
 10784                              <1> init_drives_info:
 10785                              <1>         push es
 10786                              <1>         push di
 10787                              <1>         mov cx, 256
 10788                              <1>         xor dx, dx
 10789                              <1> .loop_query:
 10790                              <1>         push cx
 10791                              <1>         push dx
 10792                              <1>         call get_drive_info
 10793                              <1>         pop dx
 10794                              <1>         pop cx
 10795                              <1>         jc .bad_drive
 10796                              <1>         inc dh
 10797                              <1>         
 10798                              <1> .bad_drive:
 10799                              <1>         add di, SIZE_OF_DRIVEINFO
 10800                              <1>         inc dl
 10801                              <1>         loop .loop_query
 10802                              <1>         
 10803                              <1>         pop di
 10804                              <1>         pop es
 10805                              <1>         ret
 10806                              <1> 
 10807                              <1> %endif
 10808                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 10809                              <1> 
 10810                              <1> ;==============================================================================
 10811                              <1> ;lba2chs ---- lba to chs translation
 10812                              <1> ;input:
 10813                              <1> ;      ebx = lba address 
 10814                              <1> ;      ds : si -> drive info struc
 10815                              <1> ;output:
 10816                              <1> ;      cf = 0 success
 10817                              <1> ;            ch = low eight bits of cylinder number
 10818                              <1> ;            cl = sector number 1-63 (bits 0-5)
 10819                              <1> ;                 high two bits of cylinder (bits 6-7, hard disk only)
 10820                              <1> ;            dh = head number
 10821                              <1> ;      cf = 1 error ( cylinder exceed )
 10822                              <1> ;==============================================================================
 10823                              <1> lba2chs:
 10824 00003BB8 50                  <1>         push ax
 10825 00003BB9 6689D8              <1> 	mov eax, ebx
 10826                              <1> 
 10827 00003BBC 660FB74C06          <1>         movzx ecx, word [si + struc_driveinfo.sectors] ; calculate sector:
 10828                              <1> 
 10829 00003BC1 09C9                <1>         or cx, cx                              ; sectors per track cannot equal
 10830 00003BC3 7429                <1>         jz .convert_failed                     ; to zero.
 10831                              <1>         
 10832 00003BC5 6631D2              <1>         xor edx, edx
 10833 00003BC8 66F7F1              <1>         div ecx                                ; sector =  lba % sects_per_track + 1
 10834 00003BCB 42                  <1>         inc dx                                 ; lba1 = lba / sects_per_track
 10835 00003BCC 89D1                <1>         mov cx, dx                             ;
 10836                              <1> 
 10837                              <1>                                                ; calculate head and cylinder:
 10838                              <1>                                                ; head = lba1 % num_of_heads
 10839 00003BCE 660FB75C04          <1>         movzx ebx, word [si + struc_driveinfo.heads] 
 10840                              <1>                                                ; cylinder = lba1 / num_of_heads
 10841                              <1> 
 10842 00003BD3 08DB                <1>         or bl, bl                              ; heads cannot equal to zero.
 10843 00003BD5 7417                <1>         jz .convert_failed                     ;
 10844                              <1>         
 10845 00003BD7 6631D2              <1>         xor edx, edx
 10846 00003BDA 66F7F3              <1>         div ebx                                ;
 10847                              <1>         
 10848 00003BDD 88D6                <1>         mov dh, dl                             ; head = dl <= 255
 10849 00003BDF 3DFF03              <1>         cmp ax, MAX_CYLS                       ; cylinder = ax
 10850 00003BE2 770A                <1>         ja .convert_failed                     ; cylinder is too big.
 10851                              <1> 
 10852 00003BE4 86C4                <1>         xchg al, ah                            ;
 10853 00003BE6 C0E006              <1>         shl al, 6                              ; fill cylinder and sector into
 10854 00003BE9 09C1                <1>         or cx, ax                              ; cx
 10855 00003BEB 58                  <1>         pop ax
 10856 00003BEC F8                  <1>         clc
 10857 00003BED C3                  <1>         ret
 10858                              <1>         
 10859                              <1> .convert_failed:
 10860 00003BEE C606[581A]FE        <1>         mov byte [hdio_tmp.disk_errno], 0xFE             ; invalid LBA address
 10861 00003BF3 58                  <1>         pop ax
 10862 00003BF4 F9                  <1>         stc
 10863 00003BF5 C3                  <1>         ret
 10864                              <1>         
 10865                              <1> ;==============================================================================
 10866                              <1> ;disk_access_low ---- read / write sectors on disk
 10867                              <1> ;input:
 10868                              <1> ;      ah      = function id, ( 02 = read, 03 = write )
 10869                              <1> ;      al      = number of sectors to be accessed
 10870                              <1> ;      ebx     = lba address
 10871                              <1> ;      ds : si -> drive info struc
 10872                              <1> ;      es : di -> buffer to get/store data
 10873                              <1> ;output:
 10874                              <1> ;      cf = 0 success
 10875                              <1> ;      cf = 1 error
 10876                              <1> ;==============================================================================
 10877                              <1> disk_access_low:
 10878 00003BF6 60                  <1>         pusha
 10879                              <1>         
 10880 00003BF7 8A7401              <1>         mov dh, [si + struc_driveinfo.flags]
 10881 00003BFA F6C601              <1>         test dh, DRVFLAG_DRIVEOK ; check if drive ok
 10882 00003BFD 7468                <1>         jz .access_error
 10883                              <1>         
 10884 00003BFF F6C608              <1>         test dh, DRVFLAG_EXTOK
 10885 00003C02 7440                <1>         jz .no_ext
 10886                              <1>         
 10887                              <1> ;int13h extension is present, use it
 10888                              <1>         
 10889 00003C04 8A14                <1>         mov dl, [si + struc_driveinfo.id]    ; get drive id
 10890 00003C06 80C440              <1>         add ah, 0x40                         ; ext read func id = 0x42
 10891 00003C09 8D36[3E1A]          <1>         lea si, [hdio_tmp.int13ext]
 10892 00003C0D 6631C9              <1>         xor ecx, ecx
 10893 00003C10 C60410              <1>         mov byte [si + struc_int13ext.pack_size], 0x10 ;
 10894 00003C13 66894C0C            <1>         mov [si + struc_int13ext.blk_num_high1], ecx ; clear and set
 10895 00003C17 884C01              <1>         mov [si + struc_int13ext.reserved], cl       ; some stuff.
 10896 00003C1A 884C03              <1>         mov [si + struc_int13ext.reserved1], cl      ;
 10897                              <1> 
 10898 00003C1D 897C04              <1>         mov [si + struc_int13ext.buf_addr_off], di
 10899 00003C20 8C4406              <1>         mov [si + struc_int13ext.buf_addr_seg], es
 10900 00003C23 66895C08            <1>         mov [si + struc_int13ext.blk_num_low1], ebx
 10901                              <1> 
 10902                              <1> .retry_ext_read:
 10903 00003C27 884402              <1>         mov [si + struc_int13ext.blk_count], al
 10904                              <1>         
 10905 00003C2A 50                  <1>         push ax
 10906 00003C2B 52                  <1>         push dx
 10907 00003C2C 56                  <1>         push si
 10908 00003C2D CD13                <1>         int 0x13
 10909 00003C2F 8826[581A]          <1>         mov [hdio_tmp.disk_errno], ah
 10910 00003C33 5E                  <1>         pop si
 10911 00003C34 5A                  <1>         pop dx
 10912 00003C35 58                  <1>         pop ax
 10913 00003C36 7330                <1>         jnc .access_ok
 10914 00003C38 E86D00              <1>         call reset_drive
 10915 00003C3B FEC6                <1>         inc dh
 10916 00003C3D 80FE03              <1>         cmp dh, RETRY_TIMES                 ; retry 3 times
 10917 00003C40 72E5                <1>         jb .retry_ext_read
 10918 00003C42 EB23                <1>         jmp short .access_error
 10919                              <1> 
 10920                              <1> ;int13h extension is not ok, use old int13h
 10921                              <1> .no_ext:
 10922 00003C44 E871FF              <1>         call lba2chs
 10923 00003C47 721E                <1>         jc .access_error
 10924 00003C49 8A14                <1>         mov dl, [si + struc_driveinfo.id]   ; dl = drive id
 10925 00003C4B 89FB                <1>         mov bx, di                          ; es : bx -> buffer
 10926 00003C4D 31FF                <1>         xor di, di
 10927                              <1>         
 10928                              <1> .retry_read:
 10929 00003C4F 50                  <1>         push ax
 10930 00003C50 52                  <1>         push dx
 10931 00003C51 53                  <1>         push bx
 10932 00003C52 CD13                <1>         int 0x13
 10933 00003C54 8826[581A]          <1>         mov [hdio_tmp.disk_errno], ah
 10934 00003C58 5B                  <1>         pop bx
 10935 00003C59 5A                  <1>         pop dx
 10936 00003C5A 58                  <1>         pop ax
 10937 00003C5B 730B                <1>         jnc .access_ok
 10938 00003C5D E84800              <1>         call reset_drive
 10939 00003C60 47                  <1>         inc di
 10940 00003C61 81FF0300            <1>         cmp di, RETRY_TIMES                 ; retry 3 times
 10941 00003C65 72E8                <1>         jb .retry_read
 10942                              <1> 
 10943                              <1> .access_error:
 10944 00003C67 F9                  <1>         stc
 10945                              <1> .access_ok:
 10946 00003C68 61                  <1>         popa
 10947 00003C69 C3                  <1>         ret
 10948                              <1> 
 10949                              <1> ;==============================================================================
 10950                              <1> ;disk_access ---- read / write sectors on disk
 10951                              <1> ;input:
 10952                              <1> ;      ah = function id, ( 02 = read, 03 = write )
 10953                              <1> ;      al = number of sectors to be accessed
 10954                              <1> ;      ebx = lba address
 10955                              <1> ;      dl = drive id
 10956                              <1> ;      es : di -> buffer
 10957                              <1> ;output:
 10958                              <1> ;      cf = 0 success
 10959                              <1> ;      cf = 1 error
 10960                              <1> ;==============================================================================
 10961                              <1> disk_access:
 10962 00003C6A 56                  <1>         push si
 10963 00003C6B 57                  <1>         push di
 10964 00003C6C 6653                <1> 	push ebx
 10965                              <1> 
 10966 00003C6E 06                  <1>         push es
 10967 00003C6F 1E                  <1>         push ds                         ; ds -> es, hdio_tmp.driveinfo is in ds segment.
 10968 00003C70 07                  <1>         pop es
 10969                              <1>         
 10970 00003C71 8D3E[4E1A]          <1>         lea di, [hdio_tmp.driveinfo]
 10971 00003C75 E84BFE              <1>         call get_drive_info
 10972                              <1>         
 10973 00003C78 07                  <1>         pop es
 10974 00003C79 665B                <1> 	pop ebx
 10975 00003C7B 5F                  <1>         pop di
 10976                              <1>         
 10977 00003C7C 7207                <1>         jc .access_error
 10978 00003C7E 8D36[4E1A]          <1>         lea si, [hdio_tmp.driveinfo]
 10979 00003C82 E871FF              <1>         call disk_access_low
 10980                              <1> .access_error:
 10981 00003C85 5E                  <1>         pop si
 10982 00003C86 C3                  <1>         ret
 10983                              <1> 
 10984                              <1> 
 10985                              <1> %if 0
 10986                              <1> ;==============================================================================
 10987                              <1> ;get_cdrom_devinfo ---- get the CDROM's device info, e.g. io port
 10988                              <1> ;input: dl = drive id
 10989                              <1> ;output: cf = 0 success, ax = base io port, bx = ctrl port,
 10990                              <1> ;        cx = device specification
 10991                              <1> ;==============================================================================
 10992                              <1> get_cdrom_devinfo:
 10993                              <1> 	push si
 10994                              <1> 	call get_drive_flags
 10995                              <1> 	test al, DRVFLAG_ISCDROM
 10996                              <1> 	jz .not_cdrom
 10997                              <1> 
 10998                              <1> 	mov si, hdio_tmp.extparam
 10999                              <1> 	mov word [si], SIZE_OF_EXTPARAM
 11000                              <1> 	mov ah, 0x48
 11001                              <1> 	int 0x13
 11002                              <1> 
 11003                              <1> 	jc .not_cdrom
 11004                              <1> 	cmp byte [si], 30
 11005                              <1> 	jb .not_cdrom
 11006                              <1> 	mov ax, [si + struc_extparam.dpte_addr + 2]
 11007                              <1> 	cmp ax, 0xffff
 11008                              <1> 	je .not_cdrom
 11009                              <1> 
 11010                              <1> 	push es
 11011                              <1> 	push di
 11012                              <1> 	mov es, ax
 11013                              <1> 	mov di, [si + struc_extparam.dpte_addr]
 11014                              <1> 	mov ax, [es:di + struc_dpte.base_io]
 11015                              <1> 	mov bx, [es:di + struc_dpte.ctrl_io]
 11016                              <1> 	pop di
 11017                              <1> 	pop es
 11018                              <1> 
 11019                              <1> 	cmp byte [si], SIZE_OF_EXTPARAM
 11020                              <1> 	jb .not_cdrom
 11021                              <1> 	mov cx, [si + struc_extparam.device_path]
 11022                              <1> 	clc
 11023                              <1> 	jmp short .ok
 11024                              <1> 
 11025                              <1> .not_cdrom:
 11026                              <1> 	stc
 11027                              <1> .ok:
 11028                              <1> 	pop si
 11029                              <1> 	ret
 11030                              <1> 
 11031                              <1> %endif
 11032                              <1> 
 11033                              <1> %ifndef DISABLE_CDBOOT
 11034                              <1> ;==============================================================================
 11035                              <1> ;get_cdrom_boot_catalog ---- get the CDROM's boot catalog
 11036                              <1> ;input:
 11037                              <1> ;	dl = drive id
 11038                              <1> ;	es:di -> buffer
 11039                              <1> ;output:
 11040                              <1> ;	cf =0 success
 11041                              <1> ;	cf =1 error
 11042                              <1> ;==============================================================================
 11043                              <1> get_cdrom_boot_catalog:
 11044 00003C87 60                  <1> 	pusha
 11045 00003C88 BE[F419]            <1> 	mov si, hdio_tmp.cdbc_cmd
 11046 00003C8B C60408              <1> 	mov byte [si], SIZE_OF_CDBC_CMD
 11047 00003C8E C6440101            <1> 	mov byte [si+struc_cdbc_cmd.sector_count], 1
 11048 00003C92 897C02              <1> 	mov [si+struc_cdbc_cmd.buf_addr_off], di
 11049 00003C95 8C4404              <1> 	mov [si+struc_cdbc_cmd.buf_addr_seg], es
 11050 00003C98 31DB                <1> 	xor bx, bx
 11051 00003C9A 895C06              <1> 	mov [si+struc_cdbc_cmd.begnning_sect], bx
 11052 00003C9D B8004D              <1> 	mov ax, 0x4d00
 11053 00003CA0 CD13                <1> 	int 0x13
 11054 00003CA2 8826[581A]          <1> 	mov [hdio_tmp.disk_errno], ah
 11055 00003CA6 61                  <1> 	popa
 11056 00003CA7 C3                  <1> 	ret
 11057                              <1> %endif
 11058                              <1> 
 11059                              <1> ;==============================================================================
 11060                              <1> ;reset_drive ---- reset the drive
 11061                              <1> ;input:
 11062                              <1> ;      dl = drive id
 11063                              <1> ;output:
 11064                              <1> ;      cf = 0 success
 11065                              <1> ;      cf = 1 error
 11066                              <1> ;==============================================================================
 11067                              <1> reset_drive:
 11068 00003CA8 60                  <1>         pusha
 11069 00003CA9 31C0                <1>         xor ax, ax
 11070 00003CAB CD13                <1>         int 0x13
 11071 00003CAD 61                  <1>         popa
 11072 00003CAE C3                  <1>         ret
 11073                              <1> 
 11074                              <1> ;==============================================================================
 11075                              <1> ; get_last_disk_errno ---- get the last disk error number
 11076                              <1> ; input:
 11077                              <1> ;	none
 11078                              <1> ; output:
 11079                              <1> ;	ax = errno
 11080                              <1> ;==============================================================================
 11081                              <1> get_last_disk_errno:
 11082 00003CAF A1[581A]            <1> 	mov ax, [hdio_tmp.disk_errno]
 11083 00003CB2 C3                  <1> 	ret
 11084                              <1> 
 11085                              <1> ;==============================================================================
 11086                              <1> ;get_drvid_str ---- get driver id string
 11087                              <1> ;input:
 11088                              <1> ;	dl = drive id
 11089                              <1> ;	es:di -> buffer
 11090                              <1> ;output:
 11091                              <1> ;	es:di -> point to the end of the string
 11092                              <1> ;==============================================================================
 11093                              <1> get_drvid_str:
 11094 00003CB3 60                  <1> 	pusha
 11095                              <1> 
 11096                              <1> %ifdef SHOW_DRV_NAME
 11097 00003CB4 E8F4FE              <1> 	call get_drive_flags
 11098 00003CB7 80FA80              <1> 	cmp dl, MIN_HD_ID
 11099 00003CBA 720D                <1> 	jb .floppy
 11100 00003CBC A804                <1> 	test al, DRVFLAG_REMOVABLE
 11101 00003CBE 740E                <1> 	jz .harddisk
 11102 00003CC0 A810                <1> 	test al, DRVFLAG_ISCDROM
 11103 00003CC2 750F                <1> 	jnz .cdrom
 11104 00003CC4 B85244              <1> 	mov ax, 'RD'
 11105 00003CC7 EB0D                <1> 	jmp short .show_drv_name
 11106                              <1> .floppy:
 11107 00003CC9 B84644              <1> 	mov ax, 'FD'
 11108 00003CCC EB08                <1> 	jmp short .show_drv_name
 11109                              <1> .harddisk:
 11110 00003CCE B84844              <1> 	mov ax, 'HD'
 11111 00003CD1 EB03                <1> 	jmp short .show_drv_name
 11112                              <1> .cdrom:
 11113 00003CD3 B84344              <1> 	mov ax, 'CD'
 11114                              <1> .show_drv_name:
 11115 00003CD6 AA                  <1> 	stosb
 11116 00003CD7 88E0                <1> 	mov al, ah
 11117 00003CD9 AA                  <1> 	stosb
 11118                              <1> 
 11119 00003CDA 0FB6C2              <1> 	movzx ax, dl
 11120 00003CDD 240F                <1> 	and al, 0x0F
 11121 00003CDF B101                <1> 	mov cl, 1
 11122 00003CE1 E8B3EF              <1> 	call htoa
 11123                              <1> %else
 11124                              <1>         movzx ax, dl                                ; fill drive id
 11125                              <1>         mov cl, 3                                   ;
 11126                              <1>         call itoa                                   ;
 11127                              <1> %endif
 11128 00003CE4 61                  <1> 	popa
 11129 00003CE5 81C70300            <1> 	add di, 3
 11130 00003CE9 C3                  <1> 	ret
 11131                              <1> 
 11132 00003CEA 01                  <1> use_int13_ext  db 1
 11133                              <1> 
 11134                              <1> %ifndef MAIN
 11135                              <1> 	section .bss
 11136                              <1> %include "tempdata.asm"
 11137                              <1> %endif
 11138                              <1> 
 11139                              <1> %endif	;End of HAVE_HD_IO
 11140                                  %include "myint13h.asm"
 11141                              <1> ; asmsyntax=nasm
 11142                              <1> ;
 11143                              <1> ; myint13h.asm
 11144                              <1> ;
 11145                              <1> ; install / uninstall func for my int13h
 11146                              <1> ;
 11147                              <1> ; Copyright (C) 2000, Suzhe. See file COPYING for details.
 11148                              <1> ;
 11149                              <1> %ifndef HAVE_MYINT13H
 11150                              <1> %define HAVE_MYINT13H
 11151                              <1> 
 11152                              <1> %ifndef DISABLE_CDBOOT
 11153                              <1>   %define SIZE_OF_EDD30	8	; my EDD3.0 and ATAPI driver need 6K mem
 11154                              <1> %else
 11155                              <1>   %define SIZE_OF_EDD30	1	; my SWAP Driver ID wrapper needs 1K mem
 11156                              <1> %endif
 11157                              <1> 
 11158                              <1> %ifndef DISABLE_CDBOOT
 11159                              <1>   %define EDD30_SIG1	'BM'
 11160                              <1>   %define EDD30_SIG2	'CB'
 11161                              <1> %else
 11162                              <1>   %define EDD30_SIG1	'BM'
 11163                              <1>   %define EDD30_SIG2	'SD'
 11164                              <1> %endif
 11165                              <1> 
 11166                              <1> %ifndef MAIN
 11167                              <1> 	section .text
 11168                              <1> %endif
 11169                              <1> 
 11170                              <1> ;=============================================================================
 11171                              <1> ;install_myint13h ---- install my int13h handler
 11172                              <1> ; bl = 0 init cdrom
 11173                              <1> ; bl = 1 don't init cdrom
 11174                              <1> ;=============================================================================
 11175                              <1> install_myint13h:
 11176 00003CEB 60                  <1> 	pusha
 11177 00003CEC 06                  <1> 	push es
 11178 00003CED 31C0                <1> 	xor ax, ax
 11179 00003CEF 8EC0                <1> 	mov es, ax
 11180                              <1> 
 11181 00003CF1 E87600              <1> 	call check_myint13h
 11182 00003CF4 720A                <1> 	jc .not_inst
 11183 00003CF6 26A14E00            <1> 	mov ax, [es:0x13*4+2]
 11184 00003CFA A3[1037]            <1> 	mov [myint13h_tmp.edd30_seg], ax
 11185                              <1> 
 11186 00003CFD E92E00              <1> 	jmp .end
 11187                              <1> 	
 11188                              <1> .not_inst:
 11189                              <1> 
 11190                              <1> %ifndef DISABLE_CDBOOT
 11191 00003D00 53                  <1> 	push bx
 11192                              <1> %endif
 11193 00003D01 26812E13040800      <1> 	sub word [es:0x413], SIZE_OF_EDD30 ; allocate memory for module edd30
 11194 00003D08 CD12                <1> 	int 0x12
 11195 00003D0A C1E006              <1> 	shl ax, 6
 11196 00003D0D 50                  <1> 	push ax
 11197 00003D0E 07                  <1> 	pop es
 11198 00003D0F 31FF                <1> 	xor di, di
 11199 00003D11 BE[883D]            <1> 	mov si, module_edd30
 11200 00003D14 B9F80B              <1> 	mov cx, end_of_mod_edd30 - module_edd30
 11201 00003D17 FC                  <1> 	cld
 11202 00003D18 F3A4                <1> 	rep movsb
 11203                              <1> 
 11204 00003D1A A3[1037]            <1> 	mov [myint13h_tmp.edd30_seg], ax
 11205                              <1> 
 11206                              <1> %ifndef DISABLE_CDBOOT
 11207 00003D1D 5B                  <1> 	pop bx
 11208 00003D1E 08DB                <1> 	or bl, bl
 11209 00003D20 7506                <1> 	jnz .go_inst_int13
 11210 00003D22 B402                <1> 	mov ah, 2
 11211 00003D24 FF1E[0E37]          <1> 	call far [myint13h_tmp.edd30_off]	;initialize cdrom drivers
 11212                              <1> %endif
 11213                              <1> 
 11214                              <1> .go_inst_int13:
 11215 00003D28 31C0                <1> 	xor ax, ax
 11216 00003D2A FF1E[0E37]          <1> 	call far [myint13h_tmp.edd30_off]	;install my int13h 
 11217                              <1> 
 11218                              <1> .end:
 11219 00003D2E 07                  <1> 	pop es
 11220 00003D2F 61                  <1> 	popa
 11221 00003D30 C3                  <1> 	ret
 11222                              <1> 
 11223                              <1> ;=============================================================================
 11224                              <1> ;uninstall_myint13h ---- uninstall my int13h handler
 11225                              <1> ;=============================================================================
 11226                              <1> uninstall_myint13h:
 11227 00003D31 60                  <1> 	pusha
 11228 00003D32 E83500              <1> 	call check_myint13h
 11229 00003D35 7215                <1> 	jc .not_inst
 11230                              <1> 
 11231 00003D37 B401                <1> 	mov ah, 1
 11232 00003D39 FF1E[0E37]          <1> 	call far [myint13h_tmp.edd30_off]
 11233 00003D3D 720D                <1> 	jc .not_inst
 11234                              <1> 
 11235 00003D3F 06                  <1> 	push es
 11236 00003D40 31C0                <1> 	xor ax, ax
 11237 00003D42 8EC0                <1> 	mov es, ax
 11238 00003D44 26810613040800      <1> 	add word [es:0x413], SIZE_OF_EDD30 ; free memory
 11239 00003D4B 07                  <1> 	pop es
 11240                              <1> 
 11241                              <1> .not_inst:
 11242 00003D4C 61                  <1> 	popa
 11243 00003D4D C3                  <1> 	ret
 11244                              <1> 
 11245                              <1> ;=============================================================================
 11246                              <1> ;set_drive_map
 11247                              <1> ;input: bx, cx drive map
 11248                              <1> ;=============================================================================
 11249                              <1> set_drive_map:
 11250 00003D4E 60                  <1> 	pusha
 11251 00003D4F E81800              <1> 	call check_myint13h
 11252 00003D52 7206                <1> 	jc .end
 11253 00003D54 B403                <1> 	mov ah, 3
 11254                              <1> 
 11255 00003D56 FF1E[0E37]          <1> 	call far [myint13h_tmp.edd30_off]
 11256                              <1> .end:
 11257 00003D5A 61                  <1> 	popa
 11258 00003D5B C3                  <1> 	ret
 11259                              <1> 
 11260                              <1> ;=============================================================================
 11261                              <1> ;set_io_ports
 11262                              <1> ;input: bx, cx io ports
 11263                              <1> ;=============================================================================
 11264                              <1> set_io_ports:
 11265 00003D5C 60                  <1> 	pusha
 11266 00003D5D E80A00              <1> 	call check_myint13h
 11267 00003D60 7206                <1> 	jc .end
 11268 00003D62 B404                <1> 	mov ah, 4
 11269                              <1> 
 11270 00003D64 FF1E[0E37]          <1> 	call far [myint13h_tmp.edd30_off]
 11271                              <1> .end:
 11272 00003D68 61                  <1> 	popa
 11273 00003D69 C3                  <1> 	ret
 11274                              <1> 
 11275                              <1> ;=============================================================================
 11276                              <1> ;check_myint13h ---- check if myint13h is present
 11277                              <1> ;=============================================================================
 11278                              <1> check_myint13h:
 11279 00003D6A 60                  <1> 	pusha
 11280 00003D6B B86666              <1> 	mov ax, 0x6666
 11281 00003D6E BB424D              <1> 	mov bx, EDD30_SIG1
 11282 00003D71 B94342              <1> 	mov cx, EDD30_SIG2
 11283 00003D74 F8                  <1> 	clc
 11284 00003D75 CD13                <1> 	int 0x13
 11285 00003D77 720C                <1> 	jc .absent
 11286 00003D79 81FB4342            <1> 	cmp bx, EDD30_SIG2
 11287 00003D7D 7506                <1> 	jne .absent
 11288 00003D7F 81F9424D            <1> 	cmp cx, EDD30_SIG1
 11289 00003D83 7401                <1> 	je .end
 11290                              <1> .absent:
 11291 00003D85 F9                  <1> 	stc
 11292                              <1> .end:
 11293 00003D86 61                  <1> 	popa
 11294 00003D87 C3                  <1> 	ret
 11295                              <1> 
 11296                              <1> module_edd30:
 11297 00003D87 <incbin>            <1> incbin "edd30.bin"
 11298                              <1> end_of_mod_edd30:
 11299                              <1> 
 11300                              <1> %ifndef MAIN
 11301                              <1> 	section .bss
 11302                              <1> %include "tempdata.asm"
 11303                              <1> %endif
 11304                              <1> 
 11305                              <1> %endif
 11306                                  
 11307                                  ;=============================================================================
 11308                                  ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<  DATA AREA  >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 11309                                  ;=============================================================================
 11310                                  
 11311                                  %define ROOT_WINDOW_ACTION_NUMBER (main_action_table.end_of_root_window - main_action_table.root_window) / SIZE_OF_STRUC_ACTION
 11312                                  %define BOOT_MENU_ACTION_NUMBER (main_action_table.end_of_boot_menu - main_action_table.boot_menu) / SIZE_OF_STRUC_ACTION
 11313                                  %define MAIN_MENU_ACTION_NUMBER (main_action_table.end_of_main_menu - main_action_table.main_menu) / SIZE_OF_STRUC_ACTION
 11314                                  %define RECORD_MENU_ACTION_NUMBER (main_action_table.end_of_record_menu - main_action_table.record_menu) / SIZE_OF_STRUC_ACTION
 11315                                  %define SYS_MENU_ACTION_NUMBER (main_action_table.end_of_sys_menu - main_action_table.sys_menu) / SIZE_OF_STRUC_ACTION
 11316                                  
 11317                                  %define MAIN_MENU_ITEMS_NUMBER   11
 11318                                  %define RECORD_MENU_ITEMS_NUMBER 16
 11319                                  %define SYS_MENU_ITEMS_NUMBER    18
 11320                                  ;=============================================================================
 11321                                  ; Windows data
 11322                                  ;=============================================================================
 11323                                  main_windows_data:
 11324                                  .root_window    istruc struc_window
 11325 00004980 0900                    		at struc_window.flags,                  dw WINFLAG_OPEN | WINFLAG_NO_FOCUS
 11326 00004982 0000                    		at struc_window.title,                  dw 0
 11327 00004984 0000                    		at struc_window.win_attr,               dw 0
 11328 00004986 0000                    		at struc_window.win_pos,                dw 0
 11329 00004988 0000                    		at struc_window.win_size,               dw 0
 11330 0000498A 0000                    		at struc_window.parent_win,             dw 0
 11331 0000498C 0000                    		at struc_window.next_win,               dw 0
 11332 0000498E 0000                    		at struc_window.previous_win,           dw 0
 11333 00004990 2F00                    		at struc_window.act_num,                dw ROOT_WINDOW_ACTION_NUMBER
 11334 00004992 [464A]                  		at struc_window.act_table,              dw main_action_table.root_window
 11335 00004994 [4429]                  		at struc_window.default_event_handle,   dw window_default_event_handle
 11336 00004996 [5029]                  		at struc_window.event_handle,           dw window_event_handle
 11337 00004998 [B918]                  		at struc_window.draw_body_proc,         dw root_window_draw_body_proc
 11338                                  		iend
 11339                                  
 11340                                  .boot_menu      istruc struc_menu_box
 11341 0000499A F400                    		at struc_window.flags,                  dw WINFLAG_FRAMED | MENUFLAG_SCROLLBAR | MENUFLAG_SINK_UPPER | MENUFLAG_SINK_WIDTH | MENUFLAG_SINK_BOTTOM
 11342 0000499C [FF4B]                  		at struc_window.title,                  dw str_idx.boot_menu_title
 11343 0000499E F13F                    		at struc_window.win_attr,               dw 0x3FF1
 11344 000049A0 0000                    		at struc_window.win_pos,                dw 0
 11345 000049A2 0000                    		at struc_window.win_size,               dw 0
 11346 000049A4 [8049]                  		at struc_window.parent_win,             dw .root_window
 11347 000049A6 0000                    		at struc_window.next_win,               dw 0
 11348 000049A8 0000                    		at struc_window.previous_win,           dw 0
 11349 000049AA 1300                    		at struc_window.act_num,                dw BOOT_MENU_ACTION_NUMBER
 11350 000049AC [314B]                  		at struc_window.act_table,              dw main_action_table.boot_menu
 11351 000049AE [1626]                  		at struc_window.default_event_handle,   dw menubox_default_event_handle
 11352 000049B0 [5029]                  		at struc_window.event_handle,           dw window_event_handle
 11353 000049B2 [D824]                  		at struc_window.draw_body_proc,         dw menubox_draw_body_proc
 11354 000049B4 [014C]                  		at struc_menu_box.menu_header,          dw str_idx.boot_menu_header
 11355 000049B6 1F                      		at struc_menu_box.menu_header_attr,     db 0x1F
 11356 000049B7 707C                    		at struc_menu_box.menu_norm_attr,       dw 0x7C70
 11357 000049B9 0F0C                    		at struc_menu_box.menu_focus_attr,      dw 0x0C0F
 11358 000049BB 0000                                    at struc_menu_box.menu_area_pos,        dw 0
 11359 000049BD 0000                                    at struc_menu_box.menu_area_size,       dw 0
 11360 000049BF 3F                      		at struc_menu_box.scrollbar_attr,       db 0x3F
 11361 000049C0 00                      		at struc_menu_box.items_num,            db 0
 11362 000049C1 00                      		at struc_menu_box.focus_item,           db 0
 11363 000049C2 00                      		at struc_menu_box.first_visible_item,   db 0
 11364 000049C3 [3B1A]                  		at struc_menu_box.item_str_proc,        dw boot_menu_item_str_proc
 11365                                  		iend
 11366                                  
 11367                                  .main_menu      istruc struc_menu_box
 11368 000049C5 0400                    		at struc_window.flags,                  dw WINFLAG_FRAMED
 11369 000049C7 [774C]                  		at struc_window.title,                  dw str_idx.main_menu_title
 11370 000049C9 F130                    		at struc_window.win_attr,               dw 0x30F1
 11371 000049CB 0101                    		at struc_window.win_pos,                dw 0x0101
 11372 000049CD 000D                    		at struc_window.win_size,               db 0, MAIN_MENU_ITEMS_NUMBER+2
 11373 000049CF [9A49]                  		at struc_window.parent_win,             dw .boot_menu
 11374 000049D1 0000                    		at struc_window.next_win,               dw 0
 11375 000049D3 0000                    		at struc_window.previous_win,           dw 0
 11376 000049D5 0B00                    		at struc_window.act_num,                dw MAIN_MENU_ACTION_NUMBER
 11377 000049D7 [464A]                  		at struc_window.act_table,              dw main_action_table.main_menu
 11378 000049D9 [1626]                  		at struc_window.default_event_handle,   dw menubox_default_event_handle
 11379 000049DB [5029]                  		at struc_window.event_handle,           dw window_event_handle
 11380 000049DD [D824]                  		at struc_window.draw_body_proc,	        dw menubox_draw_body_proc
 11381 000049DF 0000                    		at struc_menu_box.menu_header,          dw 0
 11382 000049E1 3F                      		at struc_menu_box.menu_header_attr,     db 0x3F
 11383 000049E2 303C                    		at struc_menu_box.menu_norm_attr,       dw 0x3C30
 11384 000049E4 070C                    		at struc_menu_box.menu_focus_attr,      dw 0x0C07
 11385 000049E6 0000                                    at struc_menu_box.menu_area_pos,        dw 0
 11386 000049E8 0000                                    at struc_menu_box.menu_area_size,       dw 0
 11387 000049EA 3F                      		at struc_menu_box.scrollbar_attr,       db 0x3F
 11388 000049EB 0B                      		at struc_menu_box.items_num,            db MAIN_MENU_ITEMS_NUMBER
 11389 000049EC 00                      		at struc_menu_box.focus_item,           db 0
 11390 000049ED 00                      		at struc_menu_box.first_visible_item,   db 0
 11391 000049EE [551A]                  		at struc_menu_box.item_str_proc,        dw main_menu_item_str_proc
 11392                                  		iend
 11393                                  
 11394                                  .record_menu    istruc struc_menu_box
 11395 000049F0 0400                    		at struc_window.flags,                  dw WINFLAG_FRAMED
 11396 000049F2 [8F4C]                  		at struc_window.title,                  dw str_idx.record_menu_title
 11397 000049F4 F130                    		at struc_window.win_attr,               dw 0x30F1
 11398 000049F6 0202                    		at struc_window.win_pos,                dw 0x0202
 11399 000049F8 0012                    		at struc_window.win_size,               db 0, RECORD_MENU_ITEMS_NUMBER+2
 11400 000049FA [9A49]                  		at struc_window.parent_win,             dw .boot_menu
 11401 000049FC 0000                    		at struc_window.next_win,               dw 0
 11402 000049FE 0000                    		at struc_window.previous_win,           dw 0
 11403 00004A00 1000                    		at struc_window.act_num,                dw RECORD_MENU_ACTION_NUMBER
 11404 00004A02 [7D4A]                  		at struc_window.act_table,              dw main_action_table.record_menu
 11405 00004A04 [1626]                  		at struc_window.default_event_handle,   dw menubox_default_event_handle
 11406 00004A06 [5029]                  		at struc_window.event_handle,           dw window_event_handle
 11407 00004A08 [D824]                  		at struc_window.draw_body_proc,	        dw menubox_draw_body_proc
 11408 00004A0A 0000                    		at struc_menu_box.menu_header,          dw 0
 11409 00004A0C 3F                      		at struc_menu_box.menu_header_attr,     db 0x3F
 11410 00004A0D 303C                    		at struc_menu_box.menu_norm_attr,       dw 0x3C30
 11411 00004A0F 070C                    		at struc_menu_box.menu_focus_attr,      dw 0x0C07
 11412 00004A11 0000                                    at struc_menu_box.menu_area_pos,        dw 0
 11413 00004A13 0000                                    at struc_menu_box.menu_area_size,       dw 0
 11414 00004A15 3F                      		at struc_menu_box.scrollbar_attr,       db 0x3F
 11415 00004A16 10                      		at struc_menu_box.items_num,            db RECORD_MENU_ITEMS_NUMBER
 11416 00004A17 00                      		at struc_menu_box.focus_item,           db 0
 11417 00004A18 00                      		at struc_menu_box.first_visible_item,   db 0
 11418 00004A19 [5A1A]                  		at struc_menu_box.item_str_proc,        dw record_menu_item_str_proc
 11419                                  		iend
 11420                                  
 11421                                  .sys_menu       istruc struc_menu_box
 11422 00004A1B 0400                    		at struc_window.flags,                  dw WINFLAG_FRAMED
 11423 00004A1D [B14C]                  		at struc_window.title,                  dw str_idx.sys_menu_title
 11424 00004A1F F130                    		at struc_window.win_attr,               dw 0x30F1
 11425 00004A21 0303                    		at struc_window.win_pos,                dw 0x0303
 11426 00004A23 0014                    		at struc_window.win_size,               db 0, SYS_MENU_ITEMS_NUMBER+2
 11427 00004A25 [9A49]                  		at struc_window.parent_win,             dw .boot_menu
 11428 00004A27 0000                    		at struc_window.next_win,               dw 0
 11429 00004A29 0000                    		at struc_window.previous_win,           dw 0
 11430 00004A2B 1200                    		at struc_window.act_num,                dw SYS_MENU_ACTION_NUMBER
 11431 00004A2D [CD4A]                  		at struc_window.act_table,              dw main_action_table.sys_menu
 11432 00004A2F [1626]                  		at struc_window.default_event_handle,   dw menubox_default_event_handle
 11433 00004A31 [5029]                  		at struc_window.event_handle,           dw window_event_handle
 11434 00004A33 [D824]                  		at struc_window.draw_body_proc,         dw menubox_draw_body_proc
 11435 00004A35 0000                    		at struc_menu_box.menu_header,          dw 0
 11436 00004A37 3F                      		at struc_menu_box.menu_header_attr,     db 0x3F
 11437 00004A38 303C                    		at struc_menu_box.menu_norm_attr,       dw 0x3C30
 11438 00004A3A 070C                    		at struc_menu_box.menu_focus_attr,      dw 0x0C07
 11439 00004A3C 0000                                    at struc_menu_box.menu_area_pos,        dw 0
 11440 00004A3E 0000                                    at struc_menu_box.menu_area_size,       dw 0
 11441 00004A40 3F                      		at struc_menu_box.scrollbar_attr,       db 0x3F
 11442 00004A41 12                      		at struc_menu_box.items_num,            db SYS_MENU_ITEMS_NUMBER
 11443 00004A42 00                      		at struc_menu_box.focus_item,           db 0
 11444 00004A43 00                      		at struc_menu_box.first_visible_item,   db 0
 11445 00004A44 [5F1A]                  		at struc_menu_box.item_str_proc,        dw sys_menu_item_str_proc
 11446                                  		iend
 11447                                  
 11448                                  .end_of_windows_data:
 11449                                  
 11450                                  ;=============================================================================
 11451                                  ; Action table
 11452                                  ;=============================================================================
 11453                                  main_action_table:
 11454                                  
 11455                                  .root_window:
 11456                                  
 11457                                  .main_menu:
 11458 00004A46 08                              db  ACTFLAG_REDRAW_SCR
 11459 00004A47 003B                            dw  kbF1
 11460 00004A49 [B60D]                          dw  main_show_help
 11461                                  
 11462 00004A4B 08                              db  ACTFLAG_REDRAW_SCR
 11463 00004A4C 005E                            dw  kbCtrlF1
 11464 00004A4E [CC0D]                          dw  main_show_about
 11465                                  
 11466 00004A50 88                              db  ACTFLAG_REDRAW_SCR | ACTFLAG_AUTH_SECURITY
 11467 00004A51 003C                            dw  kbF2
 11468 00004A53 [170E]                          dw  main_save_changes
 11469                                  
 11470 00004A55 54                              db  ACTFLAG_REDRAW_WIN | ACTFLAG_AUTH_RECORD | ACTFLAG_CHK_RECNUM
 11471 00004A56 0000                            dw  0
 11472 00004A58 [9B10]                          dw  main_boot_it
 11473                                  
 11474 00004A5A 04                              db  ACTFLAG_REDRAW_WIN
 11475 00004A5B 0000                            dw  0
 11476 00004A5D [6814]                          dw  main_boot_prev_in_menu
 11477                                  
 11478 00004A5F 00                              db  0
 11479 00004A60 0000                            dw  0
 11480 00004A62 0000                            dw  0
 11481                                  
 11482 00004A64 08                              db  ACTFLAG_REDRAW_SCR
 11483 00004A65 0013                            dw  kbAltR
 11484 00004A67 [E90D]                          dw  main_show_record_menu
 11485                                  
 11486 00004A69 08                              db  ACTFLAG_REDRAW_SCR
 11487 00004A6A 001F                            dw  kbAltS
 11488 00004A6C [F00D]                          dw  main_show_sys_menu
 11489                                  
 11490 00004A6E 00                              db  0
 11491 00004A6F 0000                            dw  0
 11492 00004A71 0000                            dw  0
 11493                                  
 11494 00004A73 24                              db  ACTFLAG_REDRAW_WIN | ACTFLAG_AUTH_ROOT
 11495 00004A74 1110                            dw  kbCtrlQ
 11496 00004A76 [C610]                          dw  main_return_to_bios
 11497                                  
 11498 00004A78 00                              db  0
 11499 00004A79 008A                            dw  kbCtrlF12
 11500 00004A7B [4514]                          dw  main_power_off
 11501                                  
 11502                                  .end_of_main_menu
 11503                                  
 11504                                  .record_menu:
 11505 00004A7D 04                              db  ACTFLAG_REDRAW_WIN
 11506 00004A7E 2F35                            dw  kbSlash
 11507 00004A80 [5013]                          dw  main_show_record_info
 11508                                  
 11509 00004A82 D8                              db  ACTFLAG_REDRAW_SCR | ACTFLAG_CHK_RECNUM | ACTFLAG_AUTH_SECURITY | ACTFLAG_AUTH_RECORD
 11510 00004A83 003D                            dw  kbF3
 11511 00004A85 [2D0E]                          dw  main_change_name
 11512                                  
 11513 00004A87 D8                              db  ACTFLAG_REDRAW_SCR | ACTFLAG_CHK_RECNUM | ACTFLAG_AUTH_SECURITY | ACTFLAG_AUTH_RECORD
 11514 00004A88 0043                            dw  kbF9
 11515 00004A8A [B50E]                          dw  main_change_record_password
 11516                                  
 11517 00004A8C D8                              db  ACTFLAG_REDRAW_SCR | ACTFLAG_CHK_RECNUM | ACTFLAG_AUTH_SECURITY | ACTFLAG_AUTH_RECORD
 11518 00004A8D 131F                            dw  kbCtrlS
 11519 00004A8F [9711]                          dw  main_toggle_schedule
 11520                                  
 11521 00004A91 D8                              db  ACTFLAG_REDRAW_SCR | ACTFLAG_CHK_RECNUM | ACTFLAG_AUTH_SECURITY | ACTFLAG_AUTH_RECORD
 11522 00004A92 0B25                            dw  kbCtrlK
 11523 00004A94 [6512]                          dw  main_toggle_keystrokes
 11524                                  
 11525 00004A96 00                              db  0
 11526 00004A97 0000                            dw  0
 11527 00004A99 0000                            dw  0
 11528                                  
 11529 00004A9B 08                              db  ACTFLAG_REDRAW_SCR 
 11530 00004A9C 003E                            dw  kbF4
 11531 00004A9E [3E0F]                          dw  main_mark_active
 11532                                  
 11533 00004AA0 08                              db  ACTFLAG_REDRAW_SCR
 11534 00004AA1 003F                            dw  kbF5
 11535 00004AA3 [960F]                          dw  main_toggle_hidden
 11536                                  
 11537 00004AA5 08                              db  ACTFLAG_REDRAW_SCR
 11538 00004AA6 0040                            dw  kbF6
 11539 00004AA8 [120F]                          dw  main_toggle_auto_active
 11540                                  
 11541 00004AAA 08                              db  ACTFLAG_REDRAW_SCR
 11542 00004AAB 0041                            dw  kbF7
 11543 00004AAD [280F]                          dw  main_toggle_auto_hide
 11544                                  
 11545 00004AAF 08                              db  ACTFLAG_REDRAW_SCR
 11546 00004AB0 182D                            dw  kbCtrlX
 11547 00004AB2 [7911]                          dw  main_toggle_swapid
 11548                                  
 11549 00004AB4 00                              db  0
 11550 00004AB5 0000                            dw  0
 11551 00004AB7 0000                            dw  0
 11552                                  
 11553 00004AB9 D8                              db  ACTFLAG_REDRAW_SCR | ACTFLAG_CHK_RECNUM | ACTFLAG_AUTH_SECURITY | ACTFLAG_AUTH_RECORD
 11554 00004ABA 0420                            dw  kbCtrlD
 11555 00004ABC [BE0F]                          dw  main_delete_record
 11556                                  
 11557 00004ABE D8                              db  ACTFLAG_REDRAW_SCR | ACTFLAG_CHK_RECNUM | ACTFLAG_AUTH_SECURITY | ACTFLAG_AUTH_RECORD
 11558 00004ABF 1019                            dw  kbCtrlP
 11559 00004AC1 [D210]                          dw  main_dup_record
 11560                                  
 11561 00004AC3 98                              db  ACTFLAG_REDRAW_SCR | ACTFLAG_CHK_RECNUM | ACTFLAG_AUTH_SECURITY
 11562 00004AC4 1516                            dw  kbCtrlU
 11563 00004AC6 [2711]                          dw  main_move_record_up
 11564                                  
 11565 00004AC8 98                              db  ACTFLAG_REDRAW_SCR | ACTFLAG_CHK_RECNUM | ACTFLAG_AUTH_SECURITY
 11566 00004AC9 0E31                            dw  kbCtrlN
 11567 00004ACB [F510]                          dw  main_move_record_down
 11568                                  
 11569                                  
 11570                                  .end_of_record_menu
 11571                                  
 11572                                  .sys_menu:
 11573 00004ACD 28                              db  ACTFLAG_REDRAW_SCR | ACTFLAG_AUTH_ROOT
 11574 00004ACE 0044                            dw  kbF10
 11575 00004AD0 [680E]                          dw  main_change_root_password
 11576                                  
 11577 00004AD2 A8                              db  ACTFLAG_REDRAW_SCR | ACTFLAG_AUTH_ROOT | ACTFLAG_AUTH_SECURITY
 11578 00004AD3 0067                            dw  kbCtrlF10
 11579 00004AD5 [520E]                          dw  main_login_as_root
 11580                                  
 11581 00004AD7 88                              db  ACTFLAG_REDRAW_SCR | ACTFLAG_AUTH_SECURITY
 11582 00004AD8 0071                            dw  kbAltF10
 11583 00004ADA [5E0E]                          dw  main_change_security_mode
 11584                                  
 11585 00004ADC 00                              db  0
 11586 00004ADD 0000                            dw  0
 11587 00004ADF 0000                            dw  0
 11588                                  
 11589 00004AE1 28                              db  ACTFLAG_REDRAW_SCR | ACTFLAG_AUTH_ROOT
 11590 00004AE2 0042                            dw  kbF8
 11591 00004AE4 [F80E]                          dw  main_set_default_record
 11592                                  
 11593 00004AE6 28                              db  ACTFLAG_REDRAW_SCR | ACTFLAG_AUTH_ROOT
 11594 00004AE7 005B                            dw  kbShiftF8
 11595 00004AE9 [080F]                          dw  main_unset_default_record
 11596                                  
 11597 00004AEB 28                              db  ACTFLAG_REDRAW_SCR | ACTFLAG_AUTH_ROOT
 11598 00004AEC 1414                            dw  kbCtrlT
 11599 00004AEE [6B10]                          dw  main_set_delay_time
 11600                                  
 11601 00004AF0 08                              db  ACTFLAG_REDRAW_SCR
 11602 00004AF1 0621                            dw  kbCtrlF
 11603 00004AF3 [4814]                          dw  main_change_bootmenu_style
 11604                                  
 11605 00004AF5 28                              db  ACTFLAG_REDRAW_SCR | ACTFLAG_AUTH_ROOT
 11606 00004AF6 0C26                            dw  kbCtrlL
 11607 00004AF8 [5E14]                          dw  main_toggle_rem_last
 11608                                  
 11609 00004AFA 28                              db  ACTFLAG_REDRAW_SCR | ACTFLAG_AUTH_ROOT
 11610 00004AFB 0000                            dw  0
 11611 00004AFD [EA15]                          dw  main_toggle_int13ext
 11612                                  
 11613 00004AFF 00                              db  0
 11614 00004B00 0000                            dw  0
 11615 00004B02 0000                            dw  0
 11616                                  
 11617 00004B04 28                              db  ACTFLAG_REDRAW_SCR | ACTFLAG_AUTH_ROOT
 11618 00004B05 0917                            dw  kbCtrlI
 11619 00004B07 [1010]                          dw  main_rescan_all_records
 11620                                  
 11621 00004B09 28                              db  ACTFLAG_REDRAW_SCR | ACTFLAG_AUTH_ROOT
 11622 00004B0A 0823                            dw  kbCtrlH
 11623 00004B0C [1710]                          dw  main_rescan_all_partitions
 11624                                  
 11625 00004B0E 08                              db  ACTFLAG_REDRAW_SCR
 11626 00004B0F 0000                            dw  0
 11627 00004B11 [0716]                          dw  main_set_cdrom_ioports
 11628                                  
 11629 00004B13 28                              db  ACTFLAG_REDRAW_SCR | ACTFLAG_AUTH_ROOT
 11630 00004B14 0000                            dw  0
 11631 00004B16 [7F16]                          dw  main_set_y2k_year
 11632                                  
 11633 00004B18 00                              db  0
 11634 00004B19 0000                            dw  0
 11635 00004B1B 0000                            dw  0
 11636                                  
 11637 00004B1D 08                              db  ACTFLAG_REDRAW_SCR
 11638 00004B1E 0000                            dw  0
 11639 00004B20 [7614]                          dw  main_install_sbm
 11640                                  
 11641 00004B22 28                              db  ACTFLAG_REDRAW_SCR | ACTFLAG_AUTH_ROOT
 11642 00004B23 0000                            dw  0
 11643 00004B25 [6715]                          dw  main_uninstall_sbm
 11644                                  
 11645                                  .end_of_sys_menu
 11646                                  
 11647 00004B27 08                              db  ACTFLAG_REDRAW_SCR
 11648 00004B28 01F4                            dw  EVENT_REDRAW_ROOT
 11649 00004B2A 0000                            dw  0
 11650                                  
 11651 00004B2C 18                              db  ACTFLAG_REDRAW_SCR | ACTFLAG_CHK_RECNUM
 11652 00004B2D 02F4                            dw  EVENT_BOOT_DEFAULT
 11653 00004B2F [171C]                          dw  main_boot_default
 11654                                  
 11655                                  .end_of_root_window
 11656                                          
 11657                                  .boot_menu:
 11658 00004B31 08                              db  ACTFLAG_REDRAW_SCR
 11659 00004B32 0098                            dw  kbEnhAltUp
 11660 00004B34 [B625]                          dw  menubox_focus_up
 11661                                  
 11662 00004B36 08                              db  ACTFLAG_REDRAW_SCR
 11663 00004B37 00A0                            dw  kbEnhAltDown
 11664 00004B39 [E225]                          dw  menubox_focus_down
 11665                                  
 11666 00004B3B 04                              db  ACTFLAG_REDRAW_WIN
 11667 00004B3C 3F35                            dw  kbQuestion
 11668 00004B3E [5013]                          dw  main_show_record_info
 11669                                  
 11670 00004B40 D4                              db  ACTFLAG_REDRAW_WIN | ACTFLAG_CHK_RECNUM | ACTFLAG_AUTH_SECURITY | ACTFLAG_AUTH_RECORD
 11671 00004B41 003D                            dw  kbF3
 11672 00004B43 [2D0E]                          dw  main_change_name
 11673                                  
 11674 00004B45 D4                              db  ACTFLAG_REDRAW_WIN | ACTFLAG_CHK_RECNUM | ACTFLAG_AUTH_SECURITY | ACTFLAG_AUTH_RECORD
 11675 00004B46 0043                            dw  kbF9
 11676 00004B48 [B50E]                          dw  main_change_record_password
 11677                                  
 11678 00004B4A D4                              db  ACTFLAG_REDRAW_WIN | ACTFLAG_CHK_RECNUM | ACTFLAG_AUTH_SECURITY | ACTFLAG_AUTH_RECORD
 11679 00004B4B 131F                            dw  kbCtrlS
 11680 00004B4D [9711]                          dw  main_toggle_schedule
 11681                                  
 11682 00004B4F D4                              db  ACTFLAG_REDRAW_WIN | ACTFLAG_CHK_RECNUM | ACTFLAG_AUTH_SECURITY | ACTFLAG_AUTH_RECORD
 11683 00004B50 0B25                            dw  kbCtrlK
 11684 00004B52 [6512]                          dw  main_toggle_keystrokes
 11685                                  
 11686 00004B54 D2                              db  ACTFLAG_REDRAW_BODY | ACTFLAG_CHK_RECNUM | ACTFLAG_AUTH_SECURITY | ACTFLAG_AUTH_RECORD
 11687 00004B55 003E                            dw  kbF4
 11688 00004B57 [3E0F]                          dw  main_mark_active
 11689                                  
 11690 00004B59 D2                              db  ACTFLAG_REDRAW_BODY | ACTFLAG_CHK_RECNUM | ACTFLAG_AUTH_SECURITY | ACTFLAG_AUTH_RECORD
 11691 00004B5A 003F                            dw  kbF5
 11692 00004B5C [960F]                          dw  main_toggle_hidden
 11693                                  
 11694 00004B5E D2                              db  ACTFLAG_REDRAW_BODY | ACTFLAG_CHK_RECNUM | ACTFLAG_AUTH_SECURITY | ACTFLAG_AUTH_RECORD
 11695 00004B5F 0040                            dw  kbF6
 11696 00004B61 [120F]                          dw  main_toggle_auto_active
 11697                                  
 11698 00004B63 D2                              db  ACTFLAG_REDRAW_BODY | ACTFLAG_CHK_RECNUM | ACTFLAG_AUTH_SECURITY | ACTFLAG_AUTH_RECORD
 11699 00004B64 0041                            dw  kbF7
 11700 00004B66 [280F]                          dw  main_toggle_auto_hide
 11701                                  
 11702 00004B68 D2                              db  ACTFLAG_REDRAW_BODY | ACTFLAG_CHK_RECNUM | ACTFLAG_AUTH_SECURITY | ACTFLAG_AUTH_RECORD
 11703 00004B69 182D                            dw  kbCtrlX
 11704 00004B6B [7911]                          dw  main_toggle_swapid
 11705                                  
 11706 00004B6D D2                              db  ACTFLAG_REDRAW_BODY | ACTFLAG_CHK_RECNUM | ACTFLAG_AUTH_SECURITY | ACTFLAG_AUTH_RECORD
 11707 00004B6E 0420                            dw  kbCtrlD
 11708 00004B70 [BE0F]                          dw  main_delete_record
 11709                                  
 11710 00004B72 D2                              db  ACTFLAG_REDRAW_BODY | ACTFLAG_CHK_RECNUM | ACTFLAG_AUTH_SECURITY | ACTFLAG_AUTH_RECORD
 11711 00004B73 1019                            dw  kbCtrlP
 11712 00004B75 [D210]                          dw  main_dup_record
 11713                                  
 11714 00004B77 02                              db  ACTFLAG_REDRAW_BODY
 11715 00004B78 1516                            dw  kbCtrlU
 11716 00004B7A [2711]                          dw  main_move_record_up
 11717                                  
 11718 00004B7C 02                              db  ACTFLAG_REDRAW_BODY
 11719 00004B7D 0E31                            dw  kbCtrlN
 11720 00004B7F [F510]                          dw  main_move_record_down
 11721                                  
 11722 00004B81 54                              db  ACTFLAG_REDRAW_WIN | ACTFLAG_AUTH_RECORD | ACTFLAG_CHK_RECNUM
 11723 00004B82 0D1C                            dw  kbEnter
 11724 00004B84 [9B10]                          dw  main_boot_it
 11725                                  
 11726 00004B86 14                              db  ACTFLAG_REDRAW_WIN | ACTFLAG_CHK_RECNUM
 11727 00004B87 1B01                            dw  kbEsc
 11728 00004B89 [171C]                          dw  main_boot_default
 11729                                  
 11730 00004B8B 08                              db  ACTFLAG_REDRAW_SCR
 11731 00004B8C 08F2                            dw  EVENT_ALT_RELEASE
 11732 00004B8E [E20D]                          dw  main_show_main_menu
 11733                                  .end_of_boot_menu
 11734                                  
 11735                                  ;END OF KERNEL
 11736 00004B90 55AA                            dw BR_GOOD_FLAG
 11737                                  
 11738                                  end_of_kernel:
 11739                                  ;=============================================================================
 11740                                  ;theme data
 11741                                  ;=============================================================================
 11742                                  theme_start:
 11743                                  
 11744                                  
 11745                                  %ifdef THEME_ZH
 11746                                  %include "themes/theme-zh.asm"
 11747                                  %elifdef THEME_DE
 11748                                  %include "themes/theme-de.asm"
 11749                                  %elifdef THEME_HU
 11750                                  %include "themes/theme-hu.asm"
 11751                                  %elifdef THEME_RU
 11752                                  %include "themes/theme-ru.asm"
 11753                                  %elifdef THEME_CZ
 11754                                  %include "themes/theme-cz.asm"
 11755                                  %elifdef THEME_ES
 11756                                  %include "themes/theme-es.asm"
 11757                                  %elifdef THEME_FR
 11758                                  %include "themes/theme-fr.asm"
 11759                                  %elifdef THEME_PT
 11760                                  %include "themes/theme-pt.asm"
 11761                                  %else
 11762                                  %include "themes/theme-us.asm"
 11763                              <1> ; asmsyntax=nasm
 11764                              <1> ;
 11765                              <1> ; theme-us.asm
 11766                              <1> ;
 11767                              <1> ; English theme data for Smart Boot Manager
 11768                              <1> ;
 11769                              <1> ; Copyright (C) 2001, Suzhe. See file COPYING for details.
 11770                              <1> ;
 11771                              <1> 
 11772                              <1> ; some constant used in this theme.
 11773                              <1> 
 11774                              <1> ; PLEASE DO NOT CHANGE THESE, UNLESS YOU KNOW WHAT YOU ARE DOING!
 11775                              <1> %define SBMT_MAGIC      0x544D4253         ; magic number of
 11776                              <1>                                            ; Smart Boot Manager theme.
 11777                              <1> %define SBMT_VERSION    0x035A             ; version of theme ( 3.90 ).
 11778                              <1> 
 11779                              <1> start_font              equ     219
 11780                              <1> brand_char1             equ     start_font
 11781                              <1> brand_char2             equ     start_font+1
 11782                              <1> brand_char3             equ     start_font+2
 11783                              <1> brand_char4             equ     start_font+3
 11784                              <1> 
 11785                              <1>         bits 16
 11786                              <1> 
 11787                              <1> %ifndef MAIN
 11788                              <1>         org 0                       ; DO NOT REMOVE/MODIFY THIS LINE!!!
 11789                              <1> %endif
 11790                              <1> 
 11791                              <1> start_of_theme:
 11792                              <1> 
 11793                              <1> ;!!! PLEASE DON NOT CHANGE THE SIZE AND ORDER OF FOLLOWING DATA !!!
 11794                              <1> 
 11795                              <1> ;=============================================================================
 11796                              <1> ;the header of Smart Boot Manager theme ( 16 bytes )
 11797                              <1> ;=============================================================================
 11798 00004B92 53424D54            <1> theme_magic             dd  SBMT_MAGIC ; magic number = 'SBMT', 4 bytes.
 11799                              <1>                                        ; it's abbr. of 'Smart Boot Manager Theme'
 11800 00004B96 0000                <1>                         dw  0          ;
 11801 00004B98 656E2D555300        <1> theme_lang              db  'en-US',0  ; language of this theme, 6 bytes.
 11802 00004B9E 5A03                <1> theme_version           dw  SBMT_VERSION ; version, high byte is major version,
 11803                              <1>                                          ; low byte is minor version. should be
 11804                              <1>                                          ; equal to the version of Smart Boot Manager.
 11805 00004BA0 AA0F                <1> theme_size              dw  (end_of_theme - start_of_theme)
 11806                              <1>                                          ; size of the theme (bytes).
 11807                              <1> 
 11808                              <1> ;=============================================================================
 11809                              <1> ; fix size data and index tables of variable size data
 11810                              <1> ;=============================================================================
 11811                              <1> 
 11812 00004BA2 FF                  <1> video_mode              db  0xff        ; 0 = 90x25, 0xff = 80x25
 11813                              <1>                                         ; do not use other value!!!
 11814                              <1> 
 11815 00004BA3 10                  <1> keyboard_type           db  0x10        ; = 0x10 means use enhanced keyboard
 11816                              <1>                                         ; = 0x00 means use normal keyboard
 11817                              <1>                                         ; CAUTION: cannot use other value!!!
 11818                              <1> 
 11819 00004BA4 01                  <1> show_date_method        db  1           ; the method of show date:
 11820                              <1>                                         ; 0 = don't show date
 11821                              <1>                                         ; 1 = day mm-dd-yyyy
 11822                              <1>                                         ; 2 = day yyyy-mm-dd
 11823                              <1>                                         ; 3 = day dd-mm-yyyy
 11824                              <1> 
 11825 00004BA5 01                  <1> show_time_method        db  1           ; the method of show time:
 11826                              <1>                                         ; 0 = don't show time
 11827                              <1>                                         ; 1 = hh:mm (24 hours)
 11828                              <1> 
 11829 00004BA6 79                  <1> yes_key_lower	        db  'y'
 11830 00004BA7 59                  <1> yes_key_upper	        db  'Y'
 11831                              <1>  
 11832                              <1> ; position of screen elements, low byte = column, high byte = row
 11833                              <1> position:
 11834 00004BA8 FF00                <1> .brand                  dw  0x00FF      ; start position of brand icon
 11835                              <1>                                         ; low = column, high = row
 11836                              <1>                                         ; if low = 255 then brand will be
 11837                              <1>                                         ; right justify in the screen.
 11838 00004BAA 3700                <1> .date                   dw  0x0037
 11839                              <1> 
 11840 00004BAC 4600                <1> .time                   dw  0x0046
 11841                              <1> 
 11842                              <1> ; size of screen elements
 11843                              <1> size:
 11844 00004BAE 01                  <1> .copyright              db  1           ; number of rows used by copyright info
 11845 00004BAF 01                  <1> .hint                   db  1           ; number of rows used by hint info
 11846 00004BB0 05                  <1> .box_width              db  5           ; the minimal width of info/error/input box
 11847                              <1>                                         ; (when no info string)
 11848 00004BB1 04                  <1> .box_height             db  4           ; the minimal height of info/error/input box
 11849                              <1>                                         ; (when no info string)
 11850 00004BB2 0D                  <1> .boot_menu_win_height   db  13          ; the height of the boot menu window
 11851 00004BB3 0A                  <1> .list_box_win_height    db  10          ; the height of the list box window
 11852                              <1> 
 11853                              <1> ;Black          = 0
 11854                              <1> ;Blue           = 1
 11855                              <1> ;Green          = 2
 11856                              <1> ;Cyan           = 3
 11857                              <1> ;Red            = 4
 11858                              <1> ;Violet         = 5
 11859                              <1> ;Yellow (brown) = 6
 11860                              <1> ;White          = 7
 11861                              <1> ;Black (gray)   = 8
 11862                              <1> ;Intense blue   = 9
 11863                              <1> ;Intense green  = a
 11864                              <1> ;Intense cyan   = b
 11865                              <1> ;Intense red    = c
 11866                              <1> ;Intense violet = d
 11867                              <1> ;Intense yellow = e
 11868                              <1> ;Intense white  = f
 11869                              <1> 
 11870                              <1> ; color of screen elements
 11871                              <1> ; high 4 bits is background color, low 4 bits is foreground color
 11872                              <1> 
 11873                              <1> color:
 11874 00004BB4 70                  <1> .win_title_inactive     db  0x70        ; title attribute for inactive window.
 11875                              <1> 
 11876                              <1> .boot_menu:
 11877 00004BB5 3F                  <1> .boot_menu_frame        db  0x3F        ; attributes of boot menu window
 11878 00004BB6 F1                  <1> .boot_menu_title        db  0xF1        ;
 11879 00004BB7 1F                  <1> .boot_menu_header       db  0x1F        ;
 11880 00004BB8 707C                <1> .boot_menu_normal       dw  0x7C70      ;
 11881 00004BBA 0F0C                <1> .boot_menu_focus        dw  0x0C0F      ; 
 11882 00004BBC 3F                  <1> .boot_menu_scrollbar    db  0x3F        ; scroll bar
 11883                              <1> 
 11884                              <1> .cmd_menu:
 11885 00004BBD 30                  <1> .cmd_menu_frame         db  0x30        ;
 11886 00004BBE F1                  <1> .cmd_menu_title         db  0xF1        ; the colors used 
 11887 00004BBF 3F                  <1> .cmd_menu_header        db  0x3F        ;
 11888 00004BC0 303C                <1> .cmd_menu_normal        dw  0x3C30      ; in command menu
 11889 00004BC2 070C                <1> .cmd_menu_focus         dw  0x0C07      ;
 11890 00004BC4 3F                  <1> .cmd_menu_scrollbar     db  0x3F        ;
 11891                              <1> 
 11892                              <1> .list_box:
 11893 00004BC5 30                  <1> .list_box_frame         db  0x30        ;
 11894 00004BC6 F1                  <1> .list_box_title         db  0xF1        ; list box
 11895 00004BC7 1F                  <1> .list_box_header        db  0x1F        ;
 11896 00004BC8 303C                <1> .list_box_normal        dw  0x3C30      ;
 11897 00004BCA 070C                <1> .list_box_focus         dw  0x0C07      ;
 11898 00004BCC 3F                  <1> .list_box_scrollbar     db  0x3F        ;
 11899                              <1> 
 11900                              <1> .input_box:
 11901 00004BCD B0                  <1> .input_box_frame        db  0xB0        ;
 11902 00004BCE F1                  <1> .input_box_title        db  0xF1        ; input box
 11903 00004BCF B0                  <1> .input_box_msg          db  0xB0        ;
 11904                              <1> 
 11905                              <1> .error_box:
 11906 00004BD0 CF                  <1> .error_box_frame        db  0xCF        ;
 11907 00004BD1 F1                  <1> .error_box_title        db  0xF1        ; error box
 11908 00004BD2 CF                  <1> .error_box_msg          db  0xCF        ;
 11909                              <1> 
 11910                              <1> .info_box:
 11911 00004BD3 B0                  <1> .info_box_frame         db  0xB0        ;
 11912 00004BD4 F1                  <1> .info_box_title         db  0xF1        ; info box
 11913 00004BD5 B0                  <1> .info_box_msg           db  0xB0        ;
 11914                              <1> 
 11915                              <1> .help_win:
 11916 00004BD6 3F                  <1> .help_win_frame         db  0x3F        ;
 11917 00004BD7 F1                  <1> .help_win_title         db  0xF1        ; help window
 11918 00004BD8 30                  <1> .help_msg               db  0x30        ;
 11919                              <1> 
 11920                              <1> .about_win:
 11921 00004BD9 3F                  <1> .about_win_frame        db  0x3F        ;
 11922 00004BDA F1                  <1> .about_win_title        db  0xF1        ; about window
 11923 00004BDB 3E                  <1> .about_msg              db  0x3E        ;
 11924                              <1> 
 11925 00004BDC 70                  <1> .delay_time             db  0x70        ; delay time
 11926 00004BDD 00                  <1> .background             db  0x00        ; background (if no background icon)
 11927 00004BDE 7074                <1> .copyright              dw  0x7470      ; copyright string
 11928 00004BE0 7074                <1> .hint                   dw  0x7470      ; hint string
 11929 00004BE2 7C                  <1> .knl_flags              db  0x7C        ; the color of kernal fags.
 11930 00004BE3 70                  <1> .knl_drvid              db  0x70        ; the color of kernel drive id.
 11931 00004BE4 70                  <1> .date                   db  0x70        ; color of date string
 11932 00004BE5 70                  <1> .time                   db  0x70        ; color of time string
 11933                              <1> 
 11934                              <1> ; icon data
 11935                              <1> icon:
 11936 00004BE6 0401                <1> .brand_size         dw  0x0104              ; the size of brand icon,
 11937                              <1>                                             ; high byte = row, low byte = col.
 11938 00004BE8 [EF4C]              <1> .brand              dw  icon_data.brand     ; offset of brand icon data, set to
 11939                              <1>                                             ; zero if no brand icon.
 11940                              <1> 
 11941 00004BEA 0401                <1> .background_size    dw  0x0104              ; the size of background icon,
 11942                              <1>                                             ; high byte = row, low byte = col.
 11943 00004BEC [F74C]              <1> .background         dw  icon_data.background; offset of background icon data,
 11944                              <1>                                             ; set to zero if no background icon.
 11945                              <1> 
 11946                              <1> ; font data
 11947                              <1> font:
 11948 00004BEE 0400                <1> .number             dw  (font_data.end-font_data)/17
 11949                              <1>                                             ; number of chars to be replaced,
 11950                              <1>                                             ; should <= (256 - start).
 11951 00004BF0 [FF4C]              <1> .data               dw  font_data           ; offset of font set data, set to
 11952                              <1>                                             ; zero if no font to be replaced.
 11953                              <1> 
 11954                              <1> ; chars used by window frame
 11955                              <1> frame_char:
 11956 00004BF2 20                  <1> .top                db     0x20            ; top horizontal
 11957 00004BF3 CD                  <1> .bottom             db     0xCD            ; bottom horiztontal
 11958 00004BF4 BA                  <1> .left               db     0xBA            ; left vertical
 11959 00004BF5 BA                  <1> .right              db     0xBA            ; right vertical
 11960 00004BF6 C9                  <1> .tl_corner          db     0xC9            ; top left corner
 11961 00004BF7 BB                  <1> .tr_corner          db     0xBB            ; top right corner
 11962 00004BF8 C8                  <1> .bl_corner          db     0xC8            ; bottom left corner
 11963 00004BF9 BC                  <1> .br_corner          db     0xBC            ; bottom right corner
 11964                              <1> 
 11965                              <1> ; how to draw window frame
 11966 00004BFA 01                  <1> draw_frame_method   db  1          ; = 0 means draw all frame using frame attr.
 11967                              <1>                                    ; = 1 means draw top horizontal line using
 11968                              <1>                                    ;     title attr.
 11969                              <1>                                    ; = 2 means draw top corner and horizontal
 11970                              <1>                                    ;     line using title attr.
 11971                              <1> 
 11972                              <1> ; keymap data
 11973                              <1> keymap:                                  ; entry of keymap
 11974 00004BFB 0000                <1> .number             dw  (keymap_data.end-keymap_data)/4
 11975                              <1>                                            ; number of keymap entries
 11976 00004BFD [434D]              <1> .data               dw  keymap_data      ; pointer to keymap
 11977                              <1> 
 11978                              <1> ; index table of strings
 11979                              <1> str_idx:
 11980 00004BFF [434D]              <1> .boot_menu_title                dw  string.boot_menu_title
 11981 00004C01 [4D4D]              <1> .boot_menu_header               dw  string.boot_menu_header
 11982 00004C03 [594D]              <1> .boot_menu_header_noflags       dw  string.boot_menu_header_noflags
 11983 00004C05 [614D]              <1> .boot_menu_header_nonumber      dw  string.boot_menu_header_nonumber
 11984 00004C07 [6A4D]              <1> .boot_menu_header_notype        dw  string.boot_menu_header_notype
 11985                              <1> 
 11986 00004C09 [714D]              <1> .about              dw  string.about
 11987 00004C0B [774D]              <1> .error              dw  string.error
 11988 00004C0D [7D4D]              <1> .help               dw  string.help
 11989 00004C0F [824D]              <1> .info               dw  string.info
 11990 00004C11 [8D4D]              <1> .input              dw  string.input
 11991                              <1> 
 11992 00004C13 [934D]              <1> .delay_time         dw  string.delay_time
 11993 00004C15 [A04D]              <1> .name               dw  string.name
 11994 00004C17 [A74D]              <1> .new_root_passwd    dw  string.new_root_passwd
 11995 00004C19 [AB4D]              <1> .root_passwd        dw  string.root_passwd
 11996 00004C1B [BB4D]              <1> .new_record_passwd  dw  string.new_record_passwd
 11997 00004C1D [BF4D]              <1> .record_passwd      dw  string.record_passwd
 11998 00004C1F [D14D]              <1> .retype_passwd      dw  string.retype_passwd
 11999 00004C21 [E34D]              <1> .input_schedule     dw  string.input_schedule
 12000 00004C23 [014E]              <1> .input_keystrokes   dw  string.input_keystrokes
 12001 00004C25 [4D4E]              <1> .key_count          dw  string.key_count
 12002 00004C27 [5B4E]              <1> .io_port            dw  string.io_port
 12003 00004C29 [784E]              <1> .year               dw  string.year
 12004                              <1> 
 12005 00004C2B [7F4E]              <1> .drive_id           dw  string.drive_id
 12006 00004C2D [8D4E]              <1> .part_id            dw  string.part_id
 12007 00004C2F [9A4E]              <1> .record_type        dw  string.record_type
 12008 00004C31 [A94E]              <1> .record_name        dw  string.record_name
 12009 00004C33 [B84E]              <1> .auto_active        dw  string.auto_active
 12010 00004C35 [C84E]              <1> .active             dw  string.active
 12011 00004C37 [D54E]              <1> .auto_hide          dw  string.auto_hide
 12012 00004C39 [E44E]              <1> .hidden             dw  string.hidden
 12013 00004C3B [F14E]              <1> .swap_drv           dw  string.swap_drv
 12014 00004C3D [004F]              <1> .logical            dw  string.logical
 12015 00004C3F [0D4F]              <1> .key_strokes        dw  string.key_strokes
 12016 00004C41 [1D4F]              <1> .password           dw  string.password
 12017 00004C43 [2A4F]              <1> .schedule           dw  string.schedule
 12018 00004C45 [394F]              <1> .yes                dw  string.yes
 12019 00004C47 [3D4F]              <1> .no                 dw  string.no
 12020                              <1> 
 12021 00004C49 [414F]              <1> .copyright          dw  string.copyright
 12022 00004C4B [774F]              <1> .hint               dw  string.hint
 12023 00004C4D [BE4F]              <1> .about_content      dw  string.about_content
 12024 00004C4F [C750]              <1> .help_content       dw  string.help_content
 12025                              <1> 
 12026 00004C51 [5954]              <1> .changes_saved      dw  string.changes_saved
 12027 00004C53 [6854]              <1> .passwd_changed     dw  string.passwd_changed
 12028 00004C55 [7A54]              <1> .ask_save_changes   dw  string.ask_save_changes
 12029                              <1> 
 12030 00004C57 [9254]              <1> .wrong_passwd       dw  string.wrong_passwd
 12031 00004C59 [A254]              <1> .disk_error         dw  string.disk_error
 12032 00004C5B [B154]              <1> .mark_act_failed    dw  string.mark_act_failed
 12033 00004C5D [C554]              <1> .toggle_hid_failed  dw  string.toggle_hid_failed
 12034 00004C5F [D954]              <1> .no_system          dw  string.no_system
 12035 00004C61 [0C55]              <1> .invalid_record     dw  string.invalid_record
 12036 00004C63 [2155]              <1> .invalid_schedule   dw  string.invalid_schedule
 12037 00004C65 [3855]              <1> .inst_confirm       dw  string.inst_confirm
 12038 00004C67 [6755]              <1> .inst_ok            dw  string.inst_ok
 12039 00004C69 [8355]              <1> .inst_abort         dw  string.inst_abort
 12040 00004C6B [9B55]              <1> .uninst_confirm     dw  string.uninst_confirm
 12041 00004C6D [C155]              <1> .uninst_ok          dw  string.uninst_ok
 12042 00004C6F [FB55]              <1> .uninst_abort       dw  string.uninst_abort
 12043 00004C71 [1556]              <1> .confirm            dw  string.confirm
 12044 00004C73 [3E56]              <1> .no_sbml            dw  string.no_sbml
 12045 00004C75 [7656]              <1> .invalid_ioports    dw  string.invalid_ioports
 12046                              <1> 
 12047                              <1> ; command menu str_idx
 12048                              <1> ; main menu
 12049 00004C77 [8956]              <1> .main_menu_title    dw string.main_menu_title
 12050                              <1> .main_menu_strings:
 12051 00004C79 [9356]              <1>                     dw string.main_menu_help
 12052 00004C7B [A956]              <1>                     dw string.main_menu_about
 12053 00004C7D [2D57]              <1>                     dw string.main_menu_save
 12054 00004C7F [BF56]              <1>                     dw string.main_menu_bootit
 12055 00004C81 [C756]              <1>                     dw string.main_menu_bootprev
 12056 00004C83 [4357]              <1>                     dw string.main_menu_bar
 12057 00004C85 [0557]              <1>                     dw string.main_menu_recordset
 12058 00004C87 [1957]              <1>                     dw string.main_menu_sysset
 12059 00004C89 [4357]              <1>                     dw string.main_menu_bar
 12060 00004C8B [D956]              <1>                     dw string.main_menu_quit
 12061 00004C8D [EF56]              <1>                     dw string.main_menu_poweroff
 12062                              <1> 
 12063                              <1> ; record settings menu
 12064 00004C8F [5757]              <1> .record_menu_title  dw string.record_menu_title
 12065                              <1> .record_menu_strings:
 12066 00004C91 [6757]              <1>                     dw string.record_menu_info
 12067 00004C93 [8057]              <1>                     dw string.record_menu_name
 12068 00004C95 [9957]              <1>                     dw string.record_menu_passwd
 12069 00004C97 [B257]              <1>                     dw string.record_menu_schedule
 12070 00004C99 [CB57]              <1>                     dw string.record_menu_keys
 12071 00004C9B [C558]              <1>                     dw string.record_menu_bar
 12072 00004C9D [E457]              <1>                     dw string.record_menu_act
 12073 00004C9F [FD57]              <1>                     dw string.record_menu_hide
 12074 00004CA1 [1658]              <1>                     dw string.record_menu_autoact
 12075 00004CA3 [2F58]              <1>                     dw string.record_menu_autohide
 12076 00004CA5 [4858]              <1>                     dw string.record_menu_swapdrv
 12077 00004CA7 [C558]              <1>                     dw string.record_menu_bar
 12078 00004CA9 [6158]              <1>                     dw string.record_menu_del
 12079 00004CAB [7A58]              <1>                     dw string.record_menu_dup
 12080 00004CAD [9358]              <1>                     dw string.record_menu_moveup
 12081 00004CAF [AC58]              <1>                     dw string.record_menu_movedown
 12082                              <1> 
 12083                              <1> ; system setting menu
 12084 00004CB1 [DC58]              <1> .sys_menu_title     dw string.sys_menu_title
 12085                              <1> .sys_menu_strings:
 12086 00004CB3 [EC58]              <1>                     dw string.sys_menu_rootpasswd
 12087 00004CB5 [0D59]              <1>                     dw string.sys_menu_admin
 12088 00004CB7 [2E59]              <1>                     dw string.sys_menu_security
 12089 00004CB9 [B55A]              <1>                     dw string.sys_menu_bar
 12090 00004CBB [4F59]              <1>                     dw string.sys_menu_setdef
 12091 00004CBD [7059]              <1>                     dw string.sys_menu_unsetdef
 12092 00004CBF [9159]              <1>                     dw string.sys_menu_delay
 12093 00004CC1 [B259]              <1>                     dw string.sys_menu_bmstyle
 12094 00004CC3 [D359]              <1>                     dw string.sys_menu_remlast
 12095 00004CC5 [F459]              <1>                     dw string.sys_menu_int13ext
 12096 00004CC7 [B55A]              <1>                     dw string.sys_menu_bar
 12097 00004CC9 [0C5A]              <1>                     dw string.sys_menu_rescanall
 12098 00004CCB [2D5A]              <1>                     dw string.sys_menu_rescanpart
 12099 00004CCD [4E5A]              <1>                     dw string.sys_menu_set_ioports
 12100 00004CCF [635A]              <1>                     dw string.sys_menu_set_y2kfix
 12101 00004CD1 [B55A]              <1>                     dw string.sys_menu_bar
 12102 00004CD3 [7F5A]              <1>                     dw string.sys_menu_inst
 12103 00004CD5 [995A]              <1>                     dw string.sys_menu_uninst
 12104                              <1> 
 12105 00004CD7 [D45A]              <1> .cdimg_menu_title   dw string.cdimg_menu_title
 12106 00004CD9 [E65A]              <1> .cdimg_menu_strings dw string.cdimg_menu_noemu
 12107 00004CDB [F35A]              <1>                     dw string.cdimg_menu_120m
 12108 00004CDD [025B]              <1>                     dw string.cdimg_menu_144m
 12109 00004CDF [115B]              <1>                     dw string.cdimg_menu_288m
 12110                              <1> 
 12111 00004CE1 [205B]              <1> .sunday             dw string.sunday
 12112 00004CE3 [245B]              <1> .monday             dw string.monday
 12113 00004CE5 [285B]              <1> .tuesday            dw string.tuesday
 12114 00004CE7 [2C5B]              <1> .wednesday          dw string.wednesday
 12115 00004CE9 [305B]              <1> .thursday           dw string.thursday
 12116 00004CEB [345B]              <1> .friday             dw string.friday
 12117 00004CED [385B]              <1> .saturday           dw string.saturday
 12118                              <1> 
 12119                              <1> end_of_str_idx:
 12120                              <1> 
 12121                              <1> ;=============================================================================
 12122                              <1> ; variable size data
 12123                              <1> ;=============================================================================
 12124                              <1> 
 12125                              <1> ; icon data
 12126                              <1> 
 12127                              <1> ; two bytes corresponding to a char,
 12128                              <1> ; high byte is color, low byte is char code.
 12129                              <1> icon_data:
 12130                              <1> .brand:
 12131 00004CEF DB7CDC7CDD7CDE7C    <1> db  brand_char1, 0x7C, brand_char2, 0x7C, brand_char3, 0x7C, brand_char4, 0x7C
 12132                              <1> 
 12133                              <1> .background:
 12134 00004CF7 B071B071B071B071    <1> db  0xB0, 0x71, 0xB0, 0x71, 0xB0, 0x71, 0xB0, 0x71
 12135                              <1> 
 12136                              <1> ; font data
 12137                              <1> ; each char occupied 17 bytes
 12138                              <1> ; the first bytes is the ascii code used by this char
 12139                              <1> ; the following 16 bytes is font data
 12140                              <1> ;
 12141                              <1> ; NOTE:
 12142                              <1> ;   Do not replace ascii char 0 and 0x0d, 0x1e and 0x1f,
 12143                              <1> ;   these chars have special use.
 12144                              <1> ;
 12145                              <1> font_data:
 12146 00004CFF DB                  <1>   db  start_font
 12147 00004D00 00000000070C08080C- <1>   db  0x00,0x00,0x00,0x00,0x07,0x0c,0x08,0x08,0x0c,0x07,0x00,0x00,0x00,0x00,0xfe,0x00
 12148 00004D09 0700000000FE00      <1>
 12149 00004D10 DC                  <1>   db  start_font+1
 12150 00004D11 01010101FD011F1F03- <1>   db  0x01,0x01,0x01,0x01,0xfd,0x01,0x1f,0x1f,0x03,0xf7,0x0d,0x19,0x31,0x61,0xff,0xff
 12151 00004D1A F70D193161FFFF      <1>
 12152 00004D21 DD                  <1>   db  start_font+2
 12153 00004D22 80808080BF80F0F898- <1>   db  0x80,0x80,0x80,0x80,0xbf,0x80,0xf0,0xf8,0x98,0x9b,0x98,0x98,0x98,0x98,0x9e,0x9e
 12154 00004D2B 9B989898989E9E      <1>
 12155 00004D32 DE                  <1>   db  start_font+3
 12156 00004D33 00000000FF00000000- <1>   db  0x00,0x00,0x00,0x00,0xff,0x00,0x00,0x00,0x00,0xf0,0x18,0x08,0x08,0x18,0xf0,0x00
 12157 00004D3C F018080818F000      <1>
 12158                              <1> .end:
 12159                              <1> 
 12160                              <1> ; keymap
 12161                              <1> ; each entry has two words, the first is original keycode, 
 12162                              <1> ; the second is new keycode.
 12163                              <1> keymap_data:
 12164                              <1> %ifdef KEYMAP_AZERTY
 12165                              <1>   %include "azerty.kbd"
 12166                              <1> %elifdef KEYMAP_QWERTZ
 12167                              <1>   %include "qwertz.kbd"
 12168                              <1> %elifdef KEYMAP_DVORAK
 12169                              <1>   %include "dvorak.kbd"
 12170                              <1> %elifdef KEYMAP_DVORAK_ANSI
 12171                              <1>   %include "dvorak-ansi.kbd"
 12172                              <1> %endif
 12173                              <1> .end:
 12174                              <1> 
 12175                              <1> ; strings
 12176                              <1> ; all strings are zero ending,
 12177                              <1> ; use 0x0d to break string into multi-lines.
 12178                              <1> string:
 12179                              <1> ; used in main window and boot menu.
 12180 00004D43 426F6F74204D656E75- <1> .boot_menu_title                db  'Boot Menu',0
 12181 00004D4C 00                  <1>
 12182 00004D4D 2020202020466C6167- <1> .boot_menu_header               db  '     Flags  '
 12183 00004D56 732020              <1>
 12184 00004D59 20204E756D626572    <1> .boot_menu_header_noflags       db  '  Number'
 12185 00004D61 202054797065202020  <1> .boot_menu_header_nonumber      db  '  Type   '
 12186 00004D6A 20204E616D6500      <1> .boot_menu_header_notype        db  '  Name',0
 12187                              <1> 
 12188                              <1> ; window titles.
 12189 00004D71 41626F757400        <1> .about                          db  'About',0
 12190 00004D77 4572726F7200        <1> .error                          db  'Error',0
 12191 00004D7D 48656C7000          <1> .help                           db  'Help',0
 12192 00004D82 496E666F6D6174696F- <1> .info                           db  'Infomation',0
 12193 00004D8B 6E00                <1>
 12194 00004D8D 496E70757400        <1> .input                          db  'Input',0
 12195                              <1> 
 12196                              <1> ; used in input boxes.
 12197 00004D93 44656C61792074696D- <1> .delay_time                     db  'Delay time: ',0
 12198 00004D9C 653A2000            <1>
 12199 00004DA0 4E616D653A2000      <1> .name                           db  'Name: ',0
 12200 00004DA7 4E657720            <1> .new_root_passwd                db  'New '
 12201 00004DAB 526F6F742070617373- <1> .root_passwd                    db  'Root password: ',0
 12202 00004DB4 776F72643A2000      <1>
 12203 00004DBB 4E657720            <1> .new_record_passwd              db  'New '
 12204 00004DBF 5265636F7264207061- <1> .record_passwd                  db  'Record password: ',0
 12205 00004DC8 7373776F72643A2000  <1>
 12206 00004DD1 526574797065207061- <1> .retype_passwd                  db  'Retype password: ',0
 12207 00004DDA 7373776F72643A2000  <1>
 12208 00004DE3 5363686564756C6520- <1> .input_schedule                 db  'Schedule (hh:mm-hh:mm;days): ',0
 12209 00004DEC 2868683A6D6D2D6868- <1>
 12210 00004DF5 3A6D6D3B6461797329- <1>
 12211 00004DFE 3A2000              <1>
 12212 00004E01 496E707574206B6579- <1> .input_keystrokes               db  'Input keystrokes (max 13 keys)',0x0d
 12213 00004E0A 7374726F6B65732028- <1>
 12214 00004E13 6D6178203133206B65- <1>
 12215 00004E1C 7973290D            <1>
 12216 00004E20 5072657373203C5363- <1>                                 db  'Press <Scroll Lock> to finish,',0x0d
 12217 00004E29 726F6C6C204C6F636B- <1>
 12218 00004E32 3E20746F2066696E69- <1>
 12219 00004E3B 73682C0D            <1>
 12220 00004E3F 4B657920636F646520- <1>                                 db  'Key code = 0x',0
 12221 00004E48 3D20307800          <1>
 12222 00004E4D 0D4B657920636F756E- <1> .key_count                      db  0x0d,'Key count = ',0
 12223 00004E56 74203D2000          <1>
 12224 00004E5B 492F4F204261736520- <1> .io_port                        db  'I/O Base Ports (hex1,hex2): ',0
 12225 00004E64 506F72747320286865- <1>
 12226 00004E6D 78312C68657832293A- <1>
 12227 00004E76 2000                <1>
 12228 00004E78 596561723A2000      <1> .year                           db  'Year: ',0
 12229                              <1> 
 12230                              <1> ; used in record info box.
 12231 00004E7F 202020447269766520- <1> .drive_id                       db       '   Drive ID: ',0
 12232 00004E88 49443A2000          <1>
 12233 00004E8D 202020506172742049- <1> .part_id                        db  '   Part ID: ',0
 12234 00004E96 443A2000            <1>
 12235 00004E9A 0D5265636F72642054- <1> .record_type                    db  0x0d,'Record Type: ',0
 12236 00004EA3 7970653A2000        <1>
 12237 00004EA9 0D5265636F7264204E- <1> .record_name                    db  0x0d,'Record Name: ',0
 12238 00004EB2 616D653A2000        <1>
 12239                              <1> 
 12240 00004EB8 0D0D4175746F204163- <1> .auto_active                    db  0x0d,0x0d,'Auto Active: ',0
 12241 00004EC1 746976653A2000      <1>
 12242 00004EC8 202020204163746976- <1> .active                         db  '    Active: ',0
 12243 00004ED1 653A2000            <1>
 12244 00004ED5 0D20204175746F2048- <1> .auto_hide                      db  0x0d,'  Auto Hide: ',0
 12245 00004EDE 6964653A2000        <1>
 12246 00004EE4 202020204869646465- <1> .hidden                         db  '    Hidden: ',0
 12247 00004EED 6E3A2000            <1>
 12248 00004EF1 0D5377617020647269- <1> .swap_drv                       db  0x0d,'Swap driver: ',0
 12249 00004EFA 7665723A2000        <1>
 12250 00004F00 2020204C6F67696361- <1> .logical                        db  '   Logical: ',0
 12251 00004F09 6C3A2000            <1>
 12252 00004F0D 0D0D4B657920537472- <1> .key_strokes                    db  0x0d,0x0d,'Key Strokes: ',0
 12253 00004F16 6F6B65733A2000      <1>
 12254 00004F1D 202050617373776F72- <1> .password                       db  '  Password: ',0
 12255 00004F26 643A2000            <1>
 12256 00004F2A 0D2020205363686564- <1> .schedule                       db  0x0d,'   Schedule: ',0
 12257 00004F33 756C653A2000        <1>
 12258                              <1> 
 12259 00004F39 59657300            <1> .yes                            db  'Yes',0
 12260 00004F3D 4E6F2000            <1> .no                             db  'No ',0
 12261                              <1> 
 12262                              <1> ; copyright infomation, displayed at the top of the screen.
 12263 00004F41 20536D61727420426F- <1> .copyright          db  ' Smart Boot Manager 3.90.1 | Copyright (C) 2001 Suzhe',0
 12264 00004F4A 6F74204D616E616765- <1>
 12265 00004F53 7220332E39302E3120- <1>
 12266 00004F5C 7C20436F7079726967- <1>
 12267 00004F65 687420284329203230- <1>
 12268 00004F6E 30312053757A686500  <1>
 12269                              <1> 
 12270                              <1> ; hint message, displayed at the bottom of the screen.
 12271 00004F77 207E46317E2D48656C- <1> .hint               db  ' ~F1~-Help  ~F2~-Save  ~F3~-Rename  ~F4~-Active  ~F5~-Hide  ~Tab~-Menu',0
 12272 00004F80 7020207E46327E2D53- <1>
 12273 00004F89 61766520207E46337E- <1>
 12274 00004F92 2D52656E616D652020- <1>
 12275 00004F9B 7E46347E2D41637469- <1>
 12276 00004FA4 766520207E46357E2D- <1>
 12277 00004FAD 4869646520207E5461- <1>
 12278 00004FB6 627E2D4D656E7500    <1>
 12279                              <1> 
 12280                              <1> ; about infomation.
 12281 00004FBE 202020202020202020- <1> .about_content      db  '           Smart Boot Manager 3.90.1',0x0d
 12282 00004FC7 2020536D6172742042- <1>
 12283 00004FD0 6F6F74204D616E6167- <1>
 12284 00004FD9 657220332E39302E31- <1>
 12285 00004FE2 0D                  <1>
 12286 00004FE3 2020436F7079726967- <1>                     db  '  Copyright (C) 2001 Suzhe <su_zhe@sina.com>',0x0d,0x0d
 12287 00004FEC 687420284329203230- <1>
 12288 00004FF5 30312053757A686520- <1>
 12289 00004FFE 3C73755F7A68654073- <1>
 12290 00005007 696E612E636F6D3E0D- <1>
 12291 00005010 0D                  <1>
 12292 00005011 205468697320697320- <1>                     db  ' This is free software, you can redistribute',0x0d
 12293 0000501A 6672656520736F6674- <1>
 12294 00005023 776172652C20796F75- <1>
 12295 0000502C 2063616E2072656469- <1>
 12296 00005035 73747269627574650D  <1>
 12297 0000503E 2020697420616E642F- <1>                     db  '  it and/or modify it under the terms of the',0x0d
 12298 00005047 6F72206D6F64696679- <1>
 12299 00005050 20697420756E646572- <1>
 12300 00005059 20746865207465726D- <1>
 12301 00005062 73206F66207468650D  <1>
 12302 0000506B 2020202020474E5520- <1>                     db  '     GNU General Public License version 2.',0x0d,0x0d
 12303 00005074 47656E6572616C2050- <1>
 12304 0000507D 75626C6963204C6963- <1>
 12305 00005086 656E73652076657273- <1>
 12306 0000508F 696F6E20322E0D0D    <1>
 12307 00005097 546869732070726F67- <1>                     db  'This program comes with ABSOLUTELY NO WARRANTY!',0
 12308 000050A0 72616D20636F6D6573- <1>
 12309 000050A9 207769746820414253- <1>
 12310 000050B2 4F4C5554454C59204E- <1>
 12311 000050BB 4F2057415252414E54- <1>
 12312 000050C4 592100              <1>
 12313                              <1> 
 12314                              <1> ; help infomation.
 12315                              <1> .help_content:
 12316 000050C7 202020202020463120- <1>         db '      F1 = Help                  Ctrl+F1 = About',0x0d
 12317 000050D0 3D2048656C70202020- <1>
 12318 000050D9 202020202020202020- <1>
 12319 000050E2 202020202020437472- <1>
 12320 000050EB 6C2B4631203D204162- <1>
 12321 000050F4 6F75740D            <1>
 12322 000050F8 202020202020463220- <1>         db '      F2 = Save                       F3 = Rename',0x0d
 12323 00005101 3D2053617665202020- <1>
 12324 0000510A 202020202020202020- <1>
 12325 00005113 202020202020202020- <1>
 12326 0000511C 20204633203D205265- <1>
 12327 00005125 6E616D650D          <1>
 12328 0000512A 202020202020463420- <1>         db '      F4 = Mark active                F5 = Hide/unhide',0x0d
 12329 00005133 3D204D61726B206163- <1>
 12330 0000513C 746976652020202020- <1>
 12331 00005145 202020202020202020- <1>
 12332 0000514E 20204635203D204869- <1>
 12333 00005157 64652F756E68696465- <1>
 12334 00005160 0D                  <1>
 12335 00005161 202020202020463620- <1>         db '      F6 = Toggle auto active         F7 = Toggle auto hide',0x0d
 12336 0000516A 3D20546F67676C6520- <1>
 12337 00005173 6175746F2061637469- <1>
 12338 0000517C 766520202020202020- <1>
 12339 00005185 20204637203D20546F- <1>
 12340 0000518E 67676C65206175746F- <1>
 12341 00005197 20686964650D        <1>
 12342 0000519D 202020202020463820- <1>         db '      F8 = Set default          Shift+F8 = Unset default',0x0d
 12343 000051A6 3D2053657420646566- <1>
 12344 000051AF 61756C742020202020- <1>
 12345 000051B8 202020202053686966- <1>
 12346 000051C1 742B4638203D20556E- <1>
 12347 000051CA 736574206465666175- <1>
 12348 000051D3 6C740D              <1>
 12349 000051D6 20204374726C2B4420- <1>         db '  Ctrl+D = Delete                 Ctrl+P = Duplicate',0x0d
 12350 000051DF 3D2044656C65746520- <1>
 12351 000051E8 202020202020202020- <1>
 12352 000051F1 202020202020204374- <1>
 12353 000051FA 726C2B50203D204475- <1>
 12354 00005203 706C69636174650D    <1>
 12355 0000520B 20204374726C2B5520- <1>         db '  Ctrl+U = Move record up         Ctrl+N = Move record down',0x0d
 12356 00005214 3D204D6F7665207265- <1>
 12357 0000521D 636F72642075702020- <1>
 12358 00005226 202020202020204374- <1>
 12359 0000522F 726C2B4E203D204D6F- <1>
 12360 00005238 7665207265636F7264- <1>
 12361 00005241 20646F776E0D        <1>
 12362 00005247 20204374726C2B5320- <1>         db '  Ctrl+S = Set/unset schedule     Ctrl+T = Set delay time',0x0d
 12363 00005250 3D205365742F756E73- <1>
 12364 00005259 657420736368656475- <1>
 12365 00005262 6C6520202020204374- <1>
 12366 0000526B 726C2B54203D205365- <1>
 12367 00005274 742064656C61792074- <1>
 12368 0000527D 696D650D            <1>
 12369 00005281 20204374726C2B4B20- <1>         db '  Ctrl+K = Set/unset keystrokes   / or ? = Show information',0x0d
 12370 0000528A 3D205365742F756E73- <1>
 12371 00005293 6574206B6579737472- <1>
 12372 0000529C 6F6B65732020202F20- <1>
 12373 000052A5 6F72203F203D205368- <1>
 12374 000052AE 6F7720696E666F726D- <1>
 12375 000052B7 6174696F6E0D        <1>
 12376 000052BD 20204374726C2B4920- <1>         db '  Ctrl+I = Rescan all records     Ctrl+H = Rescan all partitions',0x0d,
 12377 000052C6 3D2052657363616E20- <1>
 12378 000052CF 616C6C207265636F72- <1>
 12379 000052D8 647320202020204374- <1>
 12380 000052E1 726C2B48203D205265- <1>
 12381 000052EA 7363616E20616C6C20- <1>
 12382 000052F3 706172746974696F6E- <1>
 12383 000052FC 730D                <1>
 12384 000052FE 20204374726C2B5820- <1>         db '  Ctrl+X = Toggle swap driver id  Ctrl+F = Show/hide flags',0x0d
 12385 00005307 3D20546F67676C6520- <1>
 12386 00005310 737761702064726976- <1>
 12387 00005319 657220696420204374- <1>
 12388 00005322 726C2B46203D205368- <1>
 12389 0000532B 6F772F686964652066- <1>
 12390 00005334 6C6167730D          <1>
 12391 00005339 20204374726C2B4C20- <1>         db '  Ctrl+L = Toggle remember the last booted record',0x0d
 12392 00005342 3D20546F67676C6520- <1>
 12393 0000534B 72656D656D62657220- <1>
 12394 00005354 746865206C61737420- <1>
 12395 0000535D 626F6F746564207265- <1>
 12396 00005366 636F72640D          <1>
 12397 0000536B 202020202020463920- <1>         db '      F9 = Change boot record password',0x0d
 12398 00005374 3D204368616E676520- <1>
 12399 0000537D 626F6F74207265636F- <1>
 12400 00005386 72642070617373776F- <1>
 12401 0000538F 72640D              <1>
 12402 00005392 202020202046313020- <1>         db '     F10 = Change root password',0x0d
 12403 0000539B 3D204368616E676520- <1>
 12404 000053A4 726F6F742070617373- <1>
 12405 000053AD 776F72640D          <1>
 12406 000053B2 4374726C2B46313020- <1>         db 'Ctrl+F10 = Enter/leave Administrator mode',0x0d
 12407 000053BB 3D20456E7465722F6C- <1>
 12408 000053C4 656176652041646D69- <1>
 12409 000053CD 6E6973747261746F72- <1>
 12410 000053D6 206D6F64650D        <1>
 12411 000053DC 20416C742B46313020- <1>         db ' Alt+F10 = Enter/leave Security Lock mode',0x0d
 12412 000053E5 3D20456E7465722F6C- <1>
 12413 000053EE 656176652053656375- <1>
 12414 000053F7 72697479204C6F636B- <1>
 12415 00005400 206D6F64650D        <1>
 12416 00005406 202020202054616220- <1>         db '     Tab = Popup command menu',0x0d
 12417 0000540F 3D20506F7075702063- <1>
 12418 00005418 6F6D6D616E64206D65- <1>
 12419 00005421 6E750D              <1>
 12420 00005424 20204374726C2B5120- <1>         db '  Ctrl+Q = Quit to BIOS         Ctrl+F12 = Power off',0
 12421 0000542D 3D205175697420746F- <1>
 12422 00005436 2042494F5320202020- <1>
 12423 0000543F 20202020204374726C- <1>
 12424 00005448 2B463132203D20506F- <1>
 12425 00005451 776572206F666600    <1>
 12426                              <1> 
 12427                              <1> ; normal messages.
 12428 00005459 4368616E6765732073- <1> .changes_saved      db  'Changes saved.',0
 12429 00005462 617665642E00        <1>
 12430 00005468 50617373776F726420- <1> .passwd_changed     db  'Password changed.',0
 12431 00005471 6368616E6765642E00  <1>
 12432 0000547A 536176652074686520- <1> .ask_save_changes   db  'Save the changes (y/n)?',0
 12433 00005483 6368616E6765732028- <1>
 12434 0000548C 792F6E293F00        <1>
 12435                              <1> 
 12436                              <1> ; error messages.
 12437 00005492 57726F6E6720706173- <1> .wrong_passwd       db  'Wrong password!',0
 12438 0000549B 73776F72642100      <1>
 12439 000054A2 4469736B206572726F- <1> .disk_error         db  'Disk error! 0x',0
 12440 000054AB 722120307800        <1>
 12441 000054B1 4D61726B2061637469- <1> .mark_act_failed    db  'Mark active failed!',0
 12442 000054BA 7665206661696C6564- <1>
 12443 000054C3 2100                <1>
 12444 000054C5 486964652F756E6869- <1> .toggle_hid_failed  db  'Hide/unhide failed!',0
 12445 000054CE 6465206661696C6564- <1>
 12446 000054D7 2100                <1>
 12447 000054D9 4E6F204F7065726174- <1> .no_system          db  'No Operating System!',0x0d
 12448 000054E2 696E67205379737465- <1>
 12449 000054EB 6D210D              <1>
 12450 000054EE 5265706C6163652061- <1>                     db  'Replace a disk and try again.',0
 12451 000054F7 206469736B20616E64- <1>
 12452 00005500 207472792061676169- <1>
 12453 00005509 6E2E00              <1>
 12454 0000550C 496E76616C69642062- <1> .invalid_record     db  'Invalid boot record!',0
 12455 00005515 6F6F74207265636F72- <1>
 12456 0000551E 642100              <1>
 12457 00005521 496E76616C69642073- <1> .invalid_schedule   db  'Invalid schedule time!',0
 12458 0000552A 63686564756C652074- <1>
 12459 00005533 696D652100          <1>
 12460 00005538 5375726520746F2069- <1> .inst_confirm       db  'Sure to install Smart BootManager ',
 12461 00005541 6E7374616C6C20536D- <1>
 12462 0000554A 61727420426F6F744D- <1>
 12463 00005553 616E6167657220      <1>
 12464 0000555A 696E746F2064726976- <1>                     db  'into driver ',0
 12465 00005563 65722000            <1>
 12466 00005567 496E7374616C6C6174- <1> .inst_ok            db  'Installation is successful!',0
 12467 00005570 696F6E206973207375- <1>
 12468 00005579 636365737366756C21- <1>
 12469 00005582 00                  <1>
 12470 00005583 41626F727420746865- <1> .inst_abort         db  'Abort the installation.',0
 12471 0000558C 20696E7374616C6C61- <1>
 12472 00005595 74696F6E2E00        <1>
 12473 0000559B 5375726520746F2075- <1> .uninst_confirm     db  'Sure to uninstall Smart BootManager?',0x0d,0
 12474 000055A4 6E696E7374616C6C20- <1>
 12475 000055AD 536D61727420426F6F- <1>
 12476 000055B6 744D616E616765723F- <1>
 12477 000055BF 0D00                <1>
 12478 000055C1 556E696E7374616C6C- <1> .uninst_ok          db  'Uninstallation is successful!',0x0d
 12479 000055CA 6174696F6E20697320- <1>
 12480 000055D3 737563636573736675- <1>
 12481 000055DC 6C210D              <1>
 12482 000055DF 436F6D707574657220- <1>                     db  'Computer will be restarted.',0
 12483 000055E8 77696C6C2062652072- <1>
 12484 000055F1 65737461727465642E- <1>
 12485 000055FA 00                  <1>
 12486 000055FB 41626F727420746865- <1> .uninst_abort       db  'Abort the uninstallation.',0
 12487 00005604 20756E696E7374616C- <1>
 12488 0000560D 6C6174696F6E2E00    <1>
 12489 00005615 507265737320592074- <1> .confirm            db  'Press Y to continue, other key to abort.',0
 12490 0000561E 6F20636F6E74696E75- <1>
 12491 00005627 652C206F7468657220- <1>
 12492 00005630 6B657920746F206162- <1>
 12493 00005639 6F72742E00          <1>
 12494 0000563E 536D61727420426F6F- <1> .no_sbml            db  'Smart Boot Manager Loader missing ',0x0d
 12495 00005647 74204D616E61676572- <1>
 12496 00005650 204C6F61646572206D- <1>
 12497 00005659 697373696E67200D    <1>
 12498 00005661 6F722076657273696F- <1>                     db  'or version mismatch!',0
 12499 0000566A 6E206D69736D617463- <1>
 12500 00005673 682100              <1>
 12501 00005676 496E76616C69642049- <1> .invalid_ioports    db  'Invalid I/O Ports!',0
 12502 0000567F 2F4F20506F72747321- <1>
 12503 00005688 00                  <1>
 12504                              <1> 
 12505                              <1> ; command menu strings
 12506                              <1> ; main menu
 12507 00005689 4D61696E204D656E75- <1> .main_menu_title     db  'Main Menu',0
 12508 00005692 00                  <1>
 12509 00005693 48656C702020202020- <1> .main_menu_help      db  'Help             ~F1~',0
 12510 0000569C 20202020202020207E- <1>
 12511 000056A5 46317E00            <1>
 12512 000056A9 41626F757420202020- <1> .main_menu_about     db  'About       ~Ctrl-F1~',0
 12513 000056B2 2020207E4374726C2D- <1>
 12514 000056BB 46317E00            <1>
 12515 000056BF 426F6F7420697400    <1> .main_menu_bootit    db  'Boot it',0
 12516 000056C7 426F6F742050726576- <1> .main_menu_bootprev  db  'Boot Previous MBR',0
 12517 000056D0 696F7573204D425200  <1>
 12518 000056D9 517569742020202020- <1> .main_menu_quit      db  'Quit         ~Ctrl-Q~',0
 12519 000056E2 202020207E4374726C- <1>
 12520 000056EB 2D517E00            <1>
 12521 000056EF 506F776572204F6666- <1> .main_menu_poweroff  db  'Power Off  ~Ctrl-F12~',0
 12522 000056F8 20207E4374726C2D46- <1>
 12523 00005701 31327E00            <1>
 12524 00005705 5265636F7264205365- <1> .main_menu_recordset db  'Record Settings  ->',0
 12525 0000570E 7474696E677320202D- <1>
 12526 00005717 3E00                <1>
 12527 00005719 53797374656D205365- <1> .main_menu_sysset    db  'System Settings  ->',0
 12528 00005722 7474696E677320202D- <1>
 12529 0000572B 3E00                <1>
 12530 0000572D 53617665204368616E- <1> .main_menu_save      db  'Save Changes     ~F2~',0
 12531 00005736 67657320202020207E- <1>
 12532 0000573F 46327E00            <1>
 12533 00005743 2D2D2D2D2D2D2D2D2D- <1> .main_menu_bar       db  '-------------------',0
 12534 0000574C 2D2D2D2D2D2D2D2D2D- <1>
 12535 00005755 2D00                <1>
 12536                              <1> 
 12537                              <1> ; record settings menu
 12538 00005757 5265636F7264205365- <1> .record_menu_title    db  'Record Settings',0
 12539 00005760 7474696E677300      <1>
 12540 00005767 496E666F726D617469- <1> .record_menu_info     db  'Information     ~/ or ?~',0
 12541 00005770 6F6E20202020207E2F- <1>
 12542 00005779 206F72203F7E00      <1>
 12543 00005780 4E616D652020202020- <1> .record_menu_name     db  'Name                ~F3~',0
 12544 00005789 202020202020202020- <1>
 12545 00005792 20207E46337E00      <1>
 12546 00005799 50617373776F726420- <1> .record_menu_passwd   db  'Password            ~F9~',0
 12547 000057A2 202020202020202020- <1>
 12548 000057AB 20207E46397E00      <1>
 12549 000057B2 5363686564756C6520- <1> .record_menu_schedule db  'Schedule        ~Ctrl-S~',0
 12550 000057BB 202020202020207E43- <1>
 12551 000057C4 74726C2D537E00      <1>
 12552 000057CB 4B65797374726F6B65- <1> .record_menu_keys     db  'Keystrokes      ~Ctrl-K~',0
 12553 000057D4 732020202020207E43- <1>
 12554 000057DD 74726C2D4B7E00      <1>
 12555 000057E4 4D61726B2041637469- <1> .record_menu_act      db  'Mark Active         ~F4~',0
 12556 000057ED 766520202020202020- <1>
 12557 000057F6 20207E46347E00      <1>
 12558 000057FD 486964652F756E6869- <1> .record_menu_hide     db  'Hide/unhide         ~F5~',0
 12559 00005806 646520202020202020- <1>
 12560 0000580F 20207E46357E00      <1>
 12561 00005816 4175746F2041637469- <1> .record_menu_autoact  db  'Auto Active         ~F6~',0
 12562 0000581F 766520202020202020- <1>
 12563 00005828 20207E46367E00      <1>
 12564 0000582F 4175746F2048696465- <1> .record_menu_autohide db  'Auto Hide           ~F7~',0
 12565 00005838 202020202020202020- <1>
 12566 00005841 20207E46377E00      <1>
 12567 00005848 537761702044726976- <1> .record_menu_swapdrv  db  'Swap Driver ID  ~Ctrl-X~',0
 12568 00005851 657220494420207E43- <1>
 12569 0000585A 74726C2D587E00      <1>
 12570 00005861 44656C657465202020- <1> .record_menu_del      db  'Delete          ~Ctrl-D~',0
 12571 0000586A 202020202020207E43- <1>
 12572 00005873 74726C2D447E00      <1>
 12573 0000587A 4475706C6963617465- <1> .record_menu_dup      db  'Duplicate       ~Ctrl-P~',0
 12574 00005883 202020202020207E43- <1>
 12575 0000588C 74726C2D507E00      <1>
 12576 00005893 4D6F76652055702020- <1> .record_menu_moveup   db  'Move Up         ~Ctrl-U~',0
 12577 0000589C 202020202020207E43- <1>
 12578 000058A5 74726C2D557E00      <1>
 12579 000058AC 4D6F766520446F776E- <1> .record_menu_movedown db  'Move Down       ~Ctrl-N~',0
 12580 000058B5 202020202020207E43- <1>
 12581 000058BE 74726C2D4E7E00      <1>
 12582 000058C5 2D2D2D2D2D2D2D2D2D- <1> .record_menu_bar      db  '----------------------',0
 12583 000058CE 2D2D2D2D2D2D2D2D2D- <1>
 12584 000058D7 2D2D2D2D00          <1>
 12585                              <1> 
 12586                              <1> ; system setting menu
 12587 000058DC 53797374656D205365- <1> .sys_menu_title       db  'System Settings',0
 12588 000058E5 7474696E677300      <1>
 12589 000058EC 526F6F742050617373- <1> .sys_menu_rootpasswd  db  'Root Password              ~F10~',0
 12590 000058F5 776F72642020202020- <1>
 12591 000058FE 202020202020202020- <1>
 12592 00005907 7E4631307E00        <1>
 12593 0000590D 546F67676C65204164- <1> .sys_menu_admin       db  'Toggle Admin Mode     ~Ctrl-F10~',0
 12594 00005916 6D696E204D6F646520- <1>
 12595 0000591F 202020207E4374726C- <1>
 12596 00005928 2D4631307E00        <1>
 12597 0000592E 546F67676C65205365- <1> .sys_menu_security    db  'Toggle Security Mode   ~Alt-F10~',0
 12598 00005937 637572697479204D6F- <1>
 12599 00005940 64652020207E416C74- <1>
 12600 00005949 2D4631307E00        <1>
 12601 0000594F 536574204465666175- <1> .sys_menu_setdef      db  'Set Default Record          ~F8~',0
 12602 00005958 6C74205265636F7264- <1>
 12603 00005961 202020202020202020- <1>
 12604 0000596A 207E46387E00        <1>
 12605 00005970 556E73657420446566- <1> .sys_menu_unsetdef    db  'Unset Default Record  ~Shift-F8~',0
 12606 00005979 61756C74205265636F- <1>
 12607 00005982 726420207E53686966- <1>
 12608 0000598B 742D46387E00        <1>
 12609 00005991 5365742044656C6179- <1> .sys_menu_delay       db  'Set Delay Time          ~Ctrl-T~',0
 12610 0000599A 2054696D6520202020- <1>
 12611 000059A3 2020202020207E4374- <1>
 12612 000059AC 726C2D547E00        <1>
 12613 000059B2 4368616E676520426F- <1> .sys_menu_bmstyle     db  'Change Boot Menu Style  ~Ctrl-F~',0
 12614 000059BB 6F74204D656E752053- <1>
 12615 000059C4 74796C6520207E4374- <1>
 12616 000059CD 726C2D467E00        <1>
 12617 000059D3 546F67676C65205265- <1> .sys_menu_remlast     db  'Toggle Remember Last    ~Ctrl-L~',0
 12618 000059DC 6D656D626572204C61- <1>
 12619 000059E5 7374202020207E4374- <1>
 12620 000059EE 726C2D4C7E00        <1>
 12621 000059F4 546F67676C65204578- <1> .sys_menu_int13ext    db  'Toggle Extended Int 13H',0
 12622 000059FD 74656E64656420496E- <1>
 12623 00005A06 742031334800        <1>
 12624 00005A0C 52657363616E20416C- <1> .sys_menu_rescanall   db  'Rescan All Boot Records ~Ctrl-I~',0
 12625 00005A15 6C20426F6F74205265- <1>
 12626 00005A1E 636F726473207E4374- <1>
 12627 00005A27 726C2D497E00        <1>
 12628 00005A2D 52657363616E20416C- <1> .sys_menu_rescanpart  db  'Rescan All Partitions   ~Ctrl-H~',0
 12629 00005A36 6C2050617274697469- <1>
 12630 00005A3F 6F6E732020207E4374- <1>
 12631 00005A48 726C2D487E00        <1>
 12632 00005A4E 5365742043442D524F- <1> .sys_menu_set_ioports db  'Set CD-ROM I/O Ports',0
 12633 00005A57 4D20492F4F20506F72- <1>
 12634 00005A60 747300              <1>
 12635 00005A63 536574207965617220- <1> .sys_menu_set_y2kfix  db  'Set year (fix Y2K BIOS bug)',0
 12636 00005A6C 286669782059324B20- <1>
 12637 00005A75 42494F532062756729- <1>
 12638 00005A7E 00                  <1>
 12639 00005A7F 496E7374616C6C2053- <1> .sys_menu_inst        db  'Install Smart BootManager',0
 12640 00005A88 6D61727420426F6F74- <1>
 12641 00005A91 4D616E6167657200    <1>
 12642 00005A99 556E696E7374616C6C- <1> .sys_menu_uninst      db  'Uninstall Smart BootManager',0
 12643 00005AA2 20536D61727420426F- <1>
 12644 00005AAB 6F744D616E61676572- <1>
 12645 00005AB4 00                  <1>
 12646 00005AB5 2D2D2D2D2D2D2D2D2D- <1> .sys_menu_bar         db  '------------------------------',0
 12647 00005ABE 2D2D2D2D2D2D2D2D2D- <1>
 12648 00005AC7 2D2D2D2D2D2D2D2D2D- <1>
 12649 00005AD0 2D2D2D00            <1>
 12650                              <1> 
 12651 00005AD4 43686F6F7365206120- <1> .cdimg_menu_title     db  'Choose a CD Image',0
 12652 00005ADD 434420496D61676500  <1>
 12653 00005AE6 4E6F20456D756C6174- <1> .cdimg_menu_noemu     db  'No Emulation',0
 12654 00005AEF 696F6E00            <1>
 12655 00005AF3 312E32204D20446973- <1> .cdimg_menu_120m      db  '1.2 M Diskette',0
 12656 00005AFC 6B6574746500        <1>
 12657 00005B02 312E34344D20446973- <1> .cdimg_menu_144m      db  '1.44M Diskette',0
 12658 00005B0B 6B6574746500        <1>
 12659 00005B11 322E38384D20446973- <1> .cdimg_menu_288m      db  '2.88M Diskette',0
 12660 00005B1A 6B6574746500        <1>
 12661                              <1> 
 12662 00005B20 53756E00            <1> .sunday              db 'Sun',0
 12663 00005B24 4D6F6E00            <1> .monday              db 'Mon',0
 12664 00005B28 54756500            <1> .tuesday             db 'Tue',0
 12665 00005B2C 57656400            <1> .wednesday           db 'Wed',0
 12666 00005B30 54687500            <1> .thursday            db 'Thu',0
 12667 00005B34 46726900            <1> .friday              db 'Fri',0
 12668 00005B38 53617400            <1> .saturday            db 'Sat',0
 12669                              <1> 
 12670                              <1> ; END OF THEME.
 12671                              <1> end_of_theme:
 12672                              <1> 
 12673                              <1> ; vi:ts=8:et:nowrap
 12674                                  %endif
 12675                                  
 12676                                  end_of_sbm:
 12677                                  ;=============================================================================
 12678                                  ; temp data area
 12679                                  ;=============================================================================
 12680                                  SIZE_OF_SBMK equ ($-$$)
 12681                                  	section .bss
 12682                                  
 12683                                  %ifndef EMULATE_PROG
 12684 00000000 <res 000019F4>                  resb MAX_SBM_SIZE - SIZE_OF_SBMK   ; skip enough space for theme.
 12685                                  %endif
 12686                                   
 12687                                  start_of_tmp_data:
 12688                                  %include "tempdata.asm"
 12689                              <1> ; tempdata.asm
 12690                              <1> ;
 12691                              <1> ; some temp data for Smart Boot Manager
 12692                              <1> ;
 12693                              <1> ; Copyright (C) 2000, Suzhe. See file COPYING for details.
 12694                              <1> ;
 12695                              <1> 
 12696                              <1> ;==============================================================================
 12697                              <1> ;temp data area for hd_io.asm
 12698                              <1> ;==============================================================================
 12699                              <1> %ifdef HAVE_HD_IO
 12700                              <1> %ifndef HD_IO_TEMPDATA
 12701                              <1> %define HD_IO_TEMPDATA
 12702                              <1> 
 12703                              <1> hdio_tmp:
 12704 000019F4 <res 00000008>      <1> .cdbc_cmd	resb SIZE_OF_CDBC_CMD
 12705 000019FC <res 00000042>      <1> .extparam	resb SIZE_OF_EXTPARAM
 12706 00001A3E <res 00000010>      <1> .int13ext	resb SIZE_OF_INT13EXT
 12707 00001A4E <res 0000000A>      <1> .driveinfo	resb SIZE_OF_DRIVEINFO
 12708 00001A58 <res 00000001>      <1> .disk_errno	resb 1
 12709                              <1> 
 12710                              <1> %endif
 12711                              <1> %endif
 12712                              <1> 
 12713                              <1> ;==============================================================================
 12714                              <1> ;temp data area for knl.asm
 12715                              <1> ;==============================================================================
 12716                              <1> %ifdef HAVE_KNL
 12717                              <1> %ifndef KNL_TEMPDATA
 12718                              <1> %define KNL_TEMPDATA
 12719                              <1> 
 12720                              <1> knl_tmp:
 12721 00001A59 <res 00000001>      <1> .good_record_num	resb 1
 12722 00001A5A <res 00000001>      <1> .max_record_num		resb 1
 12723 00001A5B <res 00000001>      <1> .part_id		resb 1
 12724 00001A5C <res 00000004>      <1> .logi_father		resd 1
 12725                              <1> 
 12726 00001A60 <res 00000001>      <1> .floppy_num		resb 1
 12727 00001A61 <res 00000013>      <1> .cdemu_spec		resb SIZE_OF_CDEMU_SPEC
 12728                              <1> 
 12729 00001A74 <res 00000800>      <1> .disk_buf1		resb 2048
 12730 00002274 <res 00000800>      <1> .disk_buf2		resb 2048
 12731                              <1> 
 12732                              <1> %endif
 12733                              <1> %endif
 12734                              <1> 
 12735                              <1> ;==============================================================================
 12736                              <1> ;temp data area for ui.asm
 12737                              <1> ;==============================================================================
 12738                              <1> %ifdef HAVE_UI
 12739                              <1> %ifndef UI_TEMPDATA
 12740                              <1> %define UI_TEMPDATA
 12741                              <1> 
 12742                              <1> ui_tmp:
 12743 00002A74 <res 00000001>      <1> .left_col	resb  1
 12744 00002A75 <res 00000001>      <1> .top_row	resb  1
 12745 00002A76 <res 00000001>      <1> .right_col	resb  1
 12746 00002A77 <res 00000001>      <1> .bottom_row	resb  1
 12747 00002A78 <res 00000001>      <1> .frame_attr	resb  1
 12748 00002A79 <res 00000001>      <1> .title_attr	resb  1
 12749 00002A7A <res 00000002>      <1> .focus_win	resw  1
 12750 00002A7C <res 00000002>      <1> .root_win	resw  1
 12751 00002A7E <res 0000001A>      <1> .def_root_win	resb SIZE_OF_STRUC_WINDOW
 12752 00002A98 <res 00000020>      <1> .tmp_msgbox	resb SIZE_OF_STRUC_MESSAGE_BOX
 12753 00002AB8 <res 00000029>      <1> .tmp_inputbox	resb SIZE_OF_STRUC_INPUT_BOX
 12754 00002AE1 <res 0000002B>      <1> .tmp_menubox	resb SIZE_OF_STRUC_MENU_BOX
 12755 00002B0C <res 00000100>      <1> .tmp_buf	resb  256
 12756 00002C0C <res 00000100>      <1> .tmp_buf1	resb  256
 12757                              <1> 
 12758                              <1> %endif
 12759                              <1> %endif
 12760                              <1> 
 12761                              <1> ;==============================================================================
 12762                              <1> ;temp data area for utils.asm
 12763                              <1> ;==============================================================================
 12764                              <1> %ifdef HAVE_UTILS
 12765                              <1> %ifndef UTILS_TEMPDATA
 12766                              <1> %define UTILS_TEMPDATA
 12767                              <1> 
 12768                              <1> utils_tmp:
 12769 00002D0C <res 00000001>      <1> .kbd_work	       resb  1
 12770 00002D0D <res 00000001>      <1> .kbd_last_shift        resb  1
 12771 00002D0E <res 00000001>      <1> .kbd_bypass_next_shift resb 1
 12772                              <1> 
 12773                              <1> %endif
 12774                              <1> %endif
 12775                              <1> 
 12776                              <1> ;=============================================================================
 12777                              <1> ;temp data area for main.asm
 12778                              <1> ;=============================================================================
 12779                              <1> %ifdef HAVE_MAIN_PROG
 12780                              <1> %ifndef MAIN_TEMPDATA
 12781                              <1> %define MAIN_TEMPDATA
 12782                              <1> 
 12783                              <1> main_tmp:
 12784 00002D0F <res 00000020>      <1> .good_record_list    resb MAX_RECORD_NUM
 12785                              <1> 
 12786 00002D2F <res 00000001>      <1> .time_count         resb  1                       ;
 12787 00002D30 <res 00000002>      <1> .ticks_count        resw  1                       ; used in get_key func
 12788 00002D32 <res 00000001>      <1> .key_pressed        resb  1                       ;
 12789 00002D33 <res 00000002>      <1> .keycode            resw  1
 12790                              <1> 
 12791 00002D35 <res 00000001>      <1> .change_occured     resb  1                       ; if change occured.
 12792 00002D36 <res 00000001>      <1> .root_login         resb  1                       ; root login state.
 12793                              <1> 
 12794 00002D37 <res 00000002>      <1> .last_time          resw  1
 12795                              <1> 
 12796 00002D39 <res 00000002>      <1> .schedule_begin  resw  1
 12797 00002D3B <res 00000002>      <1> .schedule_end    resw  1
 12798 00002D3D <res 00000002>      <1> .schedule_day    resw  1
 12799                              <1> 
 12800 00002D3F <res 00000002>      <1> .keystroke_ptr   resw  1
 12801 00002D41 <res 00000001>      <1> .keystroke_num   resb  1
 12802 00002D42 <res 00000001>      <1> .keystroke_max   resb  1
 12803 00002D43 <res 0000002B>      <1> .ikbox           resb SIZE_OF_STRUC_MENU_BOX
 12804                              <1> 
 12805 00002D6E <res 00000800>      <1> .records_buf     resb MAX_RECORD_NUM * SIZE_OF_BOOTRECORD
 12806 0000356E <res 00000050>      <1> .record_string   resb 80
 12807 000035BE <res 00000100>      <1> .dialog_buf      resb 256
 12808 000036BE <res 00000050>      <1> .root_buf        resb 80
 12809                              <1> 
 12810                              <1> %endif
 12811                              <1> %endif
 12812                              <1> 
 12813                              <1> %ifdef HAVE_MYINT13H
 12814                              <1> %ifndef MYINT13H_TEMPDATA
 12815                              <1> %define MYINT13H_TEMPDATA
 12816                              <1> 
 12817                              <1> myint13h_tmp:
 12818 0000370E <res 00000002>      <1> .edd30_off  resw 1
 12819 00003710 <res 00000002>      <1> .edd30_seg  resw 1
 12820                              <1> 
 12821                              <1> %endif
 12822                              <1> %endif
 12823                              <1> 
 12824                                  end_of_tmp_data:
 12825                                  
 12826                                  ; vi:ts=8:et:nowrap
